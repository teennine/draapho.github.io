<!doctype html>




<html class="theme-next mist">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.2" />






<meta name="description" content="Embedded System, IoT, M2M">
<meta property="og:type" content="website">
<meta property="og:title" content="DRA&amp;PHO">
<meta property="og:url" content="https://draapho.github.io/page/3/index.html">
<meta property="og:site_name" content="DRA&amp;PHO">
<meta property="og:description" content="Embedded System, IoT, M2M">
<meta property="og:locale" content="en">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="DRA&amp;PHO">
<meta name="twitter:description" content="Embedded System, IoT, M2M">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: false,
    duoshuo: {
      userId: '0',
      author: 'Author'
    }
  };
</script>




  <link rel="canonical" href="https://draapho.github.io/page/3/"/>


  <title> DRA&PHO </title>
</head>

<body itemscope itemtype="//schema.org/WebPage" lang="en">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="//schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">DRA&PHO</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">thinking & logging</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            Categories
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            Search
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup">
 <span class="search-icon fa fa-search"></span>
 <input type="text" id="local-search-input">
 <div id="local-search-result"></div>
 <span class="popup-btn-close">close</span>
</div>


    </div>
  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/11/29/1819-start-meditation/" itemprop="url">
                  实修开始
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2018-11-29T00:00:00+11:00" content="2018-11-29">
              2018-11-29
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/thoughts/" itemprop="url" rel="index">
                    <span itemprop="name">thoughts</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h1><ul>
<li><a href="https://draapho.github.io/2017/10/09/1728-ultimatethink/">我的终极思考</a></li>
<li><a href="https://draapho.github.io/2018/04/12/1815-suspend/">博客暂停更新</a></li>
<li><a href="https://draapho.github.io/2018/07/08/1818-buddhism/">佛教学习资料及一些感想</a></li>
<li><a href="https://draapho.github.io/2018/11/29/1819-start-meditation/">实修开始</a></li>
<li><a href="https://draapho.github.io/2018/12/27/1820-meditation-LCP/">闻思修</a></li>
<li><a href="https://draapho.github.io/2019/03/19/1901-tittle-tattle/">杂谈</a></li>
<li><a href="https://draapho.github.io/2019/07/05/1908-unified/">各种【一元化思维】的谬误——从“星座理论”到“共产主义社会”</a></li>
<li><a href="https://draapho.github.io/2019/07/25/1909-TCM_science/">好吧，我们就从头聊一聊科学、中医、东西方文明及其不同思维模式的话题</a></li>
<li><a href="https://draapho.github.io/2019/07/26/1910-satori/">开悟是怎样一种体验？</a></li>
<li><a href="https://draapho.github.io/2020/04/15/2003-letthebulletsfly/">解构&lt;让子弹飞&gt;</a></li>
<li><a href="https://draapho.github.io/2021/01/28/2101-confusion/">与神对话读后感-矛盾与困惑</a></li>
<li><a href="https://draapho.github.io/2021/02/09/2102-intermittent/">一张简单图片演示的“甚深佛法”</a></li>
<li><a href="https://draapho.github.io/2021/02/13/2104-satori/">修行总领——明心见性</a></li>
</ul>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>接触冥想和佛教后, 虽然推倒了唯物论体系, 但始终对于修炼中的诸多规矩和方法存疑(如吃素禁欲出家等问题), 对佛教世界观存疑(主要是被后人过渡解读, 如极乐世界之类的概念). 所以, 近两年只能说处于一种半信半疑, 三天晒网两天打鱼的冥想打坐状态.</p>
<p>即便如此, 在修炼心性, 学习炒股的过程中, 依旧收获良多. 简单总结如下:</p>
<ul>
<li>一切皆相对: 本质就是”无常”. 贪嗔, 苦乐, 正邪, 美丑, 好坏, 时空, 都是个体的主观感受. 认识到这一点, 就能破很多象了, 譬如:<ul>
<li>欲望的相: 人好甜美之食, 恶酸臭之物. 但苍蝇反之. 人和苍蝇从物质上讲没什么区别哦, 所以只是需求不同导致的感受不同罢了!</li>
<li>宗教的相: 凡是用欲望来吸引教徒的, 皆不可信! 诸如天堂的黄金美女, 极乐世界的永恒安乐(一切无常, 哪来的永恒?).这也是笔者之前最终选择原始佛教的原因(但又比较排斥”一切皆苦”的论断, 因为这是一种主观判断, 不够客观).</li>
<li>科学的相: 经典物理有绝对时空观, 广义相对论有绝对光速. 物理学最严重的问题是, 为什么解释不了由原子分子构建成的生态圈和人类社会! 即便那个依稀可见的大统一理论, 也根本没把预测人类社会的发展作为目标, 只是想着统一四种基本力. 这里就产生了非常严重的矛盾: 如果物理学最终可以描述宇宙的起源和未来的发展, 而这个宇宙中包含人类, 而大统一理论又无法预测人类的未来, 那么物理学又如何能预测宇宙的未来? 所以, 一切理论皆相对真理, 只能描述和预测特定场景. 人类, 始终狂妄自大.</li>
<li>道德的相: 宣传越多的真善美, 事实就有越多的假恶丑, 因为充满了真善美后, 就成习惯, 不用再述说了! 人类的法律和道德说到底是为了社会稳定发展出的一种自我约束机制. 属于一种自组织的必然结果. 对和错只是群体对个体一种评价. 作为个体, 需要认识到这种道德的评价是群体强加给个体的. 作为群体中的个体, 需要遵守法律和道德, 但更需要认识到这只是相对的! 换一个群体, 评价体系也会跟着变化, 因而千万不要把道德要求绝对化. 一切看似错误的, 不可原谅的行为, 根本上讲, 是无所谓对错的.</li>
<li>数学的相: 笔者相信着数学和逻辑. 数学是目前人类公认最优美的, 最无歧义的语言. 但即便是数学, 也只能是相对的数学. 因为任何数学理论的建立, 都需要它自己的”锚”: 公理. 由于有这个”锚”, 其后续理论也只能是相对真理, 因为没人能保证这个”锚”不出问题.</li>
</ul>
</li>
</ul>
<ul>
<li>一花一世界, 世界是自相似的.<ul>
<li>笔者始终相信, 即便我们身处观察受限的”鱼缸”, 无法完整的观察出大千世界的真相, 但小世界和大世界, 以及众多平行世界本质上是自相似的. 正如同人类创造出的众多交易市场/虚拟游戏之间的关系.</li>
<li>有众多的交易市场, 单个交易市场内部的不同级别的K线图呈现一定的自相似性(规律性), 不同的交易市场存在自相似性. 虚拟游戏创造的可能性则千变万化, 但其本源依旧是贪嗔痴幻化而成的各种可能性.</li>
<li>量子力学诸多违背物质论常规知识也说明了本宇宙非物质性的可能性, 如果套用交易市场/虚拟游戏, 假设存在一更高层次的玩家便能更好的解释这一切(奥卡姆剃刀原则), 所以, 何不考虑一下道, 无常, 上帝, 真主的存在?</li>
</ul>
</li>
</ul>
<ul>
<li>科学精神: 一颗好奇的, 可以包罗万象的心.<ul>
<li>由于历史和现有的科学理论的成功, 大多数人已经迷信于科学理论体系了. 激进者甚至认为凡是现有科学解释不了的现象或事物, 便是不存在. 凡是不符合现有科学理论的古代知识, 便是假知识. 好熟悉的”二个凡是”. 这类人放在古代, 等同于宗教狂热者.</li>
<li>纵观科学的发展史, 便可知科学精神是探索, 是客观, 是开放, 是质疑. 探索是指: 不满足于已有知识, 探索未知的领域和世界. 客观是指: 不带主观目的和利益诉求的忠实记录各种观察数据. 开放是指: 分享自己的数据或理论, 欢迎大家来验证, 讨论和质疑. 质疑是指: 数据可重复实验出, 理论经得起考验.</li>
<li>集权国家不可能自发产生科学. 集权者为了维护自身利益和结构稳定, 是不可能允许个体具有探索, 客观, 开放, 质疑的精神, 所以中国不可能自发产生科学体系. 哪怕是思想界的百花, 都是在战乱时代才得以绽放. 而身处世外的得道之人, 即便主观上满足上述精神, 客观上通常无人知晓和传播. 对人类世界而言, 只是自生自灭的过客.</li>
<li>科学理论有自身的局限性, 自不必多言. 哪怕是科学的方法, 也是有非常大的局限性的. 问题就出在实验可重复这一条. 任何实验可分为观察者和被观察事物, 这就要求观察者的感知能力在同一水平, 被观察事物具有某种稳定性. 由此, 能被大家认可的观察结果必然属于某种特殊情况, 从唯心主义去讨论的话, 只有大家共同创造的事物, 才可被大家重复观察到. 当然, 为了有共同讨论的基础, 这也是没办法的事情, 属于”集体认知”的”锚”.</li>
<li>实修的科学性. 首先, 实修的方法是公开的, 实修的过程已经被相当充分的描述了, 实修的结果已经有历史上众多得道者, 高僧, (牧师?)公开说明. 这就已经证明实验可重复性. 过程和结果的客观性则被可相对独立的重复性保证了. 难点就是这些实修的过程和方法由于表述和传播的问题, 都有严重的变异, 其核心内容被严重的歪曲或掩盖.</li>
</ul>
</li>
</ul>
<ul>
<li>笔者的执念: 人类未来的发展.<ul>
<li>从高二某个节点, 突然就有了杞人之忧, 考虑起人类的未来. 之前因为兴趣学习天文学和物理学知识后, 知道宇宙无非就是热寂或坍塌. 既然死神永生, 剩下需要考虑的就是如何延长人类生存质量和寿命的问题了, 这个执念一直延续到此文, 结束了!</li>
<li>笔者的担忧和结论和伊隆·马斯克基本一致, 相必有类似想法的人不在少数, 但人的本性是执着于眼前的蝇头小利, 面对未来的不确定性, 当然是把握当下的利益更为重要.</li>
<li>简单而言, 这是一个机会成本的问题. 要发展, 就需要试错, 要试错就需要成本, 即需要机会成本来获得发展权. 就人类和地球的现状而言, 要全人类主动放弃发展权是不可能的, 这不是几个先知摇旗呐喊能改变的. 地球对人类而言已经变成那唯一一个鸡蛋了, 那就只有另外一条路, 增加机会, 星球殖民, 用物理空间隔离风险, 把人类放到多个鸡蛋里去试错发展. 当然只要走出这第一步, 行星生命体的自分裂就开始了, 在地球上类似的生命进化过程最终会在星系级别展开来, 然后在星空背景下述说并不新鲜的欲望与博弈.</li>
<li>人类当下的科技发展更专注于另外一个维度的扩展: 虚拟化. 主要就是基于电力, 硅基产生数字信号建立虚拟世界. 在无明显的生存压力下, 欲望当然更倾向于绝对权力, 做创始者, 而非培养竞争者, 这大概也是命中注定的一种选择.</li>
<li>从此文开始, 无此执念. 人类世界也不过是一个虚拟世界, 一场游戏, 一个进程, 一份体验罢了. 大千世界正在进行的就是一场无尽可能性的探索和体验.</li>
</ul>
</li>
</ul>
<ul>
<li>核心: 无我, 开放而包容的心. 放空掉一切理论道德欲望, 不去判断生死, 美丑, 善恶, 对错, 苦乐. 只是观察, 客观的观察.<ul>
<li>认识到此, 就是开悟了. 开悟可以是瞬间的.</li>
<li>然后坚定信心, 实修见证一切, 直到能自信的说出: 我看见道/佛/上帝了, 融于一体了. 实修必然是漫长的.</li>
</ul>
</li>
</ul>
<h1 id="理论来源"><a href="#理论来源" class="headerlink" title="理论来源"></a>理论来源</h1><p>寻寻觅觅, 终得元吾氏网站. 如获至宝. 带着疑问通读了全博客, 基本可信.</p>
<p>可信的理由如下:</p>
<ul>
<li>元吾氏有自力更生的能力, 早期不以修道求财, 后期存疑, 具有基本的科学素养, 力求描述客观.</li>
<li>深入浅出, 最基本的实修方法和笔者已知的是一致的, 最核心的观点和笔者自己的判断是一致的. (无我的观察)</li>
<li>文字浅显易懂, 不遮掩, 不神秘. 态度明确, 不授观点, 只讲客观体验.</li>
<li>知乎上的反对全部浏览了一遍. 部分实修者认同了其分享的经验, 持肯定态度. 道教中人多我正他邪, 先入为主, 不足为虑. 最大的争议就是后期的有偿解答和一些徒弟上的问题. (这样想来, 缠师早早过世倒不失其名誉了.)</li>
<li>需要注意的是: 在有一定的心定基础之前, 很可能初学者刻意追求出体体验有潜在风险.</li>
</ul>
<p>笔者一个门外汉级别的实修体验, 自然无法完全理解元吾氏全盘拖出的讲解. 于是计划按此大纲立个实修计划, 一步一个脚印走下来亲证去.</p>
<p>目录:</p>
<ul>
<li><a href="http://blog.sina.cn/dpool/blog/u/1760432301#type=-1" target="_blank" rel="noopener">元吾氏的新浪博客</a></li>
<li><a href="http://jilu.yuanwushi.com/" target="_blank" rel="noopener">元吾氏集录</a>  结构更清晰的第三方整理<ul>
<li><a href="http://jilu.yuanwushi.com/yuedu/2014-11-10/32.html" target="_blank" rel="noopener">修道之心障</a><ul>
<li>意识封闭。大道无所不包一切之可见，无所不含一切之不可见。意识越宽广者，离道越近；越狭隘者，离道越远</li>
<li>我正他邪。万法归一。道学、佛学、儒学、基督、伊斯兰、哲学、科学等皆为求道之不同流派和不同方法。条条大路通罗马</li>
<li>以术为道。以道统术，以术得道。技术是修道的方法和工具，非道也</li>
<li>舍简求繁。大道至简，大法至易。不根于虚静者即是左道，不归于易简者即是旁门</li>
<li>轻本重末。神为本，形为末。老子曰：”伪道养形，真道养神；真神通道，能亡能存</li>
<li>强为偏执。大道自然，不是自残。 (注: 正常生活即可, 不必须出家, 不必须禁欲, 不必须素食. 修炼的目的是无我无欲达到与道合一的体验, 认识到世界的本质, 而非看上去无我无欲)</li>
<li>修道的过程：一个去除心障的过程。</li>
<li>修道的结果：去除了障碍，才能到达本源。消除“回家”路上的障碍，才能“到家”。</li>
</ul>
</li>
<li><a href="http://jilu.yuanwushi.com/yuedu/2014-11-10/42.html" target="_blank" rel="noopener">终极真相—-所有问题的答案</a><ul>
<li>一个无限的、不生不灭、无形无相的自由意识(Freewil)/精神(Spirit)，有着无穷无尽的自发幻想(Imagination/思想Thoughts)，其景象（Imaginations/表现Expressions）就是无数多样的宇宙和万物及各自的规则和不规则。</li>
<li>从元吾氏的描述看, 此”终极真相”对应的就是道/涅槃/神/上帝/真主. 它不符合逻辑(把人类目前最美的语言, 数学直接给否了).</li>
<li><em>笔者注: 其描述和佛教的<code>非空非有, 非非空非有</code>, 道家的<code>道可道,非恒道</code> 是一致的. 这是语言的相对性和局限性产生的描述方法. 由于终极真相的绝对性, 语言描述只能是先基于一个概念(锚)进行描述, 再否定这个概念(锚)的存在, 所以其表现的结果就是逻辑上的难以理解和自相矛盾.</em></li>
<li><em>笔者注: 此条唯有亲证. 由于说的是终极真相, 和笔者一切相对的想法背离, 所以暂时存疑.</em></li>
</ul>
</li>
<li><a href="http://jilu.yuanwushi.com/yuedu/2014-11-10/37.html" target="_blank" rel="noopener">道、求道、万法归一、现实性、透明性</a><ul>
<li>证道：自己亲身实证实见之道</li>
<li>悟道：自己悟出的道，还没有经过自己的实证。</li>
<li>闻道：听别人说的道，既不是自己悟出的，也没有经过自己的实证。</li>
<li>大道，最不怕传授给恶人。引恶人走上正道，世间之万幸。 传道者，坦坦荡荡，无人不传</li>
<li>法术，最害怕传授给恶人。教恶人滥用法术，世间之不幸。 传术者，神神秘秘，择人而传</li>
<li>实证为上。 (目前自己略有悟道, 需要实修完成证道.)</li>
</ul>
</li>
<li><a href="http://jilu.yuanwushi.com/yuedu/2014-11-11/45.html" target="_blank" rel="noopener">我的修道经验—-我最常用的几种方法（正文）</a><ul>
<li>静观法. 打坐冥想, 动中禅. 日常修炼使用. 第一步入静, 第二步神游.</li>
<li>梦观法. 睡眠中的修炼使用. 直接进入神游状态.</li>
<li>心死神活法. 解决失眠问题.</li>
<li>技术共通点： 观-&gt;自然跟踪-&gt;得意忘形-&gt;无处不丹田.</li>
<li>静观内观法和观梦法高度互补, 日常实修使用. 心死神活法, 如果失眠, 用此法解决一下.</li>
<li><em>笔者的观点: 初学者以一念代万念来静心, 一定程度后只观念的来去进行静心, 不要强制去一念不生</em></li>
</ul>
</li>
<li><em>笔者的后续人生计划</em><ul>
<li>精进实修, 亲证”终极真相” (打引号是因为亲证前保持对”终极”的存疑, 目前一切皆相对是我的”锚”)</li>
<li>此生, 在生活中修炼, 平和的过正常人生活.</li>
<li>若有幸亲证, 后续可能的选择是尝试用人类最优美, 最无歧义的数学来告知众人, 道/涅槃/神/上帝/真主的”存在”, 以此为”开释”/“渡”.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="实修方法"><a href="#实修方法" class="headerlink" title="实修方法"></a>实修方法</h1><p>具体参考元吾氏的博文</p>
<ul>
<li><a href="http://blog.sina.cn/dpool/blog/s/blog_68ee10ad01014uij.html?type=-1" target="_blank" rel="noopener">我最常用的几种修道方法（前言）</a></li>
<li><a href="http://blog.sina.cn/dpool/blog/s/blog_68ee10ad0100rmbf.html?type=-1" target="_blank" rel="noopener">我最常用的几种修道方法（正文）</a></li>
</ul>
<p>下面针对笔者自身情况暂时选出的实修方法, 有删改.</p>
<h2 id="静观法"><a href="#静观法" class="headerlink" title="静观法"></a>静观法</h2><ol>
<li>闭目养神。</li>
<li><strong>表意识不思不想。</strong></li>
<li><strong>完全自然跟随潜意识。</strong></li>
<li><strong>静静地观察。</strong></li>
<li>不参与任何表意识杂念。</li>
<li>只是静静旁观潜意识。</li>
<li><strong>一切顺其自然</strong>。</li>
<li>真神自然显现。</li>
<li>或游走多维世界。</li>
<li>或化解人生疑难。</li>
<li>或回归万物本源。</li>
<li>一切顺其自然。</li>
<li><strong>至极至反至顺</strong>（暂时找不到更简单的描述）。</li>
</ol>
<p>注解：”至极至反至顺”</p>
<ol>
<li>即”舍己从人跟踪法”: 完全舍去自己，跟踪自然的动静和变化，与之合为一体，完全体验至极限。</li>
<li>如：有一个痛苦出现，则自然跟踪之，并完全与这个痛苦合一，体验痛苦”至极”。物极必反：至极之后会自动走向”至反”。反极必顺：至反之后自动回归”至顺”。痛苦会自动慢慢治好。 (<em>笔者注: 譬如观察一个病痛, 不做多想, 或不予理睬, 或简单回应”知道了”, 然后继续观察</em>)<br>3、一切自动化，只需耐心、舍己跟踪，直至最终。<br>4、故曰：至极至反至顺。亦曰：“舍己从人死心跟踪”。（舍己：要放弃一切恐惧，死心塌地、顺从自然。）<br>5、再重复要点：完全舍弃自己的主观，跟踪所观，死心塌地与所观合一，完全顺其自然。</li>
</ol>
<p>此法实用性极高：<br>a)用来治病，效果极好。（治病时：亦称”死心塌地跟踪法”, 静观病灶，死跟到底。病会自动慢慢治好。）<br>b)用来解决人生的问题，也是效果极好。（进入潜意识，静观人生问题，时间长了自然会”发酵”出解决办法。）<br>c)用来练精气神，亦称”舍己从神跟踪法”, 静观神意（或炁），死心跟踪，会自然水到渠成。<br>静观法的核心要点：①观；②何处不丹田。</p>
<p><em>笔者注:</em><br><em>如果初学者觉得做不到表意识的不思不想, 客观观察(就是总是被冒出来的想法牵着走), 那么先用一念代替万念的修炼方法静心. 譬如只念一句”阿弥陀佛”, 或者从观察呼吸等规律性的, 便于集中注意力的事物开始, 如<strong>数息观</strong>, <strong>出入息观</strong>.</em></p>
<p><em>对于观何处, 核心要点已经说得非常直观了: 何处不丹田! 观察适合自己的地方就行了.有感觉的地方就可以观, 可以想CT一样扫遍全身的观, 可以针对不适的地方观, 观念起念落, 观呼吸, 观声音变化, 观眼中光亮, 观动作, 等等等等, 无一不可! 关键是要让自己静下心来观!</em></p>
<p><em>此法用于日常的打坐冥想和动中禅实修.</em><br><strong><em>打坐冥想需每日固定时间练习, 每天早晚各一次, 每次30分至一小时, 即每天一小时至二小时.</em></strong><br><strong><em>动中禅随时可修. 动中禅较难, 毕竟无法闭目养神, 属于闹中取静, 但核心是一样的, 就是不思不想, 无为无我而观.</em></strong><br><strong><em>不断精进学习打坐冥想和动中禅的技术细节, 以提高实修效率</em></strong></p>
<h2 id="梦观法"><a href="#梦观法" class="headerlink" title="梦观法"></a>梦观法</h2><p>源自《梦观成就法》（请参考另篇博文：“藏密无上瑜伽—-《梦观成就法》”）。<br>有四个步骤：知梦、观梦、破梦、用梦。</p>
<ol>
<li><strong>清醒时：意识播种：’我在做梦’。</strong> （形成梦中知梦的潜意识惯性）</li>
<li><strong>入梦前：意识播种：’梦中知梦，醒来都记得’。</strong> （知梦）</li>
<li><strong>出梦后：立刻忠实笔录梦境，前后验证。</strong> （经验的记录、分析、比较、验证等作用）</li>
<li><strong>入梦后：’观察’梦境。</strong> （观梦：观=心法的核心）</li>
<li>时久，可观见梦境有两种。</li>
<li>第一种：’梦体’主观潜意识所创造的主观梦界。（’我’的梦界, 个体幻相界）</li>
<li>第二种：’梦体’离开肉体见到的客观梦界。（’我们’的梦界, 集体幻相界）</li>
<li>因此：’静化’主观潜意识，停止’创造’主观梦界。（破梦关键之一。否则依然是两种混合梦境、永远无法破梦）</li>
<li>逐渐：只剩下旁观潜意识和客观梦界，旁观其自然运作。（破梦关键之二。旁观梦境，顺其自然）</li>
<li>逐渐会发现：梦界一直在’创造’物质现象界。（初步发现物质现象界的源泉）</li>
<li>物质现象界原来也是一种梦界。</li>
<li>再逐渐会发现：梦界被更深的梦界’创造’。（发现梦界的多重源泉、梦界的梦中套梦）</li>
<li>亦可逐渐发现’多重梦体’：梦体被更深的梦体“创造”。（发现梦体的多重结构、梦体的梦中套梦）</li>
<li>一界又一界，一体又一体，更深循环，乃至极深。</li>
<li>一步步追本溯源，一直到’梦界的终极本源’。</li>
<li>由此：发现万物万界皆为梦幻，得以终极“苏醒”。（破梦的终极）</li>
<li>由此：从终极本源最深处，练习变梦及其实用。（用梦, 破梦前的变梦：可变第一种梦界，难变第二种梦界；破梦后的变梦：两者皆可）</li>
<li>实用一：在梦界中逐层化解梦体和梦界问题。（梦界影响梦界）</li>
<li>实用二：在梦界中化解肉体和物质现象界问题。（梦界影响物质现象界、连接两界）</li>
<li>随用随验，逐步提高用梦技术。</li>
<li>由此可逐步实现’梦想’。</li>
</ol>
<p>早期完全照搬古印度’那洛巴六成就法’之一的《梦观成就法》，后期融合西方清醒梦法和中国丹道睡功法，再加上本人四十年梦观经验。<br>此法与近代荷兰的“清醒梦法”如出一辙（可参考西方流传的各种清醒梦资料）。<br>中国丹道亦有类似方法，称为“睡功”（可参考陈希夷、吕纯阳、张三丰、白玉瞻等）。<br>我把《梦观成就法》的第二步“变梦”移到第四步，因为从经验上，破梦之后再变梦，效果更深更广更佳。（这是针对修梦者，玩梦者除外。）</p>
<p><em>笔者注:</em><br><strong><em>梦观法和静观法时间上高度互补, 所以计划同时修炼.</em></strong><br><em>感觉上, 静观法可定慧同修, 梦观法主要是修慧. 因而不能只用梦观法而不学静观法.</em><br><em>关于定慧的关系, 定理解为心静的程度(无我无念的程度), 心越静, 越容易得慧破幻.</em></p>
<h2 id="心死神活法"><a href="#心死神活法" class="headerlink" title="心死神活法"></a>心死神活法</h2><ol>
<li>闭目养神。</li>
<li>告诉自己已经死了。</li>
<li>已经听不到感觉不到这个世界的任何了。</li>
<li>自己已经不在这个世界了。</li>
<li>只剩下一个意识点了。</li>
<li>这个意识点已经没有可依附的肉体了。</li>
<li>这个意识点只好游离在宇宙中了。</li>
<li>不即不离反复重复以上意识。</li>
<li>一直自然跟随这个意识点。</li>
<li>不知不觉中自然出神。</li>
</ol>
<p>此方法的出发点：基于中国丹道的”心死神活”。其后融合了西方现代科学对濒死体验的研究成果。<br>其本质是：肉体意识停止，灵体意识得到自由。亦可称：心死神活法。<br>此法特点：入静较快，还可以用来解决失眠。<br>早期（79年-89年左右）总结的方法。</p>
<p>此法熟练后, 可使用Shift法/次元切换法</p>
<ol>
<li>闭目养神。</li>
<li>完全彻底忘掉肉体。</li>
<li>只剩下一个意识点。</li>
<li>决定这次具体目的。</li>
<li>告诉自己能不受次元限制。</li>
<li>能够直接切换次元</li>
<li>确信会直接到达目的地。</li>
<li>意念放松越深越好。</li>
<li>确信会自然到达目的地。</li>
<li>反复重复以上目的地。</li>
<li>一直自然跟随这个意识。</li>
<li>半知半觉中自然可达目的地。</li>
</ol>
<p>此方法的出发点：基于中国庄子的”忘我”。<br>其本质是：意识直接切换到多维世界，不再受肉体限制。亦可称：次元切换法。<br>此法特点：即可出神，亦可不出神只切换次元。换言之：既可出可入，也可不出不入。<br>中期（89年-99年左右）总结的方法。</p>
<p><em>笔者注:</em><br><em>两者本质一样, 只是前者没有目的性, 后者有目的性. 前者是基础, 后者难度更高.</em><br><em>很明显, 这种方法需要有相当的定力(需要先用静观法做到完全彻底忘掉肉体).</em><br><em>可以尝试用”心死神活法”解决偶尔的失眠问题, 否则暂不学习.</em></p>
<h2 id="经验中的最经验"><a href="#经验中的最经验" class="headerlink" title="经验中的最经验"></a>经验中的最经验</h2><ol>
<li>没有最好的方法，只有最适合你的方法。一人一法，万人万法，万法归一。</li>
<li>仅有方法不够，还需要耐心+悟性+目的（没有目的则原地打转）。</li>
<li>越复杂的方法效率越低，越简单的方法效率越高！！！</li>
<li>本人三十年来使用上百种方法之后，复杂的方法逐渐被淘汰，现在剩下来还继续使用的这些最有效的方法，都非常简单。常有人不信，觉得太简单，非说我没全盘端出，还有秘密藏着掖着。今天再次强调：我没有任何保留。大道的的确确至简，信不信由你，是真是假走到头便知！中途先别着急判断。</li>
</ol>
<p><em>笔者注:</em><br><em>笔者已对佛/道/灵修不疑不惑了, 此文就是明确目的, 培养信心, 持之以恒去实修实证的决心书. 后续实修过程遇到困难打退堂鼓时, 及时看看此文自我肯定, 补充信心即可.</em><br><strong>实修不设时间计划, 不求速成, 不影响工作生活, 唯时时日日修炼, 沿途欣赏风景, 自然精进.</strong>, 综合考虑后, 会以佛教的修行方法为主, 而非此文中的出体方法.</p>
<h1 id="推荐书籍"><a href="#推荐书籍" class="headerlink" title="推荐书籍"></a><a href="http://jilu.yuanwushi.com/yuedu/2014-11-11/71.html" target="_blank" rel="noopener">推荐书籍</a></h1><h2 id="大道经典"><a href="#大道经典" class="headerlink" title="大道经典"></a>大道经典</h2><ol>
<li><a href="http://jilu.yuanwushi.com/yuedu/2014-11-11/69.html" target="_blank" rel="noopener">《天符經》</a></li>
<li><a href="http://jilu.yuanwushi.com/yuedu/2014-11-11/68.html" target="_blank" rel="noopener">《道徳經》</a></li>
<li><a href="http://jilu.yuanwushi.com/yuedu/2014-11-11/51.html" target="_blank" rel="noopener">《心經》</a></li>
<li><a href="http://jilu.yuanwushi.com/yuedu/2014-11-11/70.html" target="_blank" rel="noopener">《金剛經》</a></li>
</ol>
<h2 id="修炼方法"><a href="#修炼方法" class="headerlink" title="修炼方法"></a>修炼方法</h2><ol>
<li>印度《合一经》（旧译《瑜伽经》）</li>
<li>印度和藏密的“中脉脉轮法”</li>
<li>印度《四禅八定法》</li>
<li>《通玄真經》</li>
<li>《老君西升經》</li>
<li>《太上老君內觀經》</li>
<li>《太上老君說了心經》</li>
<li>《张三丰內丹36訣 》</li>
<li>藏密《梦观成就法》 (梦中禅修)</li>
<li>藏密《神识出游法》</li>
<li>藏密《身外化身法》</li>
<li>美国“门罗出神法”（神游法）</li>
<li>荷兰“清醒梦法”（梦修法）</li>
<li>你自己喜欢的、适合你的有效方法（最好的方法=最适合你的方法）</li>
</ol>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li>《云笈七籖》</li>
<li>《性命圭旨 》</li>
<li>《伍柳仙宗 》</li>
<li>《唱道真言 》</li>
<li>《大成捷要 》（—-很多修道者的经验汇编）</li>
<li>丹经万卷，不如守一。</li>
</ol>
<h2 id="笔者的补充"><a href="#笔者的补充" class="headerlink" title="笔者的补充"></a><em>笔者的补充</em></h2><ul>
<li><a href="http://wyw.hwxnet.com/" target="_blank" rel="noopener">文言文字典</a></li>
<li><a href="http://www.fodian.net/fodict/index.htm" target="_blank" rel="noopener">佛学电子辞典</a></li>
</ul>
<ul>
<li><a href="http://jilu.yuanwushi.com/yuedu/2014-11-11/68.html" target="_blank" rel="noopener">道德经</a></li>
<li><a href="http://jilu.yuanwushi.com/yuedu/2014-11-11/51.html" target="_blank" rel="noopener">心經</a></li>
<li><a href="https://wenku.baidu.com/view/72640dea172ded630b1cb6a0.html" target="_blank" rel="noopener">定慧之路(致光法师)</a></li>
<li><a href="http://blog.sina.cn/dpool/blog/s/blog_993e460b0101a70f.html?vt=4" target="_blank" rel="noopener">个人推荐的一些禅修书籍下载（含阅读指导）</a><ul>
<li><a href="http://agama.buddhason.org/index.htm" target="_blank" rel="noopener">南传经藏/阿含经</a></li>
<li>马哈希体系（禅修方法主要是观察六根门出现的对象 也就是法念处 或者说是四念处的综合）</li>
<li>雪乌敏体系（主要是心念处）</li>
<li>孙伦体系（主要是身念处 受念处 其中的受偏身受 关于心受可以参考马哈希以及雪乌敏体系）</li>
<li>隆波帕默</li>
</ul>
</li>
<li><a href="http://jilu.yuanwushi.com/yuedu/2014-11-11/70.html" target="_blank" rel="noopener">金剛經</a></li>
</ul>
<ul>
<li>《当下的力量》/《当下的力量2》</li>
<li>《物理学之”道”》（卡普拉）<ul>
<li>此书是此文完成后看的, 算是对自己想法的一种补充和肯定.</li>
<li>唯物主义者和唯科学论者建议观看. 科学的最伟大之处不在于理论预测的准确性, 而在于能基于客观实验这个锚, 不断突破自我的相(科学理论的局限性).</li>
<li>书中称科学实验为实验, 冥想打坐类的体验为经验. 也略微描述了两者内在的相似之处.</li>
<li><strong>从信息论角度来说, 能重复的实验和能重复的体验是没有区别的! 都说明了被观察信息具有一定的稳定性, 便可以认为其”存在”.</strong></li>
</ul>
</li>
<li>《与神对话》（Neale Donald Walsh）<ul>
<li>此书是此文完成后看的, “与神对话1”的内容属于作者的自我开悟/觉醒, 对其内容表示理解和认同.</li>
<li>“与神对话”的2和3, 是作者自我开悟后尝试解决地球和世界问题的答案, 我基本无法认同, 因为不符合客观发展规律, 属于一厢情愿的建议.</li>
<li>此书体现了东西方思维方式的差异. 作者虽然认识到了一切相对, 但主观上依旧是人为至上, 爱和善最好. 道德经, 博弈论都明确无误的说明了: 物极必反, 至善则生恶!</li>
</ul>
</li>
</ul>
<ul>
<li><a href="http://blog.sina.com.cn/s/blog_486e105c010006n3.html" target="_blank" rel="noopener">《论语》详解：给所有曲解孔子的人</a><ul>
<li>把《论语》也写上吧, 个人并不喜欢儒家, 因为它历来和权利走的太近, 是为权利服务的学说.</li>
<li>但孔子作为源头, 是无需背负这些骂名的, 看看”缠中说禅”的《论语》, 或许能看到孔子的原意.</li>
</ul>
</li>
</ul>
<hr>
<blockquote>
<p>本人的观点仅供参考 读者应当保持足够的理性与怀疑态度<br>不要盲信任何观点包括本人的观点<br>本人观点是否正确, 需要每一位修行者严谨的通过理论学习以及禅修实践来判断</p>
</blockquote>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/07/08/1818-buddhism/" itemprop="url">
                  佛教学习资料及一些感想
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2018-07-08T00:00:00+10:00" content="2018-07-08">
              2018-07-08
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/thoughts/" itemprop="url" rel="index">
                    <span itemprop="name">thoughts</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h1><ul>
<li><a href="https://draapho.github.io/2017/10/09/1728-ultimatethink/">我的终极思考</a></li>
<li><a href="https://draapho.github.io/2018/04/12/1815-suspend/">博客暂停更新</a></li>
<li><a href="https://draapho.github.io/2018/07/08/1818-buddhism/">佛教学习资料及一些感想</a></li>
<li><a href="https://draapho.github.io/2018/11/29/1819-start-meditation/">实修开始</a></li>
<li><a href="https://draapho.github.io/2018/12/27/1820-meditation-LCP/">闻思修</a></li>
<li><a href="https://draapho.github.io/2019/03/19/1901-tittle-tattle/">杂谈</a></li>
<li><a href="https://draapho.github.io/2019/07/05/1908-unified/">各种【一元化思维】的谬误——从“星座理论”到“共产主义社会”</a></li>
<li><a href="https://draapho.github.io/2019/07/25/1909-TCM_science/">好吧，我们就从头聊一聊科学、中医、东西方文明及其不同思维模式的话题</a></li>
<li><a href="https://draapho.github.io/2019/07/26/1910-satori/">开悟是怎样一种体验？</a></li>
<li><a href="https://draapho.github.io/2020/04/15/2003-letthebulletsfly/">解构&lt;让子弹飞&gt;</a></li>
<li><a href="https://draapho.github.io/2021/01/28/2101-confusion/">与神对话读后感-矛盾与困惑</a></li>
<li><a href="https://draapho.github.io/2021/02/09/2102-intermittent/">一张简单图片演示的“甚深佛法”</a></li>
<li><a href="https://draapho.github.io/2021/02/13/2104-satori/">修行总领——明心见性</a></li>
</ul>
<h1 id="传承中的变异"><a href="#传承中的变异" class="headerlink" title="传承中的变异"></a>传承中的变异</h1><p>知识,理论, 宗教的传承中, 变异是时刻都存在的. 简单如拷贝不走样这种游戏, 奖励机制是如果信息传递过程中没有走样, 就算赢, 属于正向激励, 其结果都往往是严重走样, 更别说实际的知识和理论的传播者往往是带有强烈目的性的, 更容易选择性的删去不利于自己的东西, 加入一些有利于自己的东西. 最终到了当下, 看到的理论也就不可能是干净和纯粹的了, 其中不知夹杂了多少传播者的私货! 辨别这种变异很容易, 就是看有没有利益关系. 知识/理论/宗教的传播多半需要统治者支持才能在空间广度上扩大影响, 时间宽度上通向未来, 那么这些”文化”需要部分有利于统治阶级也非常可以理解了. 简单举几个例子:</p>
<ul>
<li>后世的儒教早已和孔子的儒家分道扬镳, 儒教将儒家利于帝王统治和愚民的部分发扬光大, 将孔子的本意或含糊其辞或略去不表, 从而到达自己的目的. 这种对比, 可以去看下<a href="http://blog.sina.com.cn/s/articlelist_1215172700_8_1.html" target="_blank" rel="noopener">缠中说禅的论语详解</a>, 至少我通读下来, 其解释更符合逻辑, 缠中说禅本人和论语也无什么明显的利害关系. 也可以去看看南怀瑾的<a href="http://www.quanxue.cn/CT_NanHuaiJin/LunYuIndex.html" target="_blank" rel="noopener">论语别裁</a>, 反正最不可信的就是御用文官的解释, 最可信的就是直接出自孔子的语句.</li>
<li>马克思的资本论和马克思主义也是牛头不对马嘴的两套东西. 资本论分析了资本主义的发展过程, 并希望分析出社会的运动法则. 这是一套非常客观的分析, 当下的世界还没有跳出资本论的范畴. 苏维埃和中共, 都是将资本论作为革X命X的理论依据, 以此打天下(替资本论行道!). 到了坐天下时, 两者都走成了国家资本主义. 如果后世拿着中苏官方的研究文档去看资本论, 那就是南辕北辙!</li>
<li>再说说当世最严谨的科学研究: 科研项目需要资金支持, 资金有利益倾向. 因而有不少研究成果对资金利益有明显的倾向性已经是不争的事实. 有些”科学家”成为企业御用笔手也越来越常态化, 这和御用文人如出一辙! 这在医用, 保健品, 农业公司尤其明显!</li>
<li>佛教也是如此, 求神拜佛, 许愿放生自不用说, 哪怕想精进学习, 接触一点本质的东西, 也是真伪难辨. 粗看大乘小乘, 诸多流派, 就深深感受到传承中因自利而导致的变异. 大乘和禅的顿悟流行于中国一点都不奇怪, 国人向来好高骛远, 爱走捷径, 实修,  工匠精神之类的从来没有成为过主流(这里强调的是大乘和禅在中国广为流传的思想基础, 并不是说大乘和禅的高僧大德自身缺乏实修). 而印度本土佛教最终被印度教同化, 藏传佛教走上了政教合一. 这么多的演变, 什么是真, 什么是假, 具体门派的和尚们恐怕是只缘身在此山中, 门外汉更是茫茫然不知所措</li>
</ul>
<p>综上, 尽信书不如无书. 信不信一套东西, 最终还是要通过自己的思考, 辨别和选择. 非常可惜, 国内教育就是告诉你应该信这个, 不应该信那个. 独立性思维是从来没有提及的, 更不会去教授了. 当然这是自古以来的有意为之.</p>
<h1 id="佛教参考资料"><a href="#佛教参考资料" class="headerlink" title="佛教参考资料"></a>佛教参考资料</h1><ul>
<li><a href="http://www.hhfg.org/jcjx.html" target="_blank" rel="noopener">慧海佛光-基础教学</a><ul>
<li><a href="http://www.hhfg.org/jcjx/f47.html" target="_blank" rel="noopener">印度佛教史</a>, 必看</li>
</ul>
</li>
<li><a href="http://blog.sina.com.cn/s/articlelist_2570995211_0_1.html" target="_blank" rel="noopener">Aggavara的博客</a><ul>
<li><a href="http://blog.sina.cn/dpool/blog/s/blog_993e460b0101alhp.html" target="_blank" rel="noopener">原始佛教修学指南（博客导读）</a>, 实修, 推荐看</li>
<li><a href="http://blog.sina.cn/dpool/blog/s/blog_993e460b0101a70f.html?vt=4" target="_blank" rel="noopener">个人推荐的一些禅修书籍下载（含阅读指导）</a></li>
<li><a href="http://blog.sina.com.cn/s/blog_993e460b01012hsp.html" target="_blank" rel="noopener">简述原始佛教核心思想</a></li>
<li><a href="https://www.meiwen.com.cn/subject/twmdsftx.html" target="_blank" rel="noopener">一张简单图片演示的“甚深佛法”</a></li>
<li><a href="http://blog.sina.com.cn/s/blog_6a0da51a0101asxu.html" target="_blank" rel="noopener">几年来深入思考和佛法禅修实践的总结</a>, 对上图的补充说明</li>
</ul>
</li>
<li><a href="http://agama.buddhason.org/index.htm" target="_blank" rel="noopener">莊春江工作站</a>, 最接近原始佛教的内容, 必看.<ul>
<li><a href="http://agama.buddhason.org/SN/index.htm" target="_blank" rel="noopener">汉译相应部</a>, 建议从此处开始看.</li>
<li><a href="https://zh.wikipedia.org/wiki/%E9%98%BF%E5%90%AB%E7%B6%93" target="_blank" rel="noopener">阿含经与尼柯耶的关系</a></li>
</ul>
</li>
<li><a href="https://wenku.baidu.com/view/72640dea172ded630b1cb6a0.html" target="_blank" rel="noopener">定慧之路-致光法师</a>, 介绍了定慧的关系, 定主要介绍的吐息法. 可看.</li>
<li>大佛顶首楞严经, 心经, 金刚经. 自己还没看, 暂不推荐.</li>
<li><a href="http://www.quanxue.cn/CT_NanHuaiJin/index.html" target="_blank" rel="noopener">南怀瑾全集</a>. 太杂, 不成体系, 不推荐</li>
</ul>
<h1 id="我对佛教的认识"><a href="#我对佛教的认识" class="headerlink" title="我对佛教的认识"></a>我对佛教的认识</h1><p>接触佛教一年不到, 洋洋洒洒粗看了一些佛教相关的书籍, 对佛教的认识肯定是粗浅的. 现在将入门阶段的心得写下一二, 若有缘, 希望能帮助与我有类似背景的人入门能快一些, 少走一些弯路.</p>
<p>通读<a href="http://www.hhfg.org/jcjx/f47.html" target="_blank" rel="noopener">印度佛教史</a>. 有助于快速抓住佛教的发展脉络, 大致了解原始佛教, 上座部(小乘), 大众部(发展为大乘)的区别和联系. 两者起源于释迦摩尼时代的原始佛教, 因为一些认知的差别, 分裂了. 小乘是大乘佛教对上座部的称呼, 上座部本身是不承认这个叫法的. 在我看来, 上座部更完整的传承了原始佛教, 大乘则更注重于佛教的发展和进化. 中国是流行大乘佛教的, 可惜大乘佛教资料繁杂, 派别众多, 很容易感觉无从入手, 纵览群书而不得要领. 看看<a href="http://www.hhfg.org/jcjx.html" target="_blank" rel="noopener">慧海佛光-基础教学</a>里佛教的定义及分类, 便可知众人对佛教认知的多样性和复杂性了.</p>
<p>释迦摩尼的原始佛教其实并不复杂, 有明确的目标, 清晰的学习方法. 释迦摩尼就是教师, 告知大家<strong>诸行无常、诸法无我、涅槃寂静</strong>. 诸行无常是佛教的世界观, 诸法无我是教学的方法和纲领, 涅槃寂静是学习的最终目标. 释迦摩尼在世时, 唯一关注的重点就是教众人”离苦得乐”的方法, 即实修的方法, 以此为核心, 会根据不同的人的根性, 做相应的说法. 而对于形而上的哲学问题, 他一概认为不重要, 可参考 <a href="https://baike.baidu.com/item/%E5%8D%81%E5%9B%9B%E6%97%A0%E8%AE%B0" target="_blank" rel="noopener">十四无记</a>, 另一个比喻是<a href="http://agama.buddhason.org/MA/MAsearch1.php?str=%E7%AE%AD%E5%96%BB&amp;path=MA221.htm" target="_blank" rel="noopener">中阿含221經/箭喻經</a>, 他将人生在世和轮回比喻为身中毒箭之人, 哪还需要去管什么箭从哪里来, 用什么做的, 给我看病的医生是谁这种不紧急的事.</p>
<p>逻辑上讲, 人生在世和不断轮回是苦, 是等同于身中毒箭之人这一观念是主观的, 对释迦摩尼而言, 十四无记里的问题是舍本求末, 没有意义的, 但不等于这些问题不值得探索. 而且, 如果去探讨毒箭何处射来, 用何材质, 飞行原理如何, 毒性如何, 都是有助于帮助更多身中毒箭的人离苦的. 在我看来, 释迦摩尼是消极厌世的, 他看到了太多的苦难, 觉得一切皆苦, 所以他的教学目的就是非常明确的涅槃寂静: 看到一切都是变化无常的, 变化无常就是苦, 现在有一种方法(诸法无我, 戒定慧)不但让你认识到诸行无常, 还能让人们脱离这种变化无常, 到达涅槃寂静.</p>
<p>还没完全信佛教, 那为什么还是想学佛法? 释迦摩尼时代的教徒, 也有很多人带着疑问在学佛, 并不是要全信了佛说的话才能学, 原始佛教是一门实修的课程, 有兴趣就能参加. 至于佛说的, 边学边去验证真伪不就行了, 释迦摩尼从来没说过学徒不能存疑. 进一步而言, 目的和方法是两回事情, 当下, 我无法认同原始佛教的最终目的, 但对佛教授的方法已经完全认同了. 如果用戒定慧的方法最终做到诸法无我, 相当于心无所执, 那无论做什么事情, 对个人对家庭对社会, 都是有百利而无一害, 看问题也会更通透. 至于神通, 轮回和诸行无常, 我已相信, 但没什么能力去证明. 而且对这些的信或不信, 丝毫不影响从戒定慧开始的实修.</p>
<p>再说一说为何要从原始佛教开始, 以及如何开始实修. 整个佛教体系, 是动态发展到当下这种情况的, 佛教的内部派系之间, 和外部宗教之间, 都充满了利益冲突, 如果都如雪山部与世无争, 其结局就是灭亡. 因而存活下来的佛教, 都是某种与人文环境妥协的产物. 由于这种原因, 看现代的佛教有如乱麻, 各种说法, 各种相面都有. 而抓住原始佛教这个源头, 有了一定观念和实修的基础以后在去了解后续变化发展后的佛教, 选择自己感兴趣的, 无疑就是最正确的学习方式了. 原始佛教的核心思想可参考 <a href="http://blog.sina.com.cn/s/blog_993e460b01012hsp.html" target="_blank" rel="noopener">简述原始佛教核心思想</a>. 简单归纳如下:</p>
<ul>
<li>佛法实修的根本方法: 观察色法(物质现象)和名法(精神现象), 出发点都是<a href="https://baike.baidu.com/item/%E4%BA%94%E8%95%B4" target="_blank" rel="noopener">五蕴</a>(可以简单理解为感官, 并把整个感受的过程细化开来).</li>
<li>佛法观察的对象: 四念处. 即: 身念处，受念处，心念处，法念处. 简单来说, 就是达到<a href="https://baike.baidu.com/item/%E5%9B%9B%E7%A6%85%E5%85%AB%E5%AE%9A#2_1" target="_blank" rel="noopener">四禅八定</a>中的某一级别后(初禅二禅三禅四禅, 每一禅内部又分近行定和安止定两种), 去客观观察自身的种种感受和想法. 重点是客观, 是无我. 不能有控制, 想要之类的念头, 也不是学了一些方法后, 觉得自己观察到了方法中暗示的内容.</li>
<li>戒定慧的关系: 戒是身行, 人众时, 需要有明确的戒才能组织管理众人. 但行终究是给外人看的, 戒的重点在心而不在行. 定是通法而非佛法独有, 可以简单理解为心的专注程度, 练习定最简单的方法是以一念代万念, 难一点的是不生一念, 其它的如姿势等都没那么重要. 慧是佛法的重点, 这里的慧, 就是指通过观察四念处, 最终体悟到诸行无常、诸法无我. 没有定是观察不了四念的, 也就不可能有慧, 因而定是慧的基础. 但有一定程度的定以后, 则可以定慧相互促进. 定与慧的关系可参考 <a href="https://wenku.baidu.com/view/72640dea172ded630b1cb6a0.html" target="_blank" rel="noopener">定慧之路-致光法师</a>. 目前面主流的灵修类书籍和体验, 大多停留在教人如何定的范畴里面. 释迦摩尼时代, 已经得定者众多(当时印度教派众多且流行苦行), 因而听了释迦摩尼的教导去观慧得解脱也要容易的多, 别人戒和定的基础都非常好. 现代人做到戒, 练习定都比较困难, 更别说进一步的慧了.</li>
<li>四念处直至涅槃的过程简述: 不用去详细了解, 实修到了哪个阶段, 再细细研判即可. 过程罗列如下<code>名色识别</code>-&gt;<code>生灭</code>-&gt;<code>缘起</code>-&gt;<code>厌离</code>-&gt;<code>舍</code>-&gt;<code>证悟</code></li>
<li>如何开始实修: 我个人是看了艾克哈特·托勒的《当下的力量》体验到<a href="https://baike.baidu.com/item/%E5%9B%9B%E7%A6%85%E5%85%AB%E5%AE%9A" target="_blank" rel="noopener">四禅八定</a>里的细心住, 后来接触佛教后, 坚持了一阵打坐, 最多也就到初禅, 而且只要稍不练习, 就会明显退步. 但这已经足够升起自己的信心了, 把自己的体验和所说的初禅一对比, 就知道所言不虚. 我明确说, 不用拿世俗上的恋爱, 性交等体验去对比, 两者不是一个层次, 这还仅仅是初禅. 写在这里, 也算一个诱惑, 但千万别去贪恋和执着任何感受, 诸法无我!</li>
</ul>
<p>最后说说佛法的科学性. 维基百科对科学有如下定义: <code>科学是通过经验实证的方法，对现象（原来指自然现象，现泛指包括社会现象等现象）进行归因的学科。科学活动所得的知识是条件明确的（不能模棱两可或随意解读）、能经得起检验的，而且不能与任何适用范围内的已知事实产生矛盾。</code>. 我对科学的认知就是: 逻辑性的怀疑和批判精神, 如果一个理论在一定的认知范围内, 疑无可疑, 批无可批, 就是科学的理论. 而不科学并不一定就是错的, 其表达的内容为一个理论或想法, 或被证伪了(错的), 或存疑没有定论, 两者都是不科学. 因而可以这样说, 中医是不科学的, 但不意味着中医就是错的, 仅仅是因为当今的手段无法证伪或证真, 存疑而已. 而牛顿经典力学放在微观领域, 是不科学的, 这已经被证伪了.</p>
<p>通过前文的介绍, 想必已经知道释迦摩尼真正关注只是教人实修的方法, 并加了自己厌世的观点而提出了一个终极目标. 去掉明显带有主观性的终极目标, 其教授的这套方法其实是非常科学而客观的. 首先要求的就是戒定慧和诸法无我(经验实证的方法), 要去掉主观判断来观察自身的客观身心表现(对现象进行归因, 即诸行无常). 这一整套方法和体验已经被非常多的人重复过了(条件明确, 经得起检验). 定是先决条件, 就好比研究粒子现象需要粒子加速器, 要观察自身就需要定! 个人没有定, 体验不到慧, 并不能说佛法不科学. 人们总不能说, 我没亲眼看到过粒子加速器里粒子的表现, 就直接说量子力学是不科学的吧? 再进一步追问, 我们自己明明没有做过任何关于量子力学的实验, 为什么很自然的就认为量子力学是科学的?</p>
<p>综上, 只有从释迦摩尼亲自教导的实修方法出发, 才最少的受宗教, 神化, 利益等等世俗观念的影响, 最为客观, 最能直观佛法的核心, 方能自己去判断佛法的对错和真伪, 这也才是最科学的态度. 学习佛教, 千万别去纠结于流传于世的各种观念, 所有的这些观念都无助于实修.</p>
<h1 id="一个妄想"><a href="#一个妄想" class="headerlink" title="一个妄想"></a>一个妄想</h1><p>在<a href="https://www.meiwen.com.cn/subject/twmdsftx.html" target="_blank" rel="noopener">一张简单图片演示的“甚深佛法”</a> 和 <a href="http://blog.sina.com.cn/s/blog_6a0da51a0101asxu.html" target="_blank" rel="noopener">几年来深入思考和佛法禅修实践的总结</a> 提出了这么一点: <strong>“当观察存在了，则有被观察者的存在。因为观察生起，则被观察者生起，当观察不存在了，则没有被观察者的存在，因为观察的灭去，则有被观察者的灭去。”</strong>, 后文是对前文的补充, 就是反之亦然, 观察者和被观察者同生同灭. 这就很有意思了, 而且我认为这非常接近世界的本源了. 量子力学, 多多少少也体现了这么一种可能性.</p>
<p>这里, 我从交易市场出发, 来详细说明这里面的因果. 交易市场的最低级别是个人发出的一笔笔交易信息, 是断续的, 一份一份的. 最终走出的行情, 就如山峦一样起起伏伏. 请问, 交易市场这个事物, 是客观存在的吗? 是唯物的还是唯心的? 交易者(观察者)和股市市场(被观察者)是一种什么样的关系? 交易市场, 只要具有贪嗔的生命体在里面交易, 它就会一直客观的存在着! 当所有生命体不在关注股票市场时, 它就消亡了. 本质上, 交易市场诞生于人类的心念, 也可终结于人类的心念. 注意: 一二个个体的退出对股票市场毫无影响, 必须是参与其中的所有个体整体退出! 因而可以说: 交易市场诞生于人类的心念, 也可以由人类全体不参与股票市场而被终结! 这里可以进一步的说, 对应着由观察者心念生起而生起, 因观察者心念灭去而灭去! 而交易市场的灭去, 同样意味着所有观察交易市场的心念没了寄托之处, 也灭去了.</p>
<p>然后, 交易市场和观察者是如何因缘互动的呢? 当你我真金实银炒股时, 只要看一眼股市, 你我就由于贪嗔痴, 在当下与股市产生了互动. 因为这意味着将来某个时候你必定会基于当下这一眼的观察和后续一些列的观察而产生买卖操作. 你我一旦进行了买卖操作, 就事实上对股市走动产生了影响. 进一步推论就是: 只要你我真金实银的在炒股, 那么哪怕就是看一眼股市, 都会对股市走动产生影响(影响发生在未来)! 要在交易市场里涅槃, 对个人而言就比较简单: 没有参与其中的心念. 这时候, 你看走势就是走势, 你的心态和股市都毫无影响. 而大乘的观点是, 佛要参与到交易市场, 但是佛的心态毫无波澜, 并去告知交易市场充满了不确定性和痛苦, 赶快离开交易市场吧(这就是大乘佛教提出的终极目标). 交易市场的结论: 诸势无常, 诸利无我, 涅槃寂灭. 交易市场的走势是无常的, 交易市场的盈亏与我无关, 那么对于交易市场, 我涅槃寂静, 玩笑了.</p>
<p>分析好了交易市场, 那么再推广到人类创造的汽车, 轮船, 大楼, 城市, 以及不是由人创造的草木, 山水等事物, 又如何呢? 很难想象这些实物会因为人去而消失吧? 这里面有个级别问题. 学过缠论的话的知道, 走势有时空上的自相似性. 同一尺度下, 近期走势和历史走势有自相似性, 不同的时间层面上, 如15分钟, 60分钟, 天也有自相似性. 而所有这些自相似性, 我们是知道来源于那一笔笔包含着贪嗔痴的交易构成的. 假设那么一个炒股的人不知道股票的底细, 看着最低只提供到5分钟K线图的炒股软件, 那么这个人要如何去理解市场走势呢? 缠论给了明确的答案: 去理解级别的自相似性, 然后向下或向上推论即可.</p>
<p>在<a href="https://draapho.github.io/2017/10/09/1728-ultimatethink/">“我的终极思考-从细胞到星球生命”</a>里, 列出了这种级别关系(见下表), 并相信里面有着自相似性. 这种自相似性就是生命的本源, 甚至是一切事物的本源, 等同于”诸行无常”,”道”,”空”,”一” 这种观念. 有可能和KK提出的造物九律相关, 一定和数学里的概率论, 博弈论, 信息论相关, 是一种描述众多事物动态变化发展的理论, 这种永不停歇的动态变化发展就是诸行无常.</p>
<table>
<thead>
<tr>
<th>人的进化</th>
<th>人类的进化</th>
<th>特性</th>
</tr>
</thead>
<tbody>
<tr>
<td>细胞</td>
<td>人</td>
<td>低层次的基本单位</td>
</tr>
<tr>
<td>细菌</td>
<td>原始部落</td>
<td>自给自足</td>
</tr>
<tr>
<td>植物</td>
<td>原始帝国</td>
<td>职能分层</td>
</tr>
<tr>
<td>动物</td>
<td>现代社会</td>
<td>高度特质化</td>
</tr>
<tr>
<td>人</td>
<td>星球生命</td>
<td>高层次的基本单位</td>
</tr>
</tbody>
</table>
<ul>
<li>…(高分子, 分子, 原子, 粒子怎么来的?)</li>
<li>…(细胞怎么来的?)</li>
<li>在人体内, 充满了各种特质化的细胞, 细菌群落, 让人生存着, 发展着.</li>
<li>在人类社会, 充满了各种专职化的个人, 让人类社会生存着, 发展着.</li>
<li>在银河系内, 充满了各种专职化的星球, 让银河生命生存着, 发展着.</li>
<li>…(宇宙之外又是什么?)</li>
</ul>
<p>如果理解了交易市场是由人心构建的, 至少不难理解人类世界是由人心和物质共同的构建的, 或再进一步, 地球生态是由生命的贪嗔痴疑慢和物质共同构建的. 基于这一点, 往上推论是很简单的: 如果能星际移民, 那么行星就有可能变成细胞级别的生命体, 在星系级别去构建一个个巨大的生命体. 难的是往下推论: 物质是哪里来的? 最前沿的物理学给的答案似乎是: 从能量而来, 到能量而去, 随机变化. 佛教则对这个世界给了明确的答案: 诸行无常. 在当下的科学理解下, 生命体由物质构成, 生命体又似乎是特殊的物质, 其实倒过来想更简单: 微观物质和生命体同源, 宏观物质是微观物质构建起的某种稳态的常规表现, 而生命体是微观物质构建起的特殊表现, 好比某些复杂数学方程的特殊解. 此时, 宏观的一切东西, 都是微观物质的某种表现, 而微观物质的存在与否, 受我们不知道的因素所影响. 若所有这些因素消失, 整个世界便轰然倒塌. 当然, 这只是猜测, 不能证真也不能证伪. 整个构想, 基于朴素的无处不在的级别自相似性. 这种时空级别的自相似性, 从微观世界到宏观宇宙, 从细菌到细胞到简单生命体到人到人类社会(譬如博弈论就能解释很多生命现象, 细菌的生长和城市的扩张路径是类似的), 无处不在!</p>
<p>顺便一提, <a href="https://www.meiwen.com.cn/subject/twmdsftx.html" target="_blank" rel="noopener">一张简单图片演示的“甚深佛法”</a> 的作者提到, 突然体验到<code>快速的生灭</code>, 感到<code>抓也抓不着，躲也躲不掉，无比煎熬</code>, 其中快速的生灭是客观描述, 无比煎熬是主观描述. 我关注的是, 如果提前说清楚了这么一种状态的存在, 是否就可以减轻这种苦的感觉. 这如同人第一次接触死人, 总是会特别惊悚, 但习惯了也就习惯了, 并不能因为第一次的惊悚, 就觉得人生就是惊悚(我始终对”一切皆苦”存疑). 另外, 猜测这种快速生灭的本质是, 在无我的状态下, 感受到了人体内细胞甚至更底层物质的永不停歇的自主活动. 或者放大一个层面去理解, 在国家层面内观, 一个国家的执政体系往往自我感觉良好, 可以对外战争, 对内收税, 对诸多活动控制的有条不紊, 政治经济发展井井有序, 无一不是自己的功劳(一种我的观念). 如果有一天, 这个执政体系解散(无政府状态), 它会发现所有的人一样在那里忙忙碌碌, 组织有序, 社会运行平稳, 原来一切都不受执政体系影响, 自顾自的运行着. 如果一个执政体系突然意识到自己一点都不重要, 是可有可无的, 多半也会焦虑不堪.</p>
<p>最后, 摘录Aggavara前辈在”原始佛教修学指南（博客导读）”里的语句:</p>
<blockquote>
<p>本人的观点仅供参考 读者应当保持足够的理性与怀疑态度<br>不要盲信任何观点包括本人的观点<br>本人观点是否正确, 需要每一位修行者严谨的通过理论学习以及禅修实践来判断</p>
</blockquote>
<p>理性的怀疑和批判, 亲力亲为的实验和实践, 这才是真正科学的态度. 释迦摩尼的佛法和科学, 并不冲突!</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/05/08/1817-interview-linux/" itemprop="url">
                  面试之嵌入式Linux
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2018-05-08T00:00:00+10:00" content="2018-05-08">
              2018-05-08
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/interview/" itemprop="url" rel="index">
                    <span itemprop="name">interview</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h1><ul>
<li><a href="https://draapho.github.io/2017/05/04/1714-expression/">逻辑|这样表达，事半功倍</a></li>
<li><a href="https://draapho.github.io/2018/01/10/1805-interview-general/">面试之常规问题</a></li>
<li><a href="https://draapho.github.io/2018/05/07/1816-interview-c/">面试之嵌入式C语言</a></li>
<li><a href="https://draapho.github.io/2017/05/17/1715-c/">C语言知识巩固</a></li>
<li><a href="https://draapho.github.io/2018/05/08/1817-interview-linux/">面试之嵌入式Linux</a></li>
</ul>
<p>我个人面试经验极少, 但这种能力都是需要培养的. 此系列总结一下面试中常见的技能要点. 侧重于技术面的准备.</p>
<h1 id="common"><a href="#common" class="headerlink" title="common"></a>common</h1><h2 id="Q-What-Is-The-Difference-Between-Microprocessor-And-Microcontroller"><a href="#Q-What-Is-The-Difference-Between-Microprocessor-And-Microcontroller" class="headerlink" title="Q: What Is The Difference Between Microprocessor And Microcontroller?"></a>Q: What Is The Difference Between Microprocessor And Microcontroller?</h2><p>Microcontroller is a self-contained system with peripherals, memory and a processor that can be used as embedded system.</p>
<p>Microprocessor is managers of the resources (I/O, memory) which lie outside of its architecture.</p>
<h2 id="Q-Difference-btwn-Process-and-Thread"><a href="#Q-Difference-btwn-Process-and-Thread" class="headerlink" title="Q: Difference btwn Process and Thread"></a>Q: Difference btwn Process and Thread</h2><p>the threads are a part of a process<br>Process has a self-contained execution environment, each process has its own memory space. just can use IPC to communication<br>Threads share resources, which helps in efficient communication between threads.</p>
<h2 id="Q-What-is-thread-safety-What-is-re-entrancy"><a href="#Q-What-is-thread-safety-What-is-re-entrancy" class="headerlink" title="Q: What is thread safety? What is re-entrancy?"></a>Q: What is thread safety? What is re-entrancy?</h2><p>线程安全的概念比较直观，一般来说，一个函数被称为线程安全的，当且仅当被多个并发线程反复调用时，它会一直产生正确的结果.<br>可重入函数一定是线程安全的. 但线程安全的函数不一定是可重入的.</p>
<p>对于可重入函数, 有如下要求:</p>
<ul>
<li>不使用全局变量或静态变量；</li>
<li>不使用用malloc或者new开辟出的空间；</li>
<li>不调用不可重入函数；</li>
</ul>
<h2 id="Q-Explain-Interrupt-Latency-And-How-Can-We-Decrease-It"><a href="#Q-Explain-Interrupt-Latency-And-How-Can-We-Decrease-It" class="headerlink" title="Q: Explain Interrupt Latency And How Can We Decrease It?"></a>Q: Explain Interrupt Latency And How Can We Decrease It?</h2><ul>
<li>Interrupt latency basically refers to the time span an interrupt is generated and it being serviced by an appropriate routine defined, usually the interrupt handler.</li>
<li>External signals, some condition in the program or by the occurrence of some event, these could be the reasons for generation of an interrupt.</li>
<li>Interrupts can also be masked so as to ignore them even if an event occurs for which a routine has to be executed.</li>
<li>Following steps could be followed to reduce the latency<ul>
<li>ISRs being simple and short.</li>
<li>Interrupts being serviced immediately</li>
<li>Avoiding those instructions that increase the latency period.</li>
<li>Also by prioritizing interrupts over threads.</li>
<li>Avoiding use of inappropriate APIs.</li>
</ul>
</li>
</ul>
<h2 id="Q-What-is-Top-half-amp-bottom-half-of-a-kernel"><a href="#Q-What-is-Top-half-amp-bottom-half-of-a-kernel" class="headerlink" title="Q: What is Top half &amp; bottom half of a kernel?"></a>Q: What is Top half &amp; bottom half of a kernel?</h2><p>Sometimes to handle an interrupt, a substantial amount of work has to be done. But it conflicts with the speed need for an interrupt handler.<br>To handle this situation, Linux splits the handler into two parts: Top half and Bottom half. </p>
<ul>
<li>The top half is the routine that actually responds to the interrupt. </li>
<li>The bottom half on the other hand is a routine that is scheduled by the upper half to be executed later at a safer time.</li>
</ul>
<p>All interrupts are enabled during execution of the bottom half. The top half saves the device data into the specific buffer, schedules bottom half and exits. The bottom half does the rest. This way the top half can service a new interrupt while the bottom half is working on the previous.</p>
<h2 id="Q-List-Out-Various-Uses-Of-Timers-In-Embedded-System"><a href="#Q-List-Out-Various-Uses-Of-Timers-In-Embedded-System" class="headerlink" title="Q: List Out Various Uses Of Timers In Embedded System?"></a>Q: List Out Various Uses Of Timers In Embedded System?</h2><ul>
<li>Real Time Clock (RTC) for the system</li>
<li>Initiating an event after a preset time delay</li>
<li>Initiating an event after a comparison of preset times</li>
<li>Capturing the count value in timer on an event</li>
<li>Between two events finding the time interval</li>
<li>Time slicing for various tasks</li>
<li>Time division multiplexing</li>
<li>Scheduling of various tasks in RTOS    </li>
</ul>
<h2 id="Q-Significance-of-watchdog-timer-in-Embedded-Systems"><a href="#Q-Significance-of-watchdog-timer-in-Embedded-Systems" class="headerlink" title="Q: Significance of watchdog timer in Embedded Systems."></a>Q: Significance of watchdog timer in Embedded Systems.</h2><p>The watchdog timer is a timing device with a predefined time interval. During that interval, some event may occur or else the device generates a time out signal. It is used to reset to the original state whenever some inappropriate events take place which can result in system malfunction. It is usually operated by counter devices.</p>
<h2 id="Q-Difference-between-RISC-and-CISC-processor"><a href="#Q-Difference-between-RISC-and-CISC-processor" class="headerlink" title="Q: Difference between RISC and CISC processor."></a>Q: Difference between RISC and CISC processor.</h2><p>RISC (Reduced Instruction Set Computer) could carry out a few sets of simple instructions simultaneously. Fewer transistors are used to manufacture RISC, which makes RISC cheaper. RISC has uniform instruction set and those instructions are also fewer in number. Due to the less number of instructions as well as instructions being simple, the RISC computers are faster. RISC emphasise on software rather than hardware. RISC can execute instructions in one machine cycle.</p>
<p>CISC (Complex Instruction Set Computer) is capable of executing multiple operations through a single instruction. CISC have rich and complex instruction set and more number of addressing modes. CISC emphasise on hardware rather that software, making it costlier than RISC. It has a small code size, high cycles per second and it is slower compared to RISC.</p>
<h2 id="Q-What-is-RTOS-What-is-the-difference-between-hard-real-time-and-soft-real-time-OS"><a href="#Q-What-is-RTOS-What-is-the-difference-between-hard-real-time-and-soft-real-time-OS" class="headerlink" title="Q: What is RTOS? What is the difference between hard real-time and soft real-time OS?"></a>Q: What is RTOS? What is the difference between hard real-time and soft real-time OS?</h2><p>The scheduler in a Real Time Operating System (RTOS) is designed to provide a predictable execution pattern. In an embedded system, a certain event must be entertained in strictly defined time.<br>To meet real time requirements, the behaviour of the scheduler must be predictable. This type of OS which have a scheduler with predictable execution pattern is called Real Time OS(RTOS). </p>
<p>A Hard real-time system strictly adheres to the deadline associated with the task. If the system fails to meet the deadline, even once, the system is considered to have failed.<br>In case of a soft real-time system, missing a deadline is acceptable. In this type of system, a critical real-time task gets priority over other tasks and retains that priority until it completes.</p>
<h2 id="Q-What-type-of-scheduling-is-there-in-RTOS"><a href="#Q-What-type-of-scheduling-is-there-in-RTOS" class="headerlink" title="Q: What type of scheduling is there in RTOS?"></a>Q: What type of scheduling is there in RTOS?</h2><p>RTOS uses pre-emptive scheduling. In pre-emptive scheduling, the higher priority task can interrupt a running process and the interrupted process will be resumed later.</p>
<h2 id="Q-What-is-priority-inversion-What-is-priority-inheritance"><a href="#Q-What-is-priority-inversion-What-is-priority-inheritance" class="headerlink" title="Q: What is priority inversion? What is priority inheritance?"></a>Q: What is priority inversion? What is priority inheritance?</h2><p>If two tasks share a resource, the one with higher priority will run first. However, if the lower-priority task is using the shared resource when the higher-priority task becomes ready, then the higher-priority task must wait for the lower-priority task to finish. In this scenario, even though the task has higher priority it needs to wait for the completion of the lower-priority task with the shared resource. This is called priority inversion.</p>
<p>Priority inheritance is a solution to the priority inversion problem. The process waiting for any resource which has a resource lock will have the maximum priority. This is priority inheritance. When one or more high priority jobs are blocked by a job, the original priority assignment is ignored and execution of critical section will be assigned to the job with the highest priority in this elevated scenario. The job returns to the original priority level soon after executing the critical section.</p>
<h2 id="Q-What-is-job-of-preprocessor-compiler-assembler-and-linker"><a href="#Q-What-is-job-of-preprocessor-compiler-assembler-and-linker" class="headerlink" title="Q: What is job of preprocessor, compiler, assembler and linker?"></a>Q: What is job of preprocessor, compiler, assembler and linker?</h2><p>The preprocessor commands are processed and expanded by the preprocessor before actual compilation. </p>
<p>After preprocessing, the compiler takes the output of the preprocessor and the source code, and generates assembly code. </p>
<p>Once compiler completes its work, the assembler takes the assembly code and produces an assembly listing with offsets and generate object files.</p>
<p>The linker combines object files or libraries and produces a single executable file. It also resolves references to external symbols, assigns final addresses to functions and variables, and revises code and data to reflect new addresses.</p>
<h2 id="Q-How-you-will-debug-the-memory-issues"><a href="#Q-How-you-will-debug-the-memory-issues" class="headerlink" title="Q: How you will debug the memory issues?"></a>Q: How you will debug the memory issues?</h2><ul>
<li>First of all, double check the code source. Make sure already paired using <code>kmalloc</code> <code>kfree</code> and <code>vmalloc</code> <code>vfree</code></li>
<li><code>free -m</code> to monitor memory using status.</li>
<li><code>kmemleak</code> to log the possible problem</li>
<li>oom or panic information from kernel</li>
<li>Intercept all functions that allocate and deallocate memory.</li>
</ul>
<h2 id="Q-Debugging-techniques"><a href="#Q-Debugging-techniques" class="headerlink" title="Q: Debugging techniques"></a>Q: Debugging techniques</h2><p><code>GDB</code>, printk, led, <code>/var/log/</code></p>
<h1 id="hardware"><a href="#hardware" class="headerlink" title="hardware"></a>hardware</h1><h2 id="Q-What-Does-Dma-Address-Will-Deal-With"><a href="#Q-What-Does-Dma-Address-Will-Deal-With" class="headerlink" title="Q: What Does Dma Address Will Deal With?"></a>Q: What Does Dma Address Will Deal With?</h2><p>DMA address deals with physical addresses. It is a device which directly drives the data and address bus during data transfer. So, it is purely physical address.</p>
<h2 id="Q-What-is-virtual-memory"><a href="#Q-What-is-virtual-memory" class="headerlink" title="Q: What is virtual memory?"></a>Q: What is virtual memory?</h2><p>Virtual memory is a technique that allows processes to allocate memory in case of physical memory shortage using automatic storage allocation upon a request.<br>The advantage of the virtual memory is that the program can have a larger memory than the physical memory. It allows large virtual memory to be provided when only a smaller physical memory is available. </p>
<p>Virtual memory can be implemented using paging.<br>A paging system is quite similar to a paging system with swapping. When we want to execute a process, we swap it into memory. Here we use a lazy swapper called pager rather than swapping the entire process into memory. When a process is to be swapped in, the pager guesses which pages will be used based on some algorithm, before the process is swapped out again. Instead of swapping whole process, the pager brings only the necessary pages into memory. By that way, it avoids reading in unnecessary memory pages, decreasing the swap time and the amount of physical memory.</p>
<h2 id="Q-What-is-kernel-paging-What-is-page-frame"><a href="#Q-What-is-kernel-paging-What-is-page-frame" class="headerlink" title="Q: What is kernel paging? What is page frame?"></a>Q: What is kernel paging? What is page frame?</h2><p>Paging is a memory management scheme by which computers can store and retrieve data from the secondary memory storage when needed in to primary memory. In this scheme, the operating system retrieves data from secondary storage in same-size blocks called pages. The paging scheme allows the physical address space of a process to be non continuous. Paging allows OS to use secondary storage for data that does not fit entirely into physical memory.</p>
<p>A page frame is a block of RAM that is used for virtual memory. It has its page frame number. The size of a page frame may vary from system to system, and it is in the power of 2 in bytes. Also, it is the smallest length block of memory in which an operating system maps memory pages.</p>
<h2 id="Q-Virtual-Address-Linear-Address-Physical-Address"><a href="#Q-Virtual-Address-Linear-Address-Physical-Address" class="headerlink" title="Q: Virtual Address, Linear Address, Physical Address"></a>Q: Virtual Address, Linear Address, Physical Address</h2><p>32-bit CPU 3GB for user layer, 1GB for kernel layer<br><code>kmalloc</code> apply the physical address directly, so it is continuous but size limination<br><code>vmalloc</code> apply the virtual memory, in physical it is not continuous. need MMU to translate to physical memory.<br>Virtual Address – Segment(GDT LDT) – Linear Address – Paging (4 layer Page Directory, Page Table) – Physical Address</p>
<h2 id="Q-How-to-decide-whether-given-processor-is-using-little-endian-format-or-big-endian-format"><a href="#Q-How-to-decide-whether-given-processor-is-using-little-endian-format-or-big-endian-format" class="headerlink" title="Q:How to decide whether given processor is using little endian format or big endian format ?"></a>Q:How to decide whether given processor is using little endian format or big endian format ?</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">check_for_endianness</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> x = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">char</span> *c = (<span class="keyword">char</span>*) &amp;x;</span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">int</span>)*c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Q-nand-vs-nor-flash"><a href="#Q-nand-vs-nor-flash" class="headerlink" title="Q: nand vs nor flash"></a>Q: nand vs nor flash</h2><ul>
<li>使用复杂 vs 使用简单(same as sram)</li>
<li>读取慢 vs 读取快</li>
<li>写入快 vs 写入慢</li>
<li>顺序读取快, 随机存取慢 vs 随机存取快</li>
<li>容量大 vs 容量小</li>
<li>擦写次数多 vs 擦写次数少</li>
<li>yaffs2 vs jffs2</li>
<li>存放引导程序, 参数区 vs 用户文件, 多媒体文件</li>
</ul>
<h2 id="Q-Definition-and-difference-between-Hardware-interrupt-Software-Interrupt-Exception-Trap-and-Signals"><a href="#Q-Definition-and-difference-between-Hardware-interrupt-Software-Interrupt-Exception-Trap-and-Signals" class="headerlink" title="Q: Definition and difference between Hardware interrupt, Software Interrupt, Exception, Trap and Signals?"></a>Q: Definition and difference between Hardware interrupt, Software Interrupt, Exception, Trap and Signals?</h2><ul>
<li>Hardware Interrupts: may arrive anytime, typically IO interrupts.</li>
<li>Exception: may only arrive after the execution of an instruction, for example when the cpu try to devide a number by 0 or a page fault</li>
<li>Trap is a kind of exceptions, whose main purpose is for debugging</li>
<li>Software Interrupt occurs at the request of the programmer. They are used to implement system calls, and handled by the CPU as trap.</li>
<li>Signals are part of the IPC, not belong to interrupts or exceptions.</li>
</ul>
<h2 id="Q-Explain-MMU-in-Linux"><a href="#Q-Explain-MMU-in-Linux" class="headerlink" title="Q: Explain MMU in Linux"></a>Q: Explain MMU in Linux</h2><p>Paged memory management unit. Translation of virtual memory addresses to physical addresses</p>
<h2 id="Q-What-are-high-memory-and-low-memory-on-Linux"><a href="#Q-What-are-high-memory-and-low-memory-on-Linux" class="headerlink" title="Q: What are high memory and low memory on Linux"></a>Q: What are high memory and low memory on Linux</h2><ul>
<li>The High Memory is the segment of memory that user-space programs can address. It cannot touch Low Memory.</li>
<li>Low Memory is the segment of memory that the Linux kernel can address directly. </li>
<li>If the kernel must access High Memory, it has to map it into its own address space first.</li>
<li><code>copy_from_user(&amp;val, data, 1);</code></li>
</ul>
<h2 id="Q-How-to-register-an-interrupt-handler"><a href="#Q-How-to-register-an-interrupt-handler" class="headerlink" title="Q: How to register an interrupt handler?"></a>Q: How to register an interrupt handler?</h2><ul>
<li><code>request_irq(IRQ_ID, handler_irq, ...);</code></li>
<li><code>irqreturn_t handler_irq(int irq, void *dev_id)</code> can get the IRQ_ID from <code>int irq</code></li>
</ul>
<h1 id="kernel"><a href="#kernel" class="headerlink" title="kernel"></a>kernel</h1><h2 id="Q-Linux驱动的一些基本概念"><a href="#Q-Linux驱动的一些基本概念" class="headerlink" title="Q: Linux驱动的一些基本概念"></a>Q: Linux驱动的一些基本概念</h2><ul>
<li>主设备号. 可以人工指定, 也可以由系统动态分配. 理解为设备类型的id即可.</li>
<li>子设备号. 譬如一个led灯的驱动设备, 可以实现多个led的控制. 子设备号可以提供针对特定的led进行控制</li>
<li>mdev. 根据动态驱动模块的信息自动创建设备节点.</li>
<li>地址映射. 这是与单片机的区别. 单片机操作寄存器可以直接使用物理地址. 但linux下使用的是虚拟地址!<ul>
<li>地址转换使用 <code>ioremap</code> <code>iounmap</code> 函数.</li>
<li>一般的芯片商也会提供操作寄存器的函数, 譬如 s3c2410_gpio_setpin</li>
</ul>
</li>
<li>用户空间和内核空间. 两个空间的资源不能直接相互访问. <ul>
<li>驱动程序内经常要用 <code>copy_to_user</code> 以及 <code>copy_from_user</code></li>
</ul>
</li>
</ul>
<h2 id="Q-Linux-调度机制"><a href="#Q-Linux-调度机制" class="headerlink" title="Q: Linux 调度机制"></a>Q: Linux 调度机制</h2><ul>
<li>轮转调度算法(Round Robin), 先来先服务(FIFC)策略, have a time slice</li>
<li>优先级调度算法(Priority): preemptive(抢占式), static priority, dynamic priority</li>
<li>Linux Sheduler: <ul>
<li>pick next, staircase scheduler.</li>
<li>using dynamic priority, and time slice</li>
<li>rt_proirity(实时任务): SCHED_FIFO (just priority), SCHED_RR (time_slice)</li>
</ul>
</li>
</ul>
<h2 id="Q-linux-android-启动流程"><a href="#Q-linux-android-启动流程" class="headerlink" title="Q: linux android 启动流程"></a>Q: linux android 启动流程</h2><ul>
<li>hardware bootloader, can load specific flash address to ram and run automatically</li>
<li>uboot stage1 (start.s): 底层硬件初始化(register), copy stage2 code to ram, init stack, data segment</li>
<li>uboot stage2 (main.c): 硬件初始化(flash, ui, net), load kernel image, copy parameter to specific address for linux</li>
<li>kernel: decompress image, read parameter from uboot, init hardware(register, MMU, paging table)</li>
<li>load filesystem, init environment(<code>etc/inittab</code>, <code>etc/init.d/rcS</code>, <code>bin/sh</code>)</li>
<li>load dymatical drivers, run user application</li>
<li>Then for android: <ul>
<li>zygote (由 Linux init 启动)</li>
<li>Dalvik VM</li>
<li>SyetemServers</li>
<li>Managers</li>
<li>Launcher</li>
</ul>
</li>
</ul>
<h2 id="Q-linux-file-system"><a href="#Q-linux-file-system" class="headerlink" title="Q: linux file system"></a>Q: linux file system</h2><ul>
<li>Linux下一切皆文件, 文件即inode.</li>
<li>索引过程为: 目录inode-&gt;目录名/文件名-&gt;对应inode-&gt;具体内容</li>
<li>BusyBox 是linux下的一个应用程序, 集成了最常用的Linux命令和工具.</li>
<li>最小文件系统 <code>dev/console</code> <code>dev/null</code> init进程<code>bin/busybox</code> <code>etc/inittab</code> C库 <code>lib/</code> 系统程序或脚本 <code>/etc/init.d/rcS</code> <code>bin/sh</code></li>
<li>mdev: 动态加载驱动时, 自动生成节点文件 <code>/dev</code></li>
<li>file format yaffs2 for nand, jffs2 for nor</li>
</ul>
<h2 id="Q-What-do-you-understand-about-Linux-Kernel-and-can-you-edit-it"><a href="#Q-What-do-you-understand-about-Linux-Kernel-and-can-you-edit-it" class="headerlink" title="Q: What do you understand about Linux Kernel and can you edit it?"></a>Q: What do you understand about Linux Kernel and can you edit it?</h2><p>Linux Kernel is the component that manages the hardware resources for the user and that provides essential services and interact with the user commands.<br>Linux Kernel is an open source software and free, and it is released under General Public License so we can edit it and it is legal.</p>
<h2 id="Q-What-are-the-different-types-of-Kernels-Explain"><a href="#Q-What-are-the-different-types-of-Kernels-Explain" class="headerlink" title="Q: What are the different types of Kernels? Explain"></a>Q: What are the different types of Kernels? Explain</h2><p>We can build kernels by many different types, but 3 of the types of kernels are most commonly used: monolithic, microkernel and hybrid.</p>
<ul>
<li><p>Microkernel: This type of kernel only manages CPU, memory, and IPC. This kind of kernel provides portability, small memory footprint and also security.</p>
</li>
<li><p>Monolithic Kernel: Linux is a monolithic kernel. So, this type of kernel provides file management, system server calls, also manages CPU, IPC as well as device drivers. It provides easier access to the process to communicate and as there is not any queue for processor time, so processes react faster.</p>
</li>
<li><p>Hybrid Kernel: In this type of kernels, programmers can select what they want to run in user mode and what in supervisor mode. So, this kernel provides more flexibility than any other kernel but it can have some latency problems.</p>
</li>
</ul>
<h2 id="Q-Linux-operating-system-components"><a href="#Q-Linux-operating-system-components" class="headerlink" title="Q: Linux operating system components"></a>Q: Linux operating system components</h2><ul>
<li>Kernel: Linux is a monolithic kernel</li>
<li>System Library: GNU C Library. Library plays a vital role because application programs access Kernels feature using system library.</li>
<li>System Utility: System Utility performs specific and individual level tasks.</li>
</ul>
<h2 id="Q-Where-is-password-file-located-in-Linux-and-how-can-you-improve-the-security-of-password-file"><a href="#Q-Where-is-password-file-located-in-Linux-and-how-can-you-improve-the-security-of-password-file" class="headerlink" title="Q: Where is password file located in Linux and how can you improve the security of password file?"></a>Q: Where is password file located in Linux and how can you improve the security of password file?</h2><p>This is an important question that is generally asked by the interviewers.<br>User information along with the passwords in Linux is stored in <code>/etc/passwd</code> that is a compatible format. But this file is used to get the user information by several tools. Here, security is at risk. So, we have to make it secured.</p>
<p>To improve the security of the password file, instead of using a compatible format we can use <strong>shadow password format</strong>. </p>
<p>So, in shadow password format, the password will be stored as single “x” character which is not <code>/etc/passwd</code>. This information is stored in another file instead with a file name <code>/etc/shadow</code>. So, to enhance the security, the file is made word readable and also, this file is readable only by the root user. Thus security risks are overcome to a great extent by using the shadow password format.</p>
<h2 id="Q-Explain-system-calls-used-for-process-management"><a href="#Q-Explain-system-calls-used-for-process-management" class="headerlink" title="Q: Explain system calls used for process management?"></a>Q: Explain system calls used for process management?</h2><p>There are some system calls used in Linux for process management.<br>These are as follows:</p>
<ul>
<li><code>Fork()</code>: It is used to create a new process</li>
<li><code>Exec()</code>: It is used to execute a new process</li>
<li><code>Wait()</code>: It is used to make the process to wait</li>
<li><code>Exit()</code>: It is used to exit or terminate the process</li>
<li><code>Getpid()</code>: It is used to find the unique process ID</li>
<li><code>Getppid()</code>: It is used to check the parent process ID</li>
<li><code>Nice()</code>: It is used to bias the currently running process property</li>
</ul>
<h2 id="Q-Guess-the-output"><a href="#Q-Guess-the-output" class="headerlink" title="Q:Guess the output"></a>Q:Guess the output</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">main() &#123;</span><br><span class="line">	fork();</span><br><span class="line">	fork();</span><br><span class="line">	fork();</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"hello world\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>It will print “hello world’ 8 times.<br>The main() will print one time and creates 3 children, let us say Child_1, Child_2, Child_3. All of them printed once.<br>The Child_3 will not create any child.<br>Child2 will create one child and that child will print once.<br>Child_1 will create two children, say Child_4 and Child_5 and each of them will print once.<br>Child_4 will again create another child and that child will print one time.<br>A total of eight times the printf statement will be executed.</p>
<h2 id="Q-What-is-the-difference-between-static-linking-and-dynamic-linking"><a href="#Q-What-is-the-difference-between-static-linking-and-dynamic-linking" class="headerlink" title="Q: What is the difference between static linking and dynamic linking ?"></a>Q: What is the difference between static linking and dynamic linking ?</h2><p>In static linking, all the library modules used in the program are placed in the final executable file making it larger in size. This is done by the linker. If the modules used in the program are modified after linking, then re-compilation is needed. The advantage of static linking is that the modules are present in an executable file. We don’t want to worry about compatibility issues.</p>
<p>In case of dynamic linking, only the names of the module used are present in the executable file and the actual linking is done at run time when the program and the library modules both are present in the memory. That is why, the executables are smaller in size. Modification of the library modules used does not force re-compilation. But dynamic linking may face compatibility issues with the library modules used.</p>
<h2 id="Q-How-a-user-mode-is-transferred-to-kernel-mode-Difference-between-kernerl-user-space"><a href="#Q-How-a-user-mode-is-transferred-to-kernel-mode-Difference-between-kernerl-user-space" class="headerlink" title="Q: How a user mode is transferred to kernel mode? Difference between kernerl/user space"></a>Q: How a user mode is transferred to kernel mode? Difference between kernerl/user space</h2><p>using System call<br>kernel mode: can do anything, cpu run in full function<br>user mode: safty purpose, cpu function is liminated.<br>kernel 访问用户层数据: <code>copy_to_user</code> <code>copy_from_user</code></p>
<h2 id="Q-Main-difference-between-Tasklets-and-workqs"><a href="#Q-Main-difference-between-Tasklets-and-workqs" class="headerlink" title="Q: Main difference between Tasklets and workqs?"></a>Q: Main difference between Tasklets and workqs?</h2><ul>
<li>Tasklets:<ul>
<li>are old (around 2.3 I believe)</li>
<li>have a straightforward, simple API</li>
<li>are designed for low latency</li>
<li>cannot sleep</li>
</ul>
</li>
<li>Work queues:<ul>
<li>are more recent (introduced in 2.5)</li>
<li>have a flexible API (more options/flags supported)</li>
<li>are designed for higher latency</li>
<li>can sleep</li>
</ul>
</li>
</ul>
<h2 id="Q-Do-you-know-panic-and-oops-errors-in-kernel-crash"><a href="#Q-Do-you-know-panic-and-oops-errors-in-kernel-crash" class="headerlink" title="Q: Do you know panic and oops errors in kernel crash?"></a>Q: Do you know panic and oops errors in kernel crash?</h2><p>Oops is a way to debug kernel code, and there are utilities for helping with that.<br>A kernel panic means the system cannot recover and must be restarted.<br>However, with an Oops, the system can usually continue. You can configure klogd and syslogd to log oops messages to files, rather than to std out.</p>
<h2 id="Q-What-is-the-name-and-path-of-the-main-system-log"><a href="#Q-What-is-the-name-and-path-of-the-main-system-log" class="headerlink" title="Q: What is the name and path of the main system log?"></a>Q: What is the name and path of the main system log?</h2><p>By default, the main system log is <code>/var/log/messages</code>.<br>This file contains all the messages and the script written by the user. By default, all scripts are saved in this file. This is the standard system log file, which contains messages from all system software, non-kernel boot issues, and messages that go to <code>dmesg</code>.<br><code>dmesg</code> is a system file that is written upon system boot.<br><code>dmesg | less</code> to review boot messages.</p>
<h2 id="Q-Explain-what-happens-when-an-insmod-is-done-an-module"><a href="#Q-Explain-what-happens-when-an-insmod-is-done-an-module" class="headerlink" title="Q: Explain what happens when an insmod is done an module"></a>Q: Explain what happens when an insmod is done an module</h2><p>insmod is a user space utility to load a module into Linux kernel. It calls init_module system call to do the work.<br>init_module loads the kernel module in ELF format into kernel address space. Each section of the ELF are read and mapped using vmalloc().<br>Use of vmalloc is because kernel modules can be big and kernel might not have contiguous physical memory to accommodate for module text and data. </p>
<p>Each .ko has a struct module section. This has relocatable address of init and exit routines (ones specified in module_init and module_exit). This goes as a separate section in ELF. Once all the relevant sections are loaded in memory, kernel calls init routine of the module.</p>
<h2 id="Q-How-will-you-insert-a-module-statically-in-to-linux-kernel"><a href="#Q-How-will-you-insert-a-module-statically-in-to-linux-kernel" class="headerlink" title="Q: How will you insert a module statically in to linux kernel."></a>Q: How will you insert a module statically in to linux kernel.</h2><p>Using makefile <code>obj-y</code>. By the way <code>obj-m</code> will generate <code>.ko</code> file.<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">obj-y += mymodule.o</span><br><span class="line">mymodule-objs := src.o other.o</span><br></pre></td></tr></table></figure></p>
<h2 id="Q-what-is-a-device-driver-and-write-a-simple-driver"><a href="#Q-what-is-a-device-driver-and-write-a-simple-driver" class="headerlink" title="Q: what is a device driver and write a simple driver"></a>Q: what is a device driver and write a simple driver</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/xxx.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/xxx.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEVICE_NAME <span class="meta-string">"drv_leds"</span>                      <span class="comment">// 设备类型名称, cat /proc/devices 可以看到</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> major;                                   <span class="comment">// 存储自动分配的主设备号</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">class</span> *<span class="title">leds_class</span>;</span>                    <span class="comment">// 类, 供mdev用, ls /sys/class/ 可以看到</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">class_device</span>	*<span class="title">leds_class_devs</span>[4];</span>    <span class="comment">// 类下设备, ls /sys/class/class_name 可以看到</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ===== 驱动的硬件实现部分, 和单片机类似 =====</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">drv_leds_open</span><span class="params">(struct inode *inode, struct file *file)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> minor = MINOR(inode-&gt;i_rdev);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化对应的LED</span></span><br><span class="line">	gpio_init(minor);</span><br><span class="line">    printk(<span class="string">"drv_leds_open\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> ssize_t <span class="title">drv_leds_write</span><span class="params">(struct file *file, <span class="keyword">const</span> <span class="keyword">char</span> __user *data, <span class="keyword">size_t</span> len, <span class="keyword">loff_t</span> *ppos)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> minor = MINOR(file-&gt;f_dentry-&gt;d_inode-&gt;i_rdev);</span><br><span class="line">    <span class="keyword">char</span> val;</span><br><span class="line">    copy_from_user(&amp;val, data, <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 操作对应的LED</span></span><br><span class="line">    gpio_set(minor);</span><br><span class="line">    printk(<span class="string">"drv_leds_write, led%d=%d\n"</span>, minor, val);</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此结构体指定了C库的文件操作函数需要调用的底层驱动的函数名.</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">drv_leds_fops</span> = &#123;</span></span><br><span class="line">    .owner  =   THIS_MODULE,        <span class="comment">// 这是一个宏，指向编译模块时自动创建的__this_module变量. 和平台相关</span></span><br><span class="line">    .open   =   drv_leds_open,     </span><br><span class="line">    .write  =   drv_leds_write,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// ===== 加载和卸载内核时, 指定要调用的函数 =====</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">drv_leds_init</span><span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> minor;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取寄存器起始地址的虚拟地址值. 其它寄存器基于此值再用偏移量.</span></span><br><span class="line">    <span class="comment">// gpio_base = ioremap(0x56000000, 0xD0);</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 注册驱动, 0表示动态分配主设备号</span></span><br><span class="line">    major = register_chrdev(<span class="number">0</span>, DEVICE_NAME, &amp;drv_leds_fops);    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 生成系统设备信息, 供mdev自动创建设备节点使用</span></span><br><span class="line">	leds_class = class_create(THIS_MODULE, <span class="string">"leds"</span>);             <span class="comment">// 创建 leds 类</span></span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(leds_class))</span><br><span class="line">		<span class="keyword">return</span> PTR_ERR(leds_class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 0-3 表示4个独立的led, 名称为 led0, led1, led2, led3</span></span><br><span class="line">    <span class="keyword">for</span> (minor = <span class="number">0</span>; minor &lt; <span class="number">4</span>; minor++) &#123;</span><br><span class="line">		leds_class_devs[minor] = class_device_create(leds_class, <span class="literal">NULL</span>, MKDEV(major, minor), <span class="literal">NULL</span>, <span class="string">"led%d"</span>, minor);</span><br><span class="line">		<span class="keyword">if</span> (unlikely(IS_ERR(leds_class_devs[minor])))</span><br><span class="line">			<span class="keyword">return</span> PTR_ERR(leds_class_devs[minor]);</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    printk(DEVICE_NAME <span class="string">" initialized\n"</span>);                       <span class="comment">// 调试用</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">drv_leds_exit</span><span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> minor;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (minor = <span class="number">0</span>; minor &lt; <span class="number">4</span>; minor++) &#123;                       </span><br><span class="line">		class_device_unregister(leds_class_devs[minor]);        <span class="comment">// 删除设备节点</span></span><br><span class="line">	&#125;</span><br><span class="line">	class_destroy(leds_class);                                  <span class="comment">// 删除设备类</span></span><br><span class="line">    unregister_chrdev(major, DEVICE_NAME);                      <span class="comment">// 卸载驱动</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// iounmap(gpio_base);</span></span><br><span class="line">    printk(DEVICE_NAME <span class="string">" deinitialized\n"</span>);     </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(drv_leds_init);</span><br><span class="line">module_exit(drv_leds_exit);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ===== 描述驱动程序的一些信息，不是必须的 =====</span></span><br><span class="line">MODULE_AUTHOR(<span class="string">"draapho"</span>);</span><br><span class="line">MODULE_VERSION(<span class="string">"0.1.1"</span>);</span><br><span class="line">MODULE_DESCRIPTION(<span class="string">"First Driver for LED"</span>);</span><br><span class="line">MODULE_LICENSE(<span class="string">"GPL"</span>);</span><br></pre></td></tr></table></figure>
<h1 id="IPC"><a href="#IPC" class="headerlink" title="IPC"></a>IPC</h1><h2 id="Q-How-many-types-of-IPC-mechanism-you-know"><a href="#Q-How-many-types-of-IPC-mechanism-you-know" class="headerlink" title="Q: How many types of IPC mechanism you know?"></a>Q: How many types of IPC mechanism you know?</h2><ul>
<li>Named pipes or FIFO</li>
<li>Semaphores</li>
<li>Shared memory</li>
<li>Message queue</li>
<li>Socket</li>
</ul>
<h2 id="Q-Explain-What-Is-Semaphore"><a href="#Q-Explain-What-Is-Semaphore" class="headerlink" title="Q: Explain What Is Semaphore?"></a>Q: Explain What Is Semaphore?</h2><p>A semaphore is an abstract datatype or variable that is used for controlling access, by multiple processes to a common resource in a concurrent system such as multiprogramming operating system.  </p>
<p>Semaphores are commonly used for two purposes:</p>
<ul>
<li>To share a common memory space</li>
<li>To share access to files</li>
</ul>
<p>Semaphores are of two types:</p>
<ul>
<li>Binary semaphore: It can have only two values (0 and 1). The semaphore value is set to 1 by the process in charge, when the resource is available.</li>
<li>Counting semaphore: It can have value greater than one. It is used to control access to a pool of resources.</li>
</ul>
<h2 id="Q-What-is-difference-between-binary-semaphore-and-mutex"><a href="#Q-What-is-difference-between-binary-semaphore-and-mutex" class="headerlink" title="Q: What is difference between binary semaphore and mutex?"></a>Q: What is difference between binary semaphore and mutex?</h2><ul>
<li>Mutual exclusion and synchronization can be used by binary semaphore while mutex is used only for mutual exclusion.</li>
<li>A mutex can be released by the same thread which acquired it. Semaphore values can be changed by other thread also.</li>
<li>From an ISR, a mutex can not be used.</li>
<li>The advantage of semaphores is that, they can be used to synchronize two unrelated processes trying to access the same resource.</li>
<li>Semaphores can act as mutex, but the opposite is not possible.</li>
</ul>
<h2 id="Q-What-is-spin-lock"><a href="#Q-What-is-spin-lock" class="headerlink" title="Q: What is spin lock?"></a>Q: What is spin lock?</h2><p>If a resource is locked, a thread that wants to access that resource may repetitively check whether the resource is available. During that time, the thread may loop and check the resource without doing any useful work. Suck a lock is termed as spin lock.</p>
<h2 id="Q-Explain-Whether-We-Can-Use-Semaphore-Or-Mutex-Or-Spinlock-In-Interrupt-Context-In-Linux-Kernel"><a href="#Q-Explain-Whether-We-Can-Use-Semaphore-Or-Mutex-Or-Spinlock-In-Interrupt-Context-In-Linux-Kernel" class="headerlink" title="Q: Explain Whether We Can Use Semaphore Or Mutex Or Spinlock In Interrupt Context In Linux Kernel?"></a>Q: Explain Whether We Can Use Semaphore Or Mutex Or Spinlock In Interrupt Context In Linux Kernel?</h2><p>Mutex cannot be used for interrupt context in Linux Kernel.<br>Semaphore only can use <code>sema_post</code> in interrupt handler.<br>Spinlocks can be used for locking in interrupt context.</p>
<h2 id="Q-What-is-shared-memory"><a href="#Q-What-is-shared-memory" class="headerlink" title="Q: What is shared memory?"></a>Q: What is shared memory?</h2><p>Shared memory is the fastest interprocess communication mechanism. The operating system maps a memory segment in the address space of several processes, so that several processes can read and write in that memory segment without calling operating system functions. However, we need some kind of synchronization between processes that read and write shared memory.</p>
<h2 id="Q-How-to-come-out-of-deadlock"><a href="#Q-How-to-come-out-of-deadlock" class="headerlink" title="Q: How to come out of deadlock?"></a>Q: How to come out of deadlock?</h2><p>The most common error causing deadlock is self deadlock or recursive deadlock: </p>
<ul>
<li>a thread tries to acquire a lock it is already holding. </li>
<li>Recursive deadlock is very easy to program by mistake.</li>
</ul>
<p>Here are some simple guidelines for locking.</p>
<ul>
<li>Try not to hold locks across long operations like I/O where performance can be adversely affected.</li>
<li>Don’t hold locks when calling a function that is outside the module and that might reenter the module.</li>
<li>In general, start with a coarse-grained approach, identify bottlenecks, and add finer-grained locking where necessary to alleviate the bottlenecks. Most locks are held for short amounts of time and contention is rare, so fix only those locks that have measured contention.</li>
<li>When using multiple locks, avoid deadlocks by making sure that all threads acquire the locks in the same order.</li>
</ul>
<h2 id="Q-生产者-消费者写法"><a href="#Q-生产者-消费者写法" class="headerlink" title="Q: 生产者, 消费者写法"></a>Q: 生产者, 消费者写法</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">goods</span>  </span></span><br><span class="line"><span class="class">&#123;</span>  </span><br><span class="line">    <span class="keyword">int</span> id;  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">goods</span> *<span class="title">next</span>;</span>  </span><br><span class="line">&#125;;  </span><br><span class="line"><span class="keyword">pthread_mutex_t</span> m;  </span><br><span class="line"><span class="keyword">pthread_cond_t</span> has_product;  </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">goods</span> *<span class="title">head</span>;</span>  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">producer</span><span class="params">(<span class="keyword">void</span> *argv)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">goods</span> *<span class="title">p</span> = <span class="title">NULL</span>;</span>  </span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)  </span><br><span class="line">    &#123;  </span><br><span class="line">        pthread_mutex_lock(&amp;m);  </span><br><span class="line">        p = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct goods));  </span><br><span class="line">        p-&gt;id = rand() % <span class="number">100</span>;  </span><br><span class="line">        p-&gt;next = head;  </span><br><span class="line">        head = p;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"produce %d\n"</span>, p-&gt;id);  </span><br><span class="line">        pthread_mutex_unlock(&amp;m);  </span><br><span class="line">        pthread_cond_signal(&amp;has_product);  </span><br><span class="line">        <span class="comment">//printf("produce %d\n", p-&gt;id);  </span></span><br><span class="line">        sleep(rand() % <span class="number">2</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">void</span> *)<span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">comsumer</span><span class="params">(<span class="keyword">void</span> *argv)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">goods</span> *<span class="title">p</span> = <span class="title">NULL</span>;</span>  </span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)  </span><br><span class="line">    &#123;  </span><br><span class="line">        pthread_mutex_lock(&amp;m);  </span><br><span class="line">        <span class="comment">//思考：pthread_cond_wait()的作用？  </span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">NULL</span> == head)  </span><br><span class="line">            pthread_cond_wait(&amp;has_product, &amp;m);  </span><br><span class="line">        p = head;  </span><br><span class="line">        head = head-&gt;next;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"comsume %d\n"</span>, p-&gt;id);  </span><br><span class="line">        pthread_mutex_unlock(&amp;m);  </span><br><span class="line">        <span class="comment">//printf("comsume %d\n", p-&gt;id);  </span></span><br><span class="line">        <span class="built_in">free</span>(p);  </span><br><span class="line">        sleep(rand() % <span class="number">2</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">void</span> *)<span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 开启两个线程作为生产者，三个线程作为消费者</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> i;  </span><br><span class="line">    <span class="comment">//初始化条件变量和互斥量  </span></span><br><span class="line">    pthread_mutex_init(&amp;m, <span class="literal">NULL</span>);  </span><br><span class="line">    pthread_cond_init(&amp;has_product, <span class="literal">NULL</span>);  </span><br><span class="line">    head = <span class="literal">NULL</span>;  </span><br><span class="line">    <span class="keyword">pthread_t</span> pro[<span class="number">2</span>], com[<span class="number">3</span>];  </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)  </span><br><span class="line">        pthread_create(&amp;pro[i], <span class="literal">NULL</span>, producer, <span class="literal">NULL</span>);  </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)  </span><br><span class="line">        pthread_create(&amp;com[i], <span class="literal">NULL</span>, comsumer, <span class="literal">NULL</span>);  </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)  </span><br><span class="line">        pthread_join(pro[i], <span class="literal">NULL</span>);  </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)  </span><br><span class="line">        pthread_join(com[i], <span class="literal">NULL</span>);  </span><br><span class="line">    <span class="comment">//销毁条件变量和互斥量  </span></span><br><span class="line">    pthread_mutex_destroy(&amp;m);  </span><br><span class="line">    pthread_cond_destroy(&amp;has_product);  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="bash-command"><a href="#bash-command" class="headerlink" title="bash command"></a>bash command</h1><h2 id="Q-How-can-I-redirect-both-stderr-and-stdin-at-once"><a href="#Q-How-can-I-redirect-both-stderr-and-stdin-at-once" class="headerlink" title="Q: How can I redirect both stderr and stdin at once?"></a>Q: How can I redirect both stderr and stdin at once?</h2><p>command <code>&gt; file.log 2&gt;&amp;1</code> : Redirect stderr to “where stdout is currently going”. In this case, that is a file opened in append mode. In other words, the <code>&amp;1</code> reuses the file descriptor which stdout currently uses.</p>
<h2 id="Q-what-is-proc-entry-and-how-it-is-useful"><a href="#Q-what-is-proc-entry-and-how-it-is-useful" class="headerlink" title="Q: what is /proc entry and how it is useful"></a>Q: what is <code>/proc</code> entry and how it is useful</h2><p>Virtual directory for system information, 虚拟档案系统. 数据都在内存当中,不占用硬盘空间.<br>主要包括系统核心,接口设备状态,网络状态.<br>比较重要的档案例: <code>proc/cpuinfo</code>  <code>/proc/interrupts</code>  <code>/proc/ioports</code></p>
<h2 id="How-can-we-edit-a-file-without-opening-in-Linux"><a href="#How-can-we-edit-a-file-without-opening-in-Linux" class="headerlink" title="How can we edit a file without opening in Linux?"></a>How can we edit a file without opening in Linux?</h2><p><code>sed</code> command is used to edit a file without opening.<br><code>sed</code> command is used to modify or change the contents of a file.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># For example, we have a text file with below content</span></span><br><span class="line">&gt; cat file.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># replace “sed” with “vi”</span></span><br><span class="line">&gt;sed ‘s/sed/vi/’ file.txt</span><br></pre></td></tr></table></figure>
<h2 id="Q-How-can-you-find-out-how-much-memory-Linux-is-using"><a href="#Q-How-can-you-find-out-how-much-memory-Linux-is-using" class="headerlink" title="Q: How can you find out how much memory Linux is using?"></a>Q: How can you find out how much memory Linux is using?</h2><p><code>cat /proc/meminfo</code></p>
<h2 id="Q-Explain-grep-command-and-its-use"><a href="#Q-Explain-grep-command-and-its-use" class="headerlink" title="Q: Explain grep command and its use."></a>Q: Explain grep command and its use.</h2><p><code>grep</code> command in Linux is used to search a specific pattern. Grep command will help you to explore the string in a file or multiple files.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">grep ‘word’ filename</span><br><span class="line">grep ‘word’ file1 file2 file3</span><br><span class="line"><span class="built_in">command</span> | grep ‘string’</span><br><span class="line"></span><br><span class="line"><span class="comment"># For example,</span></span><br><span class="line"></span><br><span class="line">grep “smith” passwd</span><br><span class="line">grep “smith” passwd shadow</span><br><span class="line">netstat -an | grep 8083</span><br><span class="line">cat /etc/passwd | grep smith</span><br></pre></td></tr></table></figure>
<h2 id="Q-Explain-file-content-commands-along-with-the-description"><a href="#Q-Explain-file-content-commands-along-with-the-description" class="headerlink" title="Q: Explain file content commands along with the description."></a>Q: Explain file content commands along with the description.</h2><ul>
<li><code>head</code>: to check the starting of a file.</li>
<li><code>tail</code>: to check the ending of the file. It is the reverse of head command.</li>
<li><code>cat</code>: used to view, create, concatenate the files.</li>
<li><code>more</code>: used to display the text in the terminal window in pager form.</li>
<li><code>less</code>: used to view the text in the backward direction and also provides single line movement.</li>
</ul>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://www.wisdomjobs.com/e-university/linux-embedded-systems-interview-questions.html" target="_blank" rel="noopener">Linux Embedded systems Interview Questions &amp; Answers</a></li>
<li><a href="http://linuxdevicedrivercinterviewqs.blogspot.com.au/" target="_blank" rel="noopener">Linux Device Driver,Embedded C Interview Questions</a></li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/05/07/1816-interview-c/" itemprop="url">
                  面试之嵌入式C语言
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2018-05-07T00:00:00+10:00" content="2018-05-07">
              2018-05-07
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/interview/" itemprop="url" rel="index">
                    <span itemprop="name">interview</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h1><ul>
<li><a href="https://draapho.github.io/2017/05/04/1714-expression/">逻辑|这样表达，事半功倍</a></li>
<li><a href="https://draapho.github.io/2018/01/10/1805-interview-general/">面试之常规问题</a></li>
<li><a href="https://draapho.github.io/2018/05/07/1816-interview-c/">面试之嵌入式C语言</a></li>
<li><a href="https://draapho.github.io/2017/05/17/1715-c/">C语言知识巩固</a></li>
<li><a href="https://draapho.github.io/2018/05/08/1817-interview-linux/">面试之嵌入式Linux</a></li>
</ul>
<p>我个人面试经验极少, 但这种能力都是需要培养的.<br>此系列总结一下面试中常见的技能要点. 侧重于技术面的准备.</p>
<h1 id="Q1-define"><a href="#Q1-define" class="headerlink" title="Q1: #define"></a>Q1: #define</h1><p>Using the #define statement, how would you declare a manifest constant that returns the number of seconds in a year? Disregard leap years in your answer.</p>
<p>A1:<br><code>#define SECONDS_PER_YEAR (60UL * 60UL * 24UL * 365UL)</code></p>
<p>I’m looking for several things here:</p>
<ul>
<li>Basic knowledge of the #define syntax (i.e. no semi-colon at the end, the need to parenthesize etc.).</li>
<li>A good choice of name, with capitalization and underscores.</li>
<li>An understanding that the pre-processor will evaluate constant expressions for you. Thus, it is clearer, and penalty free to spell out how you are calculating the number of seconds in a year, rather than actually doing the calculation yourself.</li>
<li>A realization that the expression will oveflow an integer argument on a 16 bit machine hence the need for the L, telling the compiler to treat the expression as a Long.</li>
<li>As a bonus, if you modified the expression with a UL (indicating unsigned long), then you are off to a great start because you are showing that you are mindful of the perils of signed and unsigned types and remember, first impressions count!</li>
</ul>
<h1 id="Q2-define"><a href="#Q2-define" class="headerlink" title="Q2: #define"></a>Q2: #define</h1><p>Write the “standard” MIN macro. That is, a macro that takes two arguments and returns the smaller of the two arguments.</p>
<p>A2:<br><code>#define MIN(A,B) ( (A) &lt;= (B) ? (A) : (B) )</code></p>
<p>The purpose of this question is to test the following:</p>
<ul>
<li>Basic knowledge of the #define directive as used in macros. This is important, because until the inline operator becomes part of standard C, macros are the only portable way of generating inline code. Inline code is often necessary in embedded systems in order to achieve the required performance level.</li>
<li>Knowledge of the ternary conditional operator. This exists in C because it allows the compiler to potentially produce more optimal code than an ifthen-else sequence. Given that performance is normally an issue in embedded systems, knowledge and use of this construct is important.</li>
<li>Understanding of the need to very carefully parenthesize arguments to macros.</li>
<li>I also use this question to start a discussion on the side effects of macros, e.g. what happens when you write code such as : <code>least = MIN(*p++, b);</code></li>
</ul>
<h1 id="Q3-error"><a href="#Q3-error" class="headerlink" title="Q3: #error"></a>Q3: #error</h1><p>What is the purpose of the preprocessor directive #error?</p>
<p>A3:<br>Either you know the answer to this, or you don’t. If you don’t, then see reference.<br>This question is very useful for dierentiating between normal folks and the nerds. It’s only the nerds that actually read the appendices of C textbooks that find out about such things. Of course, if you aren’t looking for a nerd, the candidate better hope she doesn’t know the answer.</p>
<h1 id="Q4-Infinite-loops"><a href="#Q4-Infinite-loops" class="headerlink" title="Q4: Infinite loops"></a>Q4: Infinite loops</h1><p>Infinite loops often arise in embedded systems. How does one code an infinite loop in C?</p>
<p>A4:<br>There are several solutions to this question. My preferred solution is:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> ( <span class="number">1</span> ) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Another common construct is:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ( ; ; ) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Personally, I dislike this construct because the syntax doesn’t exactly spell out what is going on. Thus, if a candidate gives this as a solution, I’ll use it as an opportunity to explore their rationale for doing so. If their answer is basically “I was taught to do it this way and I have never thought about it since” then it tells me something (bad) about them. Conversely, if they state that it’s the K&amp;R preferred method and the only way to get an infinite loop passed Lint, then they score bonus points.</p>
<p>A third solution is to use a goto:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Loop :</span><br><span class="line">. . .</span><br><span class="line"><span class="keyword">goto</span> Loop ;</span><br></pre></td></tr></table></figure></p>
<p>Candidates that propose this are either assembly language programmers (which is probably good), or else they are closet BASIC / FORTRAN programmers looking to get into a new field.</p>
<h1 id="Q5-Data-declarations"><a href="#Q5-Data-declarations" class="headerlink" title="Q5: Data declarations"></a>Q5: Data declarations</h1><p>Using the variable a, write down definitions for the following:<br>a) An integer<br>b) A pointer to an integer<br>c) A pointer to a pointer to an integer<br>d) An array of ten integers<br>e) An array of ten pointers to integers<br>f) A pointer to an array of ten integers<br>g) A pointer to a function that takes an integer as an argument and returns an integer<br>h) An array of ten pointers to functions that take an integer argument and return an integer</p>
<p>A5:<br>The answers are:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a;          <span class="comment">// An integer</span></span><br><span class="line"><span class="keyword">int</span> *a;         <span class="comment">// A pointer to an integer</span></span><br><span class="line"><span class="keyword">int</span> **a;        <span class="comment">// A pointer to a pointer to an integer</span></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>];      <span class="comment">// An array of ten integers</span></span><br><span class="line"><span class="keyword">int</span> *a[<span class="number">10</span>];     <span class="comment">// An array of ten pointers to integers</span></span><br><span class="line"><span class="keyword">int</span> (*a)[<span class="number">10</span>];   <span class="comment">// A pointer to an array of ten integers</span></span><br><span class="line"><span class="keyword">int</span> (*a)(<span class="keyword">int</span>);  <span class="comment">// A pointer to a function that takes an integer as an argument and returns an integer</span></span><br><span class="line"><span class="keyword">int</span> (*a[<span class="number">10</span>])(<span class="keyword">int</span>); <span class="comment">// An array of ten pointers to functions that take an integer argument and return an integer</span></span><br></pre></td></tr></table></figure></p>
<p>People often claim that a couple of these are the sorts of thing that one looks up in textbooks and I agree. While writing this article, I consulted textbooks to ensure the syntax was correct. However, I expect to be asked this question (or something close to it) when in an interview situation. Consequently, I make sure I know the answers at least for the few hours of the interview. Candidates that don’t know the answers (or at least most of them) are simply unprepared for the interview. If they can’t be prepared for the interview, what will they be prepared for?</p>
<h1 id="Q6-Static"><a href="#Q6-Static" class="headerlink" title="Q6: Static"></a>Q6: Static</h1><p>What are the uses of the keyword static?</p>
<p>A6:<br>This simple question is rarely answered completely. Static has three distinct uses in C:</p>
<ul>
<li>A variable declared static within the body of a function maintains its value between function invocations.</li>
<li>A variable declared static within a module1, (but outside the body of a function) is accessible by all functions within that module. It is not accessible by functions within any other module. That is, it is a localized global.</li>
<li>Functions declared static within a module may only be called by otherfunctions within that module. That is, the scope of the function is localized to the module within which it is declared.</li>
</ul>
<p>Most candidates get the first part correct. A reasonable number get the second part correct, while a pitiful number understand the third answer. This is a serious weakness in a candidate, since they obviously do not understand the importance and benefits of localizing the scope of both data and code.</p>
<h1 id="Q7-Const"><a href="#Q7-Const" class="headerlink" title="Q7: Const"></a>Q7: Const</h1><p>What does the keyword const mean?</p>
<p>A7:<br>As soon as the interviewee says “const means constant”, I know I’m dealing with an amateur. Dan Saks has exhaustively covered const in the last year, such that every reader of ESP should be extremely familiar with what const can and cannot do for you. If you haven’t been reading that column, suffice it to say that const means “read-only”. Although this answer doesn’t really do the subject justice, I’d accept it as a correct answer. (If you want the detailed answer, then read Saks’ columns carefully!).</p>
<p>If the candidate gets the answer correct, then I’ll ask him these supplemental questions:</p>
<h1 id="Q7-1-Const"><a href="#Q7-1-Const" class="headerlink" title="Q7.1: Const"></a>Q7.1: Const</h1><p>What do the following incomplete declarations mean?<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const int a ;</span><br><span class="line">int const a ;</span><br><span class="line">const int *a ;</span><br><span class="line">int * const a ;</span><br><span class="line">int const *a const ;</span><br></pre></td></tr></table></figure></p>
<p>A7.1:<br>The first two mean the same thing, namely a is a const (read-only) integer.<br>The third means a is a pointer to a const integer (i.e., the integer isn’t modifiable, but the pointer is).<br>The fourth declares a to be a const pointer to an integer (i.e., the integer pointed to by a is modifiable, but the pointer is not).<br>The final declaration declares a to be a const pointer to a const integer (i.e., neither the integer pointed to by a, nor the pointer itself may be modified).</p>
<p>If the candidate correctly answers these questions, I’ll be impressed. Incidentally, one might wonder why I put so much emphasis on const, since it is very easy to write a correctly functioning program without ever using it. There are several reasons:</p>
<ul>
<li>The use of const conveys some very useful information to someone reading your code. In effect, declaring a parameter const tells the user about its intended usage. If you spend a lot of time cleaning up the mess left by other people, then you’ll quickly learn to appreciate this extra piece of information. (Of course, programmers that use const, rarely leave a mess for others to clean up…)</li>
<li>const has the potential for generating tighter code by giving the optimizer some additional information.</li>
<li>Code that uses const liberally is inherently protected by the compiler against inadvertent coding constructs that result in parameters being changed that should not be. In short, they tend to have fewer bugs.</li>
</ul>
<h1 id="Q8-Volatile"><a href="#Q8-Volatile" class="headerlink" title="Q8: Volatile"></a>Q8: Volatile</h1><p>What does the keyword volatile mean? Give three different examples of its use.</p>
<p>A8:<br>A volatile variable is one that can change unexpectedly. Consequently, the compiler can make no assumptions about the value of the variable. In particular, the optimizer must be careful to reload the variable every time it is used instead of holding a copy in a register. Examples of volatile variables are:</p>
<ul>
<li>Hardware registers in peripherals (e.g., status registers)</li>
<li>Non-stack variables referenced within an interrupt service routine.</li>
<li>Variables shared by multiple tasks in a multi-threaded application.</li>
</ul>
<p>If a candidate does not know the answer to this question, they aren’t hired. I consider this the most fundamental question that distinguishes between a ‘C programmer’ and an ‘embedded systems programmer’. Embedded folks deal with hardware, interrupts, RTOSes, and the like. All of these require volatile variables. Failure to understand the concept of volatile will lead to disaster. On the (dubious) assumption that the interviewee gets this question correct, I like to probe a little deeper, to see if they really understand the full significance of volatile. In particular, I’ll ask them the following:</p>
<h1 id="Q8-1-Volatile"><a href="#Q8-1-Volatile" class="headerlink" title="Q8.1: Volatile"></a>Q8.1: Volatile</h1><ul>
<li>Can a parameter be both const and volatile? Explain your answer.</li>
<li>Can a pointer be volatile? Explain your answer.</li>
<li>What is wrong with the following function?:</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">square</span> <span class="params">(<span class="keyword">volatile</span> <span class="keyword">int</span> *ptr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> *ptr * *ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>A8.1:<br>The answers are as follows:</p>
<ul>
<li>Yes. An example is a read only status register. It is volatile because it can change unexpectedly. It is const because the program should not attempt to modify it.</li>
<li>Yes. Although this is not very common. An example is when an interrupt service routine modifses a pointer to a buffer.</li>
<li>This one is wicked. The intent of the code is to return the square of the value pointed to by <code>*ptr</code>. However, since <code>*ptr</code>points to a volatile parameter, the compiler will generate code that looks something like this:</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">square</span> <span class="params">( <span class="keyword">volatile</span> <span class="keyword">int</span> *ptr )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a, b;</span><br><span class="line">    a = *ptr ;</span><br><span class="line">    b = *ptr ;</span><br><span class="line">    <span class="keyword">return</span> a * b ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Since it is possible for the value of <code>*ptr</code> to change unexpectedly, it is possible for a and b to be different. Consequently, this code could return a number that is not a square! The correct way to code this is:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">square</span> <span class="params">( <span class="keyword">volatile</span> <span class="keyword">int</span> *ptr )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    a = *ptr;</span><br><span class="line">    <span class="keyword">return</span> a * a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Q9-Bit-Manipulation"><a href="#Q9-Bit-Manipulation" class="headerlink" title="Q9: Bit Manipulation"></a>Q9: Bit Manipulation</h1><p>Embedded systems always require the user to manipulate bits in registers or variables. Given an integer variable a, write two code fragments. The first should set bit 3 of a. The second should clear bit 3 of a. In both cases, the remaining<br>bits should be unmodified.</p>
<p>A9:<br>These are the three basic responses to this question:</p>
<ul>
<li>No idea. The interviewee cannot have done any embedded systems work.</li>
<li>Use bit fields. Bit fields are right up there with trigraphs as the most braindead portion of C. Bit fields are inherently non-portable across compilers, and as such guarantee that your code is not reusable. I recently had the misfortune to look at a driver written by Infineon for one of their more complex communications chip. It used bit fields, and was completely useless because my compiler implemented the bit fields the other way around. The moral never let a non-embedded person anywhere near a real piece of hardware!</li>
<li>Use #defines and bit masks. This is a highly portable method, and is the one that should be used. My optimal solution to this problem would be:</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BIT3 (0x1&lt;&lt;3)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> a;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_bit3</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    a |= BIT3 ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear_bit3</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    a &amp;= ~BIT3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Some people prefer to define a mask, together with manifest constants for the set and clear values. This is also acceptable. The important elements that I’m looking for are the use of manifest constants, together with the <code>|=</code> and <code>&amp;=</code> constructs.</p>
<h1 id="Q10-Accessing-fixed-memory-locations"><a href="#Q10-Accessing-fixed-memory-locations" class="headerlink" title="Q10: Accessing fixed memory locations"></a>Q10: Accessing fixed memory locations</h1><p>Embedded systems are often characterized by requiring the programmer to access a specific memory location. On a certain project it is required to set an integer variable at the absolute address 0x67a9 to the value 0xaa55. The compiler is a pure ANSI compiler. Write code to accomplish this task.</p>
<p>A10:<br>This problem tests whether you know that it is legal to typecast an integer to a pointer in order to access an absolute location. The exact syntax varies depending upon one’s style. However, I would typically be looking<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// for something like this:</span></span><br><span class="line"><span class="keyword">int</span> *ptr;</span><br><span class="line">ptr = (<span class="keyword">int</span> *)<span class="number">0x67a9</span> ;</span><br><span class="line">*ptr = <span class="number">0xaa55</span> ;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A more obfuscated approach is:</span></span><br><span class="line">*(<span class="keyword">int</span> * <span class="keyword">const</span>)(<span class="number">0x67a9</span>) = <span class="number">0xaa55</span>;</span><br></pre></td></tr></table></figure></p>
<p>Even if your taste runs more to the second solution, I suggest the first solution when you are in an interview situation.</p>
<h1 id="Q11-Interrupts"><a href="#Q11-Interrupts" class="headerlink" title="Q11: Interrupts"></a>Q11: Interrupts</h1><p>Interrupts are an important part of embedded systems. Consequently, many compiler vendors offer an extension to standard C to support interrupts. Typically, this new key word is <code>__interrupt</code>. The following code uses <code>__interrupt</code> to define an interrupt service routine. Comment on the code.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">__<span class="function">interrupt <span class="keyword">double</span> <span class="title">compute_area</span><span class="params">(<span class="keyword">double</span> radius)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> ar ea = PI * radius * radius;</span><br><span class="line">    print (<span class="string">"\nArea = %f"</span>, area ) ;</span><br><span class="line">    <span class="keyword">return</span> area ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>A11:<br>This function has so much wrong with it, it’s almost tough to know where to start.</p>
<ul>
<li>Interrupt service routines cannot return a value. If you don’t understand this, then you aren’t hired.</li>
<li>ISR’s cannot be passed parameters. See first item for your employment prospects if you missed this.</li>
<li>On many processors/compilers, floating point operations are not necessarily re-entrant. In some cases one needs to stack additional registers, in other cases, one simply cannot do floating point in an ISR. Furthermore, given that a general rule of thumb is that ISRs should be short and sweet, one wonders about the wisdom of doing floating point math here.</li>
<li>In a similar vein to third point, printf() often has problems with reentrancy and performance.<br>If you missed last two points then I wouldn’t be too hard on you. Needless to say, if you got these two points, then your employment prospects are looking better and better.</li>
</ul>
<h1 id="Q12-Code-Examples"><a href="#Q12-Code-Examples" class="headerlink" title="Q12: Code Examples"></a>Q12: Code Examples</h1><p>What does the following code output and why?<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void foo (void) &#123;</span><br><span class="line">    unsigned int a = 6;</span><br><span class="line">    int b = -20;</span><br><span class="line">    (a+b &gt; 6) ? puts (&quot;&gt;6&quot;) : puts(&quot;&lt;=6&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>A12:<br>This question tests whether you understand the integer promotion rules in C an area that I find is very poorly understood by many developers. Anyway, the answer is that this outputs <code>&gt;6</code>. The reason for this is that expressions involving signed and unsigned types have all operands promoted to unsigned types. Thus <code>-20</code> becomes a very large positive integer and the expression evaluates to greater than 6. This is a very important point in embedded systems where unsigned data types should be used frequently. If you get this one wrong, then you are perilously close to not being hired.</p>
<h1 id="Q13-Code-Examples"><a href="#Q13-Code-Examples" class="headerlink" title="Q13: Code Examples"></a>Q13: Code Examples</h1><p>Comment on the following code fragment?<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unsigned int zero = 0;</span><br><span class="line">unsigned int compzero = 0xFFFF; /* 1&apos;s complement of zero */</span><br></pre></td></tr></table></figure></p>
<p>A13:<br>On machines where an int is not 16 bits, this will be incorrect. It should be coded:<br><code>unsigned int compzero = ~0;</code></p>
<p>This question really gets to whether the candidate understands the importance of word length on a computer. In my experience, good embedded programmers are critically aware of the underlying hardware and its limitations, whereas computer programmers tend to dismiss the hardware as a necessary annoyance.</p>
<p>By this stage, candidates are either completely demoralized or they are on a roll and having a good time. If it is obvious that the candidate isn’t very good, then the test is terminated at this point. However, if the candidate is doing well, then I throw in these supplemental questions. These questions are hard, and I expect that only the very best candidates will do well on them. In posing these questions, I’m looking more at the way the candidate tackles the problems, rather than the answers. Anyway, have fun…</p>
<h1 id="Q14-Dynamic-memory-allocation"><a href="#Q14-Dynamic-memory-allocation" class="headerlink" title="Q14: Dynamic memory allocation"></a>Q14: Dynamic memory allocation</h1><p>Although not as common as in non-embedded computers, embedded systems still do dynamically allocate memory from the heap. What are the problems with dynamic memory allocation in embedded systems?</p>
<p>A14:<br>Here, I expect the user to mention memory fragmentation, problems with garbage collection, variable execution time, etc. This topic has been covered extensively in ESP, mainly by Plauger. His explanations are far more insightful than anything I could offer here, so go and read those back issues! Having lulled the candidate into a sense of false security, I then offer up this tidbit: What does the following code fragment output and why?</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *ptr;</span><br><span class="line"><span class="keyword">if</span> (( ptr=(<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="number">0</span>)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Got a null pointer"</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Got a valid pointer"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>This is a fun question. I stumbled across this only recently, when a colleague of mine inadvertently passed a value of 0 to malloc, and got back a valid pointer! After doing some digging, I discovered that the result of malloc(0) is implementation defined, so that the correct answer is “it depends”. I use this to start a discussion on what the interviewee thinks is the correct thing for malloc to do. Getting the right answer here is nowhere near as important as the way you approach the problem and the rationale for your decision.</p>
<h1 id="Q15-Typedef"><a href="#Q15-Typedef" class="headerlink" title="Q15: Typedef"></a>Q15: Typedef</h1><p>Typedef is frequently used in C to declare synonyms for pre-existing data types.<br>It is also possible to use the preprocessor to do something similar. For instance,<br>consider the following code fragment:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dPS struct s *</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">s</span> * <span class="title">tPS</span>;</span></span><br></pre></td></tr></table></figure>
<p>The intent in both cases is to define dPS and tPS to be pointers to structure s. Which method (if any) is preferred and why?</p>
<p>A15:<br>This is a very subtle question, and anyone that gets it right (for the right reason) is to be congratulated or condemned (“get a life” springs to mind). The answer is the typedef is preferred. Consider the declarations:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dPS p1, p2;</span><br><span class="line">tPS p3, p4;</span><br></pre></td></tr></table></figure>
<p>The first expands to <code>struct s *p1 , p2</code> which defines p1 to be a pointer to the structure and p2 to be an actual structure, which is probably not what you wanted. The second example correctly defines p3 and p4 to be pointers.</p>
<h1 id="Q16-Obfuscated-syntax"><a href="#Q16-Obfuscated-syntax" class="headerlink" title="Q16: Obfuscated syntax"></a>Q16: Obfuscated syntax</h1><p>C allows some appalling constructs. Is this construct legal, and if so what does this code do?</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a=<span class="number">5</span>, b=<span class="number">7</span>, c;</span><br><span class="line">c = a+++b ;</span><br></pre></td></tr></table></figure>
<p>A16:<br>This question is intended to be a lighthearted end to the quiz, as, believe it or not, this is perfectly legal syntax. The question is how does the compiler treat it? Those poor compiler writers actually debated this issue, and came up with the “maximum munch” rule, which stipulates that the compiler should bite off as big a (legal) chunk as it can. Hence, this code is treated as:<br>    <code>c = a++ + b;</code></p>
<p>Thus, after this code is executed, a = 6, b = 7 and c = 12; If you knew the answer, or guessed correctly then well done. If you didn’t know the answer then I would not consider this to be a problem. I find the biggest benefit of this question is that it is very good for stimulating questions on coding styles, the value of code reviews and the benefits of using lint.</p>
<p>Well folks, there you have it. That was my version of the C test. I hope you had as much fun doing it as I had writing it. If you think the test is a good test, then by all means use it in your recruitment. Who knows, I may get lucky in a year or two and end up being on the receiving end of my own work.</p>
<h1 id="Q-What-is-NULL-pointer-and-what-is-its-use"><a href="#Q-What-is-NULL-pointer-and-what-is-its-use" class="headerlink" title="Q: What is NULL pointer and what is its use?"></a>Q: What is NULL pointer and what is its use?</h1><p>The NULL is a macro de¡ned in C. Null pointer actually means a pointer that does not point to any valid location. We de¡ne a pointer to be null when we want to make sure that the pointer does not point to any valid location and not to use that pointer to change anything. If we don’t use null pointer, then we can’t verify whether this pointer points to any valid location or not.</p>
<h1 id="Q-What-is-void-pointer-and-what-is-its-use"><a href="#Q-What-is-void-pointer-and-what-is-its-use" class="headerlink" title="Q: What is void pointer and what is its use?"></a>Q: What is void pointer and what is its use?</h1><p>The void pointer means that it points to a variable that can be of any type. Other pointers points to a speci¡c type of variable while void pointer is a somewhat generic pointer and can be pointed to any data type, be it standard data type(int, char etc) or user de¡ne data type (structure, union etc.). We can pass any kind of pointer and reference it as a void pointer. But to dereference it, we have to type the void pointer to correct data type.</p>
<h1 id="Q-What-is-ISR"><a href="#Q-What-is-ISR" class="headerlink" title="Q: What is ISR?"></a>Q: What is ISR?</h1><p>An ISR(Interrupt Service Routine) is an interrupt handler, a callback subroutine which is called when a interrupt is encountered Interrupt latency is the time required for an ISR responds to an interrupt.</p>
<h1 id="Q-What-is-interrupt-latency-How-to-reduce-interrupt-latency"><a href="#Q-What-is-interrupt-latency-How-to-reduce-interrupt-latency" class="headerlink" title="Q: What is interrupt latency? How to reduce interrupt latency?"></a>Q: What is interrupt latency? How to reduce interrupt latency?</h1><p>Interrupt latency is the time required for an ISR responds to an interrupt.<br>Interrupt latency can be minimized by writing short ISR routine and by not delaying interrupts for more time.</p>
<p>20) What is Top half &amp; bottom half of a kernel?</p>
<p>Sometimes to handle an interrupt, a substantial amount of work has to be done. But it conflicts with the speed need for an interrupt handler. To handle this situation, Linux splits the handler into two parts – Top half and Bottom half. The top half is the routine that actually responds to the interrupt. The bottom half on the other hand is a routine that is scheduled by the upper half to be executed later at a safer time.</p>
<p>All interrupts are enabled during execution of the bottom half. The top half saves the device data into the specific buffer, schedules bottom half and exits. The bottom half does the rest. This way the top half can service a new interrupt while the bottom half is working on the previous.</p>
<h1 id="Q-Can-static-variables-be-declared-in-a-header-file"><a href="#Q-Can-static-variables-be-declared-in-a-header-file" class="headerlink" title="Q: Can static variables be declared in a header file?"></a>Q: Can static variables be declared in a header file?</h1><p>A static variable cannot be declared without defining it. A static variable can be defined in the header file. But doing so, the result will be having a private copy of that variable in each source file which includes the header file. So it will be wise not to declare a static variable in header file, unless you are dealing with a different scenario.</p>
<h1 id="Q-Is-Count-Down-to-Zero-Loop-better-than-Count-Up-Loops"><a href="#Q-Is-Count-Down-to-Zero-Loop-better-than-Count-Up-Loops" class="headerlink" title="Q: Is Count Down_to_Zero Loop better than Count_Up_Loops?"></a>Q: Is Count Down_to_Zero Loop better than Count_Up_Loops?</h1><p>Count down to zero loops are better. Reason behind this is that at loop termination, comparison to zero can be optimized by the compiler. Most processors have instruction for comparing to zero. So they don’t need to load the loop variable and the maximum value, subtract them and then compare to zero. That is why count down to zero loop is better.</p>
<h1 id="Q-What-are-inline-functions-Advantages-and-disadvantages-of-using-macro-and-inline-functions"><a href="#Q-What-are-inline-functions-Advantages-and-disadvantages-of-using-macro-and-inline-functions" class="headerlink" title="Q: What are inline functions? Advantages and disadvantages of using macro and inline functions?"></a>Q: What are inline functions? Advantages and disadvantages of using macro and inline functions?</h1><p>The ARM compilers support inline functions with the keyword __inline. These functions have a small definition and the function body is substituted in each call to the inline function. The argument passing and stack maintenance is skipped and it results in faster code execution, but it increases code size, particularly if the inline function is large or one inline function is used often.</p>
<p>The advantage of the macro and inline function is that the overhead for argument passing and stuff is reduced as the function are in-lined. The advantage of macro function is that we can write type insensitive functions. It is also the disadvantage of macro function as macro functions can’t do validation check. The macro and inline function also increases the size of the executable.</p>
<h1 id="Q-What-happens-when-recursive-functions-are-declared-inline"><a href="#Q-What-happens-when-recursive-functions-are-declared-inline" class="headerlink" title="Q: What happens when recursive functions are declared inline?"></a>Q: What happens when recursive functions are declared inline?</h1><p>Inlining an recursive function reduces the overhead of saving context on stack. But, inline is merely a suggestion to the compiler and it does not guarantee that a function will be inlined. Obviously, the compiler won’t be able to inline a recursive function infinitely. It may not inline it at all or it may inline it, just a few levels deep.</p>
<h1 id="Q-Can-structures-be-passed-to-the-functions-by-value"><a href="#Q-Can-structures-be-passed-to-the-functions-by-value" class="headerlink" title="Q: Can structures be passed to the functions by value?"></a>Q: Can structures be passed to the functions by value?</h1><p>Passing structure by its value to a function is possible, but not a good programming practice. First of all, if we pass the structure by value and the function changes some of those values, then the value change is not reflected in caller function. Also, if the structure is big, then passing the structure by value means copying the whole structure to the function argument stack which can slow the program by a significant amount.</p>
<h1 id="Q-Why-cannot-arrays-be-passed-by-values-to-functions"><a href="#Q-Why-cannot-arrays-be-passed-by-values-to-functions" class="headerlink" title="Q: Why cannot arrays be passed by values to functions?"></a>Q: Why cannot arrays be passed by values to functions?</h1><p>In C, the array name itself represents the address of the first element. So, even if we pass the array name as argument, it will be passed as reference and not its address.</p>
<h1 id="Q-What-is-the-concatenation-operator"><a href="#Q-What-is-the-concatenation-operator" class="headerlink" title="Q: What is the concatenation operator?"></a>Q: What is the concatenation operator?</h1><p>The Concatenation operator (##) in macro is used to concatenate two arguments. Literally, we can say that the arguments are concatenated, but actually their value are not concatenated. Think it this way, if we pass A and B to a macro which uses ## to concatenate those two, then the result will be AB. Consider the example to clear the confusion-<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SOME_MACRO(a, b) a##b</span></span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> var = <span class="number">15</span>;</span><br><span class="line">  <span class="built_in">printf</span>(“%d”, SOME_MACRO(v, ar));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Output of the above program will be 15.</p>
<h1 id="Q-define-cat-x-y-x-y-concatenates-x-to-y-But-cat-cat-1-2-3-does-not-expand-but-gives-preprocessor-warning-Why"><a href="#Q-define-cat-x-y-x-y-concatenates-x-to-y-But-cat-cat-1-2-3-does-not-expand-but-gives-preprocessor-warning-Why" class="headerlink" title="Q: #define cat(x,y) x##y concatenates x to y. But cat(cat(1,2),3) does not expand but gives preprocessor warning. Why?"></a>Q: <code>#define cat(x,y) x##y</code> concatenates x to y. But <code>cat(cat(1,2),3)</code> does not expand but gives preprocessor warning. Why?</h1><p>The cat(x, y) expands to x##y. It just pastes x and y. But in case of cat(cat(1,2),3), it expands to cat(1,2)##3 instead of 1##2##3. That is why it is giving preprocessor warning.</p>
<h1 id="Q-How-to-decide-whether-given-processor-is-using-little-endian-format-or-big-endian-format"><a href="#Q-How-to-decide-whether-given-processor-is-using-little-endian-format-or-big-endian-format" class="headerlink" title="Q: How to decide whether given processor is using little endian format or big endian format ?"></a>Q: How to decide whether given processor is using little endian format or big endian format ?</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">check_for_endianness</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> x = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">char</span> *c = (<span class="keyword">char</span>*) &amp;x;</span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">int</span>)*c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Q-What-is-forward-reference-w-r-t-pointers-in-c"><a href="#Q-What-is-forward-reference-w-r-t-pointers-in-c" class="headerlink" title="Q: What is forward reference w.r.t. pointers in c?"></a>Q: What is forward reference w.r.t. pointers in c?</h1><p>Forward Referencing with respect to pointers is used when a pointer is declared and compiler reserves the memory for the pointer, but the variable or data type is not defined to which the pointer points to. For example<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span> *<span class="title">p</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"> <span class="comment">// members</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Q-How-can-you-define-a-structure-with-bit-field-members"><a href="#Q-How-can-you-define-a-structure-with-bit-field-members" class="headerlink" title="Q: How can you define a structure with bit field members?"></a>Q: How can you define a structure with bit field members?</h1><p>Not command use bit field in embedded system! because bit fields are inherently non-portable across compilers, and as such guarantee that your code is not reusable.<br>Bit field members can be declared as shown below<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct A</span><br><span class="line">&#123;</span><br><span class="line"> char c1 : 3;</span><br><span class="line"> char c2 : 4;</span><br><span class="line"> char c3 : 1;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>Here c1, c2 and c3 are members of a structure with width 3, 4, and 1 bit respectively. The ‘:’ indicates that they are bit fields and the following numbers indicates the width in bits.</p>
<h1 id="Q-How-do-you-write-a-function-which-takes-2-arguments-a-byte-and-a-field-in-the-byte-and-returns-the-value-of-the-field-in-that-byte"><a href="#Q-How-do-you-write-a-function-which-takes-2-arguments-a-byte-and-a-field-in-the-byte-and-returns-the-value-of-the-field-in-that-byte" class="headerlink" title="Q: How do you write a function which takes 2 arguments - a byte and a field in the byte and returns the value of the field in that byte?"></a>Q: How do you write a function which takes 2 arguments - a byte and a field in the byte and returns the value of the field in that byte?</h1><p>The function will look like this -<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetFieldValue</span><span class="params">(<span class="keyword">int</span> byte, <span class="keyword">int</span> field )</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (byte &gt;&gt; field) &amp; <span class="number">0x01</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>The byte is right shifted exactly n times where n is same as the field value. That way, our intended value ends up in the 0th bit position. “Bitwise And” with 1 can get the intended value. The function then returns the intended value.</p>
<h1 id="Q-What-is-job-of-preprocessor-compiler-assembler-and-linker"><a href="#Q-What-is-job-of-preprocessor-compiler-assembler-and-linker" class="headerlink" title="Q: What is job of preprocessor, compiler, assembler and linker ?"></a>Q: What is job of preprocessor, compiler, assembler and linker ?</h1><p>The preprocessor commands are processed and expanded by the preprocessor before actual compilation. After preprocessing, the compiler takes the output of the preprocessor and the source code, and generates assembly code. Once compiler completes its work, the assembler takes the assembly code and produces an assembly listing with offsets and generate object files.</p>
<p>The linker combines object files or libraries and produces a single executable file. It also resolves references to external symbols, assigns final addresses to functions and variables, and revises code and data to reflect new addresses.</p>
<h1 id="Q-Significance-of-watchdog-timer-in-Embedded-Systems"><a href="#Q-Significance-of-watchdog-timer-in-Embedded-Systems" class="headerlink" title="Q: Significance of watchdog timer in Embedded Systems."></a>Q: Significance of watchdog timer in Embedded Systems.</h1><p>The watchdog timer is a timing device with a predefined time interval. During that interval, some event may occur or else the device generates a time out signal. It is used to reset to the original state whenever some inappropriate events take place which can result in system malfunction. It is usually operated by counter devices.</p>
<h1 id="Q-Why-n-executes-faster-than-n-1"><a href="#Q-Why-n-executes-faster-than-n-1" class="headerlink" title="Q: Why ++n executes faster than n+1?"></a>Q: Why ++n executes faster than n+1?</h1><p>The expression ++n requires a single machine instruction such as INR to carry out the increment operation. In case of n+1, apart from INR, other instructions are required to load the value of n. That is why ++n is faster.</p>
<h1 id="Q-What-is-wild-pointer"><a href="#Q-What-is-wild-pointer" class="headerlink" title="Q: What is wild pointer?"></a>Q: What is wild pointer?</h1><p>A pointer that is not initialized to any valid address or NULL is considered as wild pointer. Consider the following code fragment -</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p;</span><br><span class="line">*p = <span class="number">20</span>;</span><br></pre></td></tr></table></figure>
<p>Here p is not initialized to any valid address and still we are trying to access the address. The p will get any garbage location and the next statement will corrupt that memory location.</p>
<h1 id="Q-What-is-dangling-pointer"><a href="#Q-What-is-dangling-pointer" class="headerlink" title="Q: What is dangling pointer?"></a>Q: What is dangling pointer?</h1><p>迷途指针, 指向的buffer已经被释放了, 但是指向它的指针依旧<br>If the memory of a pointer is de-allocated or freed and the pointer is not assigned to NULL, then it may still contain that address and accessing the pointer means that we are trying to access that location and it will give an error. This type of pointer is called dangling pointer.</p>
<h1 id="Q-Write-down-the-equivalent-pointer-expression-for-referring-the-same-element-a-i-j-k-l"><a href="#Q-Write-down-the-equivalent-pointer-expression-for-referring-the-same-element-a-i-j-k-l" class="headerlink" title="Q: Write down the equivalent pointer expression for referring the same element a[i][j][k][l] ?"></a>Q: Write down the equivalent pointer expression for referring the same element <code>a[i][j][k][l]</code> ?</h1><p>We know that <code>a[i]</code> can be written as <code>*(a+i)</code>. Same way, the array elements can be written like pointer expression as follows -<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a[i][j] == *(*(a+i)+j)</span><br><span class="line">a[i][j][k] == *(*(*(a+i)+j)+k)</span><br><span class="line">a[i][j][k][l] == *(*(*(*(a+i)+j)+k)+l)</span><br></pre></td></tr></table></figure></p>
<h1 id="Q-When-should-we-use-register-modifier"><a href="#Q-When-should-we-use-register-modifier" class="headerlink" title="Q: When should we use register modifier?"></a>Q: When should we use register modifier?</h1><p>The register modifier is used when a variable is expected to be heavily used and keeping it in the CPU’s registers will make the access faster.</p>
<h1 id="Q-Explain-what-are-the-different-storage-classes-in-C"><a href="#Q-Explain-what-are-the-different-storage-classes-in-C" class="headerlink" title="Q: Explain what are the different storage classes in C"></a>Q: Explain what are the different storage classes in C</h1><ul>
<li><code>auto</code> for local variables in RAM</li>
<li><code>register</code> for local variables in register</li>
<li><code>static</code> for local variable, keeping the value during the life-time of the program</li>
<li><code>static</code> for global variable only shared on its own file scope</li>
<li><code>extern</code> to give a reference of a global variable that is visible to ALL the program files</li>
</ul>
<hr>
<p><strong><em>转载自 <a href="http://www.emb-linux.narod.ru/interview/0x10_questions.pdf" target="_blank" rel="noopener">The 0x10 Best Questions for Would-be Embedded Programmers</a></em></strong><br><strong><em>转载自 <a href="http://a4academics.com/interview-questions/57-c-plus-plus/722-embedded-c-interview-questions?showall=&amp;limitstart=" target="_blank" rel="noopener">Embedded C Interview Questions and Answers</a></em></strong></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/04/12/1815-suspend/" itemprop="url">
                  博客暂停更新
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2018-04-12T00:00:00+10:00" content="2018-04-12">
              2018-04-12
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/thoughts/" itemprop="url" rel="index">
                    <span itemprop="name">thoughts</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h1><ul>
<li><a href="https://draapho.github.io/2017/10/09/1728-ultimatethink/">我的终极思考</a></li>
<li><a href="https://draapho.github.io/2018/04/12/1815-suspend/">博客暂停更新</a></li>
<li><a href="https://draapho.github.io/2018/07/08/1818-buddhism/">佛教学习资料及一些感想</a></li>
<li><a href="https://draapho.github.io/2018/11/29/1819-start-meditation/">实修开始</a></li>
<li><a href="https://draapho.github.io/2018/12/27/1820-meditation-LCP/">闻思修</a></li>
<li><a href="https://draapho.github.io/2019/03/19/1901-tittle-tattle/">杂谈</a></li>
<li><a href="https://draapho.github.io/2019/07/05/1908-unified/">各种【一元化思维】的谬误——从“星座理论”到“共产主义社会”</a></li>
<li><a href="https://draapho.github.io/2019/07/25/1909-TCM_science/">好吧，我们就从头聊一聊科学、中医、东西方文明及其不同思维模式的话题</a></li>
<li><a href="https://draapho.github.io/2019/07/26/1910-satori/">开悟是怎样一种体验？</a></li>
<li><a href="https://draapho.github.io/2020/04/15/2003-letthebulletsfly/">解构&lt;让子弹飞&gt;</a></li>
<li><a href="https://draapho.github.io/2021/01/28/2101-confusion/">与神对话读后感-矛盾与困惑</a></li>
<li><a href="https://draapho.github.io/2021/02/09/2102-intermittent/">一张简单图片演示的“甚深佛法”</a></li>
<li><a href="https://draapho.github.io/2021/02/13/2104-satori/">修行总领——明心见性</a></li>
</ul>
<h1 id="本博客暂停更新"><a href="#本博客暂停更新" class="headerlink" title="本博客暂停更新"></a>本博客暂停更新</h1><p>原因的话, 最大的兴趣点始终是在人文和生命本源这一块. 参考 <a href="https://draapho.github.io/2017/10/09/1728-ultimatethink/">我的终极思考</a><br>当下可能找到了一种方法, 让生活和兴趣可以两全. 我需要全力去试一试.</p>
<p>第一阶段, 独善其身:</p>
<ul>
<li>于资本汇聚之地得自由</li>
<li>于人性汇聚之地得自在</li>
<li>万物皆空, 上善若水<ul>
<li>贪嗔痴疑慢, 万物皆烦恼. 舍万物?求信仰? 终是不究竟.</li>
<li>水无所依, 可依万物. 心无所执, 可着万境.</li>
</ul>
</li>
</ul>
<p>第二阶段, 兼济天下:</p>
<ul>
<li>人文学科和生命本源数学化, 理论化.</li>
<li>已有大致思路:<ul>
<li>心为本, 物为载体, 心可改变物.</li>
<li>一切出发点是基本生命体的相互关系, 这种相互关系就是本源, 不随级别改变.</li>
<li>环境的影响首先作用于心, 心影响生命体的相互关系, 从而影响整个群体的行为和特性.</li>
</ul>
</li>
<li>主观上, 我认为佛教的世界观是正确的; 但受限于”客观”的观察要求, 要证明比较困难.<ul>
<li>所谓大千世界, 是指不同级别包含生命体的世界. 每个人, 每朵花, 每个细胞都是一世界. (分子,原子不敢确定)</li>
<li>世界就是玻璃缸, 人是没有什么”客观”的方法去观察玻璃缸外的情况的.</li>
<li>人之所以稍微特殊一点, 是因为以人为基础单位, 明显已经发展出多样的更高层次的生命体(企业, 国家等各种形态的组织)</li>
<li>更重要的, 人有潜能进行星际殖民, 从而把星球发展成为更高级的”基础细胞”.</li>
</ul>
</li>
</ul>
<p>最后, 无论成败, 先在此感谢 <a href="http://blog.sina.com.cn/u/1215172700" target="_blank" rel="noopener">缠中说禅</a> 不但指明了实用的生存方法, 更是给予了我无穷的灵感!<br>读君博文, 方觉虚度光阴30载. 愿君彼岸安好.</p>
<hr>
<p><strong><em>原创于 <a href="https://draapho.github.io/">DRA&amp;PHO</a></em></strong></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/02/09/1815-drv-i2c/" itemprop="url">
                  驱动之I2C驱动
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2018-02-09T00:00:00+11:00" content="2018-02-09">
              2018-02-09
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/embedded-linux/" itemprop="url" rel="index">
                    <span itemprop="name">embedded linux</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h1><ul>
<li><a href="https://draapho.github.io/2017/11/23/1734-linux-content/">嵌入式linux学习目录</a></li>
<li><a href="https://draapho.github.io/2018/02/09/1815-drv-i2c/">驱动之I2C驱动</a></li>
</ul>
<p>本文使用 linux-2.6.22.6 内核, 由于jz2440开发板没有板载I2C设备, 因此源码部分无法实际测试.</p>
<h1 id="I2C驱动框架分析"><a href="#I2C驱动框架分析" class="headerlink" title="I2C驱动框架分析"></a>I2C驱动框架分析</h1><p>I2C协议本身不是太复杂, 但Linux内核为了通用化, 搞了一套复杂的总线系统.</p>
<p><img src="https://draapho.github.io/images/1815/layer.png" alt="layer.png"></p>
<p><strong>最要理解i2c框架, 尝试理解 <code>i2c_add_adapter</code> 和 <code>i2c_add_driver</code> 就行了.</strong></p>
<ul>
<li><code>i2c_adapter</code> 对i2c主机的抽象概念, 与 <code>i2c_add_adapter</code> 相关<ul>
<li>这部分的架构都是已经搭好的, 由CPU厂商完成.</li>
<li>针对特定的开发板, 一般情况只会有一个 <code>i2c_adapter</code>. 会在<code>/drivers/i2c/busses</code>下选取一个</li>
<li>但特殊情况, 如果需要用不同的数据预处理方式, 如 <code>i2c-algo-bit</code>, 那么也可以抽象出多个 <code>i2c_adapter</code></li>
</ul>
</li>
<li><code>i2c_driver</code>  对i2c从机的抽象概念, 与 <code>i2c_add_driver</code> 相关<ul>
<li>Linux内核给了很多i2c芯片的驱动范例. 我们所说的开发i2c驱动, 是位于这一端的.</li>
<li>一个真实的i2c从机设备并非对应唯一的 <code>i2c_driver</code>.</li>
<li>譬如i2c芯片24cXX. 可以对APP端抽象出多种概念:<ul>
<li>linux内核为了让APP端能直接操作i2c, 通过 <code>i2c-dev.c</code> 实现了一个 <code>i2c_driver</code></li>
<li>系统里的<code>eeprom.c</code>, 帮我们实现了通用eeprom的操作. 就是另一个 <code>i2c_driver</code></li>
<li>我们自己也可以写一个驱动, 将24cXX认为是一块加密芯片. 就是第三个 <code>i2c_driver</code></li>
<li>这样, i2c从机端的底层都是一样的, 但上层的抽象概念是不同的. 或许, 这也是将主机端取名为 <code>i2c_adapter</code> 的原因, 它只是一个通讯适配器. 将APP层的不同抽象概念适配到一个个具体的i2c芯片上.</li>
</ul>
</li>
</ul>
</li>
<li><code>i2c_adapter</code> 和 <code>i2c_driver</code> 的关联方式<ul>
<li>就是 platform 总线架构, 两个链表有新加内容后, 循环查找匹配.</li>
<li>是否匹配有两个要点:<ul>
<li>一是 <code>i2c_adapter.nr</code> 和 <code>i2c_client_address_data</code> 里的设置是否一样</li>
<li>这里基本都不用这个值去匹配的. 总线驱动也没去设置 <code>i2c_adapter.nr</code>. 设备端驱动直接设置为 <code>ANY_I2C_BUS</code> 即可.</li>
<li>二是 i2c 的物理地址, 根据物理地址实际通讯一下, 来进行匹配.</li>
<li>如果用了 <code>i2c_client_address_data.force</code>, 那么物理地址的检测过程也将被忽略.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="相关文件"><a href="#相关文件" class="headerlink" title="相关文件"></a>相关文件</h2><ul>
<li><code>./drivers/i2c/i2c-core.c</code> 这个文件实现了I2C核心的功能以及/proc/bus/i2c*接口。<ul>
<li>此文件就是 <code>i2c核心层</code> 作用是承上启下:</li>
<li>对上, 提供统一的调用接口, 屏蔽硬件差异. 如提供 <code>read</code> <code>write</code> 函数.</li>
<li>对下, 抽象出i2c操作通用的部分, 简化i2c的硬件驱动开发.<br>-　<code>./drivers/i2c/busses</code> 包含了各个芯片厂商的I2C总线的驱动</li>
<li>如 <code>i2c-s3c2410.c</code> 针对S3C系列处理器的I2C控制器驱动.</li>
</ul>
</li>
<li><code>./drivers/i2c/i2c-dev.c</code> 实现了I2C适配器设备文件的功能，每一个I2C适配器都被分配一个设备.<ul>
<li>把这个文件理解为系统提供的一个i2c设备驱动程序即可. 需要手动加载.</li>
<li>此文件会调用 <code>i2c_add_driver</code>, 系统默认注册的一个i2c设备, 可供app端直接调用.</li>
<li>i2c芯片另外需要自己的驱动程序, 去调用 <code>i2c_add_driver</code>, 并注册设备.</li>
</ul>
</li>
<li><del><code>./drivers/i2c/algos</code>　文件夹实现了一些I2C总线适配器的algorithm.</del><ul>
<li>algorithm 这个词让人容易误解. 我的理解是数据预处理方式的不同.</li>
<li><code>i2c-algo-pca.c</code>. 可参考 <a href="https://www.nxp.com/docs/en/data-sheet/PCF8584.pdf" target="_blank" rel="noopener">PCF8584 I2C-bus controller</a></li>
<li><code>i2c-algo-pcf.c</code>. 可参考 <a href="https://www.nxp.com/docs/en/data-sheet/PCA9564.pdf" target="_blank" rel="noopener">PCA9564 Parallel bus to I2C-bus controller</a></li>
<li><code>i2c-algo-sgi.c</code>. 应该针对给2款早已过时的PC机用的.</li>
<li><code>I2C_ALGO_XXX</code> 的宏定义可以在 <code>./include/linux/i2c-id.h</code> 下找到</li>
</ul>
</li>
</ul>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><ul>
<li><code>struct i2c_driver</code> 提供 <code>probe</code> <code>remove</code> 等函数接口. i2c从机设备驱动使用<ul>
<li><code>i2c_add_driver</code> 函数使用. 与 <code>i2c_adapter</code> 对应, 两者需要匹配.</li>
</ul>
</li>
<li><code>struct i2c_adapter</code> 适配器. 就是将多种多样的底层I2C硬件需求(不同地址, 不同通讯方法)给一个统一的方法接入到I2C核心层.<ul>
<li>指定通讯方式(i2c_algorithm)</li>
<li>指定i2c设备(i2c_client)</li>
<li><code>i2c_add_adapter</code> 函数使用. 与 <code>i2c_driver</code> 对应, 两者需要匹配.</li>
</ul>
</li>
<li><code>struct i2c_client</code> 描述了真实设备的所有必要信息, 如 i2c addr, 设备名称, 中断号等等.<ul>
<li>除了提供给 <code>i2c_adapter</code> 外, 还直接和 <code>i2c_driver</code> 想关联.</li>
<li>原因应该是内核层和应用层都需要方便的读取真实i2c设备的必要信息</li>
</ul>
</li>
<li><code>struct i2c_algorithm</code> 通讯方法. 其中两个函数指针是由底层硬件实现的. 相当于 i2c核心层和底层的接口<ul>
<li>algorithm 这个词让人容易误解. 我的理解是数据预处理方式的不同.</li>
<li>只和 <code>i2c_adapter</code> 相关, 给i2c主机提供收发功能</li>
<li><code>.master_xfer</code> 发送函数, 需要底层实现.</li>
<li><code>struct i2c_msg</code> 用于存放通讯时的地址, 数据buf, 长度等信息</li>
<li><code>.functionality</code> 驱动支持的功能, 需要底层明确.</li>
<li>底层没有接收函数. 因为i2c通讯必须由主机发起并提供时钟, 发送的同时就会接收数据.</li>
</ul>
</li>
</ul>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p><img src="https://draapho.github.io/images/1815/function.png" alt="function.png"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// =========== 从 i2c_add_driver 看 ==========</span></span><br><span class="line">i2c_add_driver                                              <span class="comment">// I2C 设备驱动会调用, 如自己写的驱动</span></span><br><span class="line">    i2c_register_driver</span><br><span class="line">        driver-&gt;driver.bus = &amp;i2c_bus_type;</span><br><span class="line">        driver_register(&amp;driver-&gt;driver);</span><br><span class="line">        list_add_tail(&amp;driver-&gt;<span class="built_in">list</span>,&amp;drivers);              <span class="comment">// 将 i2c_driver 放到链表尾部</span></span><br><span class="line"></span><br><span class="line">        list_for_each_entry(adapter, &amp;adapters, <span class="built_in">list</span>) &#123;</span><br><span class="line">            driver-&gt;attach_adapter(adapter);                <span class="comment">// 尝试匹配 i2c_adapter</span></span><br><span class="line">            <span class="comment">// driver-&gt;attach_adapter 就会去调用驱动里指定的 attach_adapter 函数.</span></span><br><span class="line">            <span class="comment">// 一般的, 就是直接调用 i2c_probe. "i2c-dev.c" 除外, 它关联所有的 "i2c_adapter".</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">i2c_probe(adapter, &amp;addr_data, eeprom_detect);              <span class="comment">// adapter 是系统传过来的</span></span><br><span class="line">    adap_id = i2c_adapter_id(adapter)                       <span class="comment">// i2c_adapter.nr 作为判断.</span></span><br><span class="line">    <span class="comment">// 判断 address_data 里是否有 forces.类型匹配即可. 强制类型不会检查I2C从设备是否存在</span></span><br><span class="line">    <span class="keyword">if</span> (address_data-&gt;forces) &#123;</span><br><span class="line">        <span class="comment">// force里的类型与 i2c_adapter.nr 一致, 或者是 ANY_I2C_BUS</span></span><br><span class="line">        <span class="keyword">if</span> (forces[kind][i] == adap_id || forces[kind][i] == ANY_I2C_BUS) &#123;</span><br><span class="line">            i2c_probe_address();                            <span class="comment">// 调用 i2c_probe_address</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// address_data.probe 里的地址和类型不受ignore影响.</span></span><br><span class="line">    <span class="comment">// probe 的数据格式也必须是 &#123;I2C_BUS_ID, ADDR, I2C_BUS_ID, ADDR, I2C_CLIENT_END&#125;</span></span><br><span class="line">    <span class="keyword">if</span> (address_data-&gt;probe[i] == adap_id || address_data-&gt;probe[i] == ANY_I2C_BUS) &#123;</span><br><span class="line">            i2c_probe_address();                            <span class="comment">// 调用 i2c_probe_address</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// address_data.normal_i2c, 就是排除 .ignore 后, 进行 i2c_probe_address</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">i2c_probe_address                                           <span class="comment">// 发出S信号,发出设备地址(来自addr_data)</span></span><br><span class="line">    i2c_smbus_xfer</span><br><span class="line">        i2c_smbus_xfer_emulated</span><br><span class="line">            i2c_transfer</span><br><span class="line">                adap-&gt;algo-&gt;master_xfer                     <span class="comment">// 就是调用 s3c24xx_i2c_xfer</span></span><br><span class="line">    found_proc(adapter, addr, kind);</span><br><span class="line">    <span class="comment">// 回调用户设置的的 detection 函数, 告知匹配成功. 可以做一些收发数据的初始化准备.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// =========== 从 i2c_add_adapter 看 ==========</span></span><br><span class="line">i2c_add_adapter                                             <span class="comment">// I2C 总线驱动会调用, 如 "i2c-s3c2410.c"</span></span><br><span class="line">    i2c_register_adapter</span><br><span class="line">        device_register(&amp;adap-&gt;dev);                        <span class="comment">// 在 i2c-adapter 下注册 i2c-X</span></span><br><span class="line">        list_for_each(item,&amp;drivers) &#123;</span><br><span class="line">            driver = list_entry(item, struct i2c_driver, <span class="built_in">list</span>);</span><br><span class="line">            driver-&gt;attach_adapter(adap);                   <span class="comment">// 尝试匹配 i2c_adapter</span></span><br><span class="line">            <span class="comment">// driver-&gt;attach_adapter 就会去调用i2c设备驱动里指定的 attach_adapter 函数.</span></span><br><span class="line">            <span class="comment">// 后续过程和后面的 i2c_add_driver 一样, 略过不表</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关于 i2c_adapter.nr 应该是由这里的驱动在设定, 作为对接的依据之一.</span></span><br><span class="line"><span class="comment">// 但实际上, 大多数CPU厂商都没有用这个 i2c_adapter.nr 去作为 I2C_BUS 的ID. 默认值应该是0</span></span><br><span class="line"><span class="comment">// 所以最终是否能匹配就变成了根据 I2C 的地址, 实际检测一下设备是否存在...</span></span><br></pre></td></tr></table></figure>
<h1 id="编写I2C设备驱动"><a href="#编写I2C设备驱动" class="headerlink" title="编写I2C设备驱动"></a>编写I2C设备驱动</h1><p>一般的, I2C总线驱动也由芯片公司完成了.<br>因此, 当外接了某个i2c设备时, 只需要编写一下设备驱动就可以了.<br>linux内核还包含了常用的 i2c 设备如eeprom. 可以在 <code>./drivers/i2c/chips</code> 下看看.</p>
<p>核心步骤如下:</p>
<ul>
<li>分配一个i2c_driver结构体</li>
<li>设置:<pre><code>- `attach_adapter`, 它直接调用 i2c_probe (adap, 设备地址, 发现这个设备后要调用的函数)
- `detach_client`,  卸载这个驱动后,如果之前发现能够支持的设备,则调用它来清理
</code></pre></li>
<li>注册： <code>i2c_add_driver</code></li>
<li>注册为<code>字符设备</code>或其它. 如 <code>input系统</code> <code>块设备</code>, 并实现对应的操作函数.</li>
</ul>
<h2 id="at24cxx-c"><a href="#at24cxx-c" class="headerlink" title="at24cxx.c"></a>at24cxx.c</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/slab.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/jiffies.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/i2c.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/mutex.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/uaccess.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">"GPL"</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">"DRAAPHO"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">short</span> ignore[]      = &#123; I2C_CLIENT_END &#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">short</span> normal_addr[] = &#123; <span class="number">0x50</span>, I2C_CLIENT_END &#125;;     <span class="comment">// 地址值是7位</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ignore 数组范例</span></span><br><span class="line"><span class="comment">// static unsigned short ignore[]      = &#123; ANY_I2C_BUS, 0x60, I2C_CLIENT_END &#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// probe 数组范例</span></span><br><span class="line"><span class="comment">// static unsigned short probe[]       = &#123; ANY_I2C_BUS, 0x60, I2C_CLIENT_END &#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// force 数组范例</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">short</span> force_addr[] = &#123;ANY_I2C_BUS, <span class="number">0x60</span>, I2C_CLIENT_END&#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">short</span> *forces[] = &#123;force_addr, <span class="literal">NULL</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2c_client_address_data</span> <span class="title">addr_data</span> = &#123;</span></span><br><span class="line">    .normal_i2c = normal_addr,              <span class="comment">// 要发出S信号和设备地址并得到ACK信号, 才确认设备存在</span></span><br><span class="line">    .probe      = ignore,</span><br><span class="line">    .ignore     = ignore,</span><br><span class="line">    <span class="comment">// 一般不用 .forces 的. 由于jz2440没有i2c从设备, 因此这里用一下.</span></span><br><span class="line">    .forces     = forces,                   <span class="comment">// 强制认为存在这个设备</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> major;</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">class</span> *<span class="title">cls</span>;</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2c_driver</span> <span class="title">at24cxx_driver</span>;</span>    <span class="comment">// i2c_driver 结构体, 初始化在后面</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">i2c_client</span> *<span class="title">at24cxx_client</span>;</span>          <span class="comment">// i2c_client 结构体</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> ssize_t <span class="title">at24cxx_read</span><span class="params">(struct file *file, <span class="keyword">char</span> __user *buf, <span class="keyword">size_t</span> size, <span class="keyword">loff_t</span> * offset)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> address;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">i2c_msg</span> <span class="title">msg</span>[2];</span>                  <span class="comment">// i2c_msg 结构体</span></span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size != <span class="number">1</span>)                          <span class="comment">// 只接受1个参数, 表地址.</span></span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    copy_from_user(&amp;address, buf, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读AT24CXX时,要先把要读的存储空间的地址发给它</span></span><br><span class="line">    msg[<span class="number">0</span>].addr  = at24cxx_client-&gt;addr;    <span class="comment">// 目的</span></span><br><span class="line">    msg[<span class="number">0</span>].buf   = &amp;address;                <span class="comment">// 源</span></span><br><span class="line">    msg[<span class="number">0</span>].len   = <span class="number">1</span>;                       <span class="comment">// 地址=1 byte</span></span><br><span class="line">    msg[<span class="number">0</span>].flags = <span class="number">0</span>;                       <span class="comment">// 表示写</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 然后启动读操作</span></span><br><span class="line">    msg[<span class="number">1</span>].addr  = at24cxx_client-&gt;addr;    <span class="comment">// 源</span></span><br><span class="line">    msg[<span class="number">1</span>].buf   = &amp;data;                   <span class="comment">// 目的</span></span><br><span class="line">    msg[<span class="number">1</span>].len   = <span class="number">1</span>;                       <span class="comment">// 数据=1 byte</span></span><br><span class="line">    msg[<span class="number">1</span>].flags = I2C_M_RD;                <span class="comment">// 表示读</span></span><br><span class="line"></span><br><span class="line">    ret = i2c_transfer(at24cxx_client-&gt;adapter, msg, <span class="number">2</span>);    <span class="comment">// 发送+接受</span></span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">2</span>) &#123;</span><br><span class="line">        copy_to_user(buf, &amp;data, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> -EIO;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> ssize_t <span class="title">at24cxx_write</span><span class="params">(struct file *file, <span class="keyword">const</span> <span class="keyword">char</span> __user *buf, <span class="keyword">size_t</span> size, <span class="keyword">loff_t</span> *offset)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> val[<span class="number">2</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">i2c_msg</span> <span class="title">msg</span>[1];</span></span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size != <span class="number">2</span>)                          <span class="comment">// 只接受2个参数, 表地址和数据.</span></span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    copy_from_user(val, buf, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    msg[<span class="number">0</span>].addr  = at24cxx_client-&gt;addr;    <span class="comment">// 目的</span></span><br><span class="line">    msg[<span class="number">0</span>].buf   = val;                     <span class="comment">// 源</span></span><br><span class="line">    msg[<span class="number">0</span>].len   = <span class="number">2</span>;                       <span class="comment">// 地址+数据=2 byte</span></span><br><span class="line">    msg[<span class="number">0</span>].flags = <span class="number">0</span>;                       <span class="comment">// 表示写</span></span><br><span class="line"></span><br><span class="line">    ret = i2c_transfer(at24cxx_client-&gt;adapter, msg, <span class="number">1</span>);    <span class="comment">// 发送</span></span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> -EIO;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">at24cxx_fops</span> = &#123;</span></span><br><span class="line">    .owner = THIS_MODULE,</span><br><span class="line">    .read  = at24cxx_read,</span><br><span class="line">    .write = at24cxx_write,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">at24cxx_detect</span><span class="params">(struct i2c_adapter *adapter, <span class="keyword">int</span> address, <span class="keyword">int</span> kind)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    printk(<span class="string">"at24cxx_detect\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一个i2c_client结构体: 收发数据时会用到它</span></span><br><span class="line">    at24cxx_client = kzalloc(<span class="keyword">sizeof</span>(struct i2c_client), GFP_KERNEL);</span><br><span class="line">    at24cxx_client-&gt;addr    = address;</span><br><span class="line">    at24cxx_client-&gt;adapter = adapter;</span><br><span class="line">    at24cxx_client-&gt;driver  = &amp;at24cxx_driver;</span><br><span class="line">    <span class="built_in">strcpy</span>(at24cxx_client-&gt;name, <span class="string">"at24cxx"</span>);</span><br><span class="line">    i2c_attach_client(at24cxx_client);      <span class="comment">// 关联到 i2c_driver 和 i2c_adapter</span></span><br><span class="line"></span><br><span class="line">    major = register_chrdev(<span class="number">0</span>, <span class="string">"at24cxx"</span>, &amp;at24cxx_fops);</span><br><span class="line"></span><br><span class="line">    cls = class_create(THIS_MODULE, <span class="string">"at24cxx"</span>);</span><br><span class="line">    class_device_create(cls, <span class="literal">NULL</span>, MKDEV(major, <span class="number">0</span>), <span class="literal">NULL</span>, <span class="string">"at24cxx"</span>);           <span class="comment">// /dev/at24cxx</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">at24cxx_attach</span><span class="params">(struct i2c_adapter *adapter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 主动调用 probe 函数, 符合要求后, 会调用 at24cxx_detect</span></span><br><span class="line">    <span class="keyword">return</span> i2c_probe(adapter, &amp;addr_data, at24cxx_detect);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">at24cxx_detach</span><span class="params">(struct i2c_client *client)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    printk(<span class="string">"at24cxx_detach\n"</span>);</span><br><span class="line">    class_device_destroy(cls, MKDEV(major, <span class="number">0</span>));</span><br><span class="line">    class_destroy(cls);</span><br><span class="line">    unregister_chrdev(major, <span class="string">"at24cxx"</span>);</span><br><span class="line"></span><br><span class="line">    i2c_detach_client(client);</span><br><span class="line">    kfree(i2c_get_clientdata(client));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2c_driver</span> <span class="title">at24cxx_driver</span> = &#123;</span> <span class="comment">// i2c_driver 结构体</span></span><br><span class="line">    .driver = &#123;</span><br><span class="line">        .name   = <span class="string">"at24cxx"</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    .attach_adapter = at24cxx_attach,</span><br><span class="line">    .detach_client  = at24cxx_detach,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">at24cxx_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    i2c_add_driver(&amp;at24cxx_driver);        <span class="comment">// i2c_add_driver, 会自动去匹配 i2c_add_adapter</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">at24cxx_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    i2c_del_driver(&amp;at24cxx_driver);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(at24cxx_init);</span><br><span class="line">module_exit(at24cxx_exit);</span><br></pre></td></tr></table></figure>
<h2 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h2><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">TEST_FILE   := i2c_test</span><br><span class="line"></span><br><span class="line">obj-m       := at24cxx.o</span><br><span class="line">KERN_SRC    := /home/draapho/share/jz2440/kernel/linux-2.6.22.6/</span><br><span class="line">PWD         := <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"></span><br><span class="line"><span class="section">modules:</span></span><br><span class="line">    make -C <span class="variable">$(KERN_SRC)</span> M=<span class="variable">$(PWD)</span> modules</span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    make -C <span class="variable">$(KERN_SRC)</span> M=<span class="variable">$(PWD)</span> clean</span><br><span class="line">    rm -f <span class="variable">$(TEST_FILE)</span></span><br><span class="line"></span><br><span class="line"><span class="section">test:</span></span><br><span class="line">    arm-linux-gcc <span class="variable">$(TEST_FILE)</span>.c -o <span class="variable">$(TEST_FILE)</span></span><br></pre></td></tr></table></figure>
<h2 id="i2c-test-c"><a href="#i2c-test-c" class="headerlink" title="i2c_test.c"></a>i2c_test.c</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* i2c_test r addr</span></span><br><span class="line"><span class="comment"> * i2c_test w addr val</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_usage</span><span class="params">(<span class="keyword">char</span> *file)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s r addr\n"</span>, file);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s w addr val\n"</span>, file);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> buf[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((argc != <span class="number">3</span>) &amp;&amp; (argc != <span class="number">4</span>)) &#123;</span><br><span class="line">        print_usage(argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fd = open(<span class="string">"/dev/at24cxx"</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"can't open /dev/at24cxx\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">"r"</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        buf[<span class="number">0</span>] = strtoul(argv[<span class="number">2</span>], <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">        read(fd, buf, <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"data: %c, %d, 0x%2x\n"</span>, buf[<span class="number">0</span>], buf[<span class="number">0</span>], buf[<span class="number">0</span>]);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">"w"</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        buf[<span class="number">0</span>] = strtoul(argv[<span class="number">2</span>], <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">        buf[<span class="number">1</span>] = strtoul(argv[<span class="number">3</span>], <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">        write(fd, buf, <span class="number">2</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        print_usage(argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Ubuntu 主机端</span></span><br><span class="line"><span class="comment"># pwd = ~/share/jz2440/drivers/i2c/             # i2c驱动目录</span></span><br><span class="line">$ make modules</span><br><span class="line">$ make <span class="built_in">test</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 开发板端, 开始测试</span></span><br><span class="line">$ cat /proc/devices                             <span class="comment"># 注册的驱动, 如调用 "register_chrdev"</span></span><br><span class="line">$ ls /sys/class/                                <span class="comment"># 注册的类, 如调用 "class_create"</span></span><br><span class="line">i2c-adapter                                     <span class="comment"># 由 i2c-core.c 生成</span></span><br><span class="line"><span class="comment"># 里面有个 i2c-0 设备, 是i2c主机端概念,</span></span><br><span class="line"><span class="comment"># 由 i2c_add_adapter 生成. 就是 s3c2440-i2c.</span></span><br><span class="line"></span><br><span class="line">$ ls /sys/class/class_name                      <span class="comment"># 注册的设备, 如调用 "device_create"</span></span><br><span class="line">$ ls /dev/                                      <span class="comment"># mdev根据注册的设备, 使用mknod生成的设备节点</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># pwd = ~/share/jz2440//kernel/linux-2.6.22.6/drivers/i2c   # i2c驱动目录, nfs</span></span><br><span class="line">$ insmod i2c-dev.ko                             <span class="comment"># 加载系统自带的i2c</span></span><br><span class="line"><span class="comment"># 源码里会调用 i2c_add_driver 表示一个从机设备, 供APP端直接操作此i2c设备</span></span><br><span class="line"></span><br><span class="line">$ cat /proc/devices</span><br><span class="line"> 89 i2c                                         <span class="comment"># 固定的主设备号89, i2c 从设备</span></span><br><span class="line">$ ls /sys/class/</span><br><span class="line">i2c-dev                                         <span class="comment"># 找到了 i2c-dev 类</span></span><br><span class="line">$ ls /sys/class/i2c-dev</span><br><span class="line">i2c-0                                           <span class="comment"># 这个i2c0是从机端概念, 由 i2c_add_driver 生成</span></span><br><span class="line"><span class="comment"># ls /dev/i2c*</span></span><br><span class="line">/dev/i2c-0                                      <span class="comment"># 是 i2c-dev 的 i2c-0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 继续做实验</span></span><br><span class="line"><span class="comment"># pwd = ~/share/jz2440/drivers/i2c/             # i2c驱动目录, nfs</span></span><br><span class="line">$ insmod at24cxx.ko                             <span class="comment"># 加载驱动</span></span><br><span class="line">at24cxx_detect                                  <span class="comment"># 使用的强制加载, 因此没有外设也说检测到了</span></span><br><span class="line"></span><br><span class="line">$ cat /proc/devices</span><br><span class="line"> 89 i2c                                         <span class="comment"># APP可以通过这里操作i2c底层</span></span><br><span class="line">252 at24cxx                                     <span class="comment"># APP可以通过这里认为只是在读写eeprom, 虽然底层实现是i2c通讯</span></span><br><span class="line">$ ls /sys/class/</span><br><span class="line">at24cxx                                         <span class="comment"># 由自己的i2c驱动代码生成, 与 i2c_add_driver 相关</span></span><br><span class="line">i2c-adapter                                     <span class="comment"># 由 i2c-core 生成, 与 i2c_add_adapter 相关</span></span><br><span class="line">i2c-dev                                         <span class="comment"># 由 i2c-dev 生成, 与 i2c_add_driver 相关</span></span><br><span class="line">$ ls /dev/at* /dev/i2c*</span><br><span class="line">/dev/at24cxx  /dev/i2c-0                        <span class="comment"># 两个设备节点.</span></span><br><span class="line"><span class="comment"># i2c-adapter 是不会出现在这里的. 因为只会对i2c从机进行读写操作, 是不会对i2c主机做什么操作的.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># at24c芯片操作.</span></span><br><span class="line"><span class="comment"># pwd = ~/share/jz2440/drivers/i2c/             # i2c驱动目录, nfs</span></span><br><span class="line">$ ./i2c_test r 0</span><br><span class="line">$ ./i2c_test w 0 0x59</span><br><span class="line">$ ./i2c_test r 0                                <span class="comment"># 回读应该也是 0x59 才对.</span></span><br><span class="line"><span class="comment"># 断电后再读也应该是0x59. eeprom是非易失性存储器</span></span><br><span class="line"><span class="comment"># 对jz2440肯定是失败的, 因为没有这个外设.</span></span><br></pre></td></tr></table></figure>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="http://www.cnblogs.com/lcw/p/3297889.html" target="_blank" rel="noopener">【驱动】linux下I2C驱动架构全面分析</a></li>
<li><a href="http://blog.csdn.net/hanmengaidudu/article/details/10159787" target="_blank" rel="noopener">用户空间使用i2c-dev.c</a></li>
</ul>
<hr>
<p><strong><em>原创于 <a href="https://draapho.github.io/">DRA&amp;PHO</a></em></strong></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/02/08/1814-drv-rtc/" itemprop="url">
                  驱动之RTC分析
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2018-02-08T00:00:00+11:00" content="2018-02-08">
              2018-02-08
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/embedded-linux/" itemprop="url" rel="index">
                    <span itemprop="name">embedded linux</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h1><ul>
<li><a href="https://draapho.github.io/2017/11/23/1734-linux-content/">嵌入式linux学习目录</a></li>
<li><a href="https://draapho.github.io/2018/01/05/1802-drv-input/">驱动之input子系统</a></li>
<li><a href="https://draapho.github.io/2018/01/08/1803-drv-platform/">驱动之platform概念</a></li>
<li><a href="https://draapho.github.io/2018/02/08/1814-drv-rtc/">驱动之RTC分析</a></li>
<li><a href="https://draapho.github.io/2018/01/09/1804-drv-lcd/">驱动之LCD驱动框架和实现</a></li>
<li><a href="https://draapho.github.io/2018/01/11/1806-drv-ts/">驱动之触摸屏驱动框架和实现</a></li>
<li><a href="https://draapho.github.io/2018/01/18/1807-drv-usb1/">驱动之USB基础概念和框架</a></li>
<li><a href="https://draapho.github.io/2018/01/19/1808-drv-usb2/">驱动之USB设备驱动程序</a></li>
</ul>
<p>本文使用 linux-2.6.22.6 内核, 使用jz2440开发板.</p>
<h1 id="字符设备驱动另一种写法"><a href="#字符设备驱动另一种写法" class="headerlink" title="字符设备驱动另一种写法"></a>字符设备驱动另一种写法</h1><p>在 <a href="https://draapho.github.io/2017/11/22/1733-drv-chr1/">驱动之字符设备-框架</a> 里, 使用的是函数 <code>register_chrdev</code> 进行注册的.<br>其缺点是, 默认调用了 <code>__register_chrdev_region(major, 0, 256, name);</code>, 也就是会把256个次设备号全部注册掉.<br>为了合理使用次设备号, 就需要另外一种写法.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> major;                               <span class="comment">// 确定主设备号</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">hello_fops</span> = &#123;</span>    <span class="comment">// fop数据结构</span></span><br><span class="line">    .owner = THIS_MODULE,</span><br><span class="line">    .open = hello_open,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __init hello_init(<span class="keyword">void</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主设备号已知, 用 register_chrdev_region 即可</span></span><br><span class="line">    <span class="comment">// devid = MKDEV(major, 0);</span></span><br><span class="line">    <span class="comment">// register_chrdev_region(devid, HELLO_CNT, "hello");</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主设备号需要系统分配, 用 alloc_chrdev_region 函数</span></span><br><span class="line">    alloc_chrdev_region(&amp;devid, <span class="number">0</span>, HELLO_CNT, <span class="string">"hello"</span>);</span><br><span class="line">    major = MAJOR(devid);                       <span class="comment">// 提取主设备号</span></span><br><span class="line"></span><br><span class="line">    cls = class_create(THIS_MODULE, <span class="string">"hello"</span>);   <span class="comment">// 创建类</span></span><br><span class="line">    cdev_init(&amp;hello_cdev, &amp;hello_fops);        <span class="comment">// 初始化</span></span><br><span class="line">    cdev_add(&amp;hello_cdev, devid, HELLO_CNT);    <span class="comment">// 添加指定个数的字符设备</span></span><br><span class="line">    device_create(cls , <span class="literal">NULL</span> , MKDEV(major, <span class="number">0</span>), <span class="string">"hello0"</span>);  <span class="comment">// 和 class_device_create 没有本质区别.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>本质上, 就是自己实现一遍 <code>register_chrdev</code> 函数里的内容, 来控制子设备号个数.<br>博客里 <a href="https://draapho.github.io/2017/11/30/1740-drv-chr2/">驱动之基于LinK+设计按键驱动</a> 这些内容都是由 <code>LinK+</code> 自动实现的.</p>
<h1 id="RTC源码分析"><a href="#RTC源码分析" class="headerlink" title="RTC源码分析"></a>RTC源码分析</h1><p>这里以RTC源码为例进行分析, 用于熟悉字符设备的写法和分离分层即platform的概念</p>
<p><code>/drivers/rtc/rtc-dev.c</code> 提供了所有的RTC驱动层读写函数.<br>里面进一步调用了 <code>/drivers/rtc/class.c</code> 的一些函数.<br>这两个文件是linux内核RTC驱动设备的软件抽象核心.</p>
<p>显然的, 后面的很多文件是芯片厂商提供的硬件相关的RTC部分. 譬如 <code>rtc-s3c.c</code>.<br>也可以通过分析 <code>rtc-dev.c</code> 里的 <code>rtc_dev_add_device</code> 倒过来找到这些文件.</p>
<p>下面, 我们从底层硬件(<code>rtc-s3c.c</code>)往上层进行分析, 看看rtc字符设备的整个注册过程.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// subsys_initcall(rtc_init), 系统初始化时调用</span></span><br><span class="line">rtc_init();                                         <span class="comment">// 此函数位于 "class.c"</span></span><br><span class="line">    class_create(THIS_MODULE, <span class="string">"rtc"</span>);               <span class="comment">// =====&gt; class_create</span></span><br><span class="line">    rtc_dev_init();</span><br><span class="line">        alloc_chrdev_region();                      <span class="comment">// =====&gt; alloc_chrdev_region, 分配 RTC_DEV_MAX 个子设备号</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// module_init(s3c_rtc_init), 驱动入口函数. insmod 时被调用</span></span><br><span class="line">s3c_rtc_init();                                     <span class="comment">// 此函数位于 "rtc-s3c.c"</span></span><br><span class="line">    platform_driver_register(&amp;s3c2410_rtcdrv);</span><br><span class="line">    <span class="comment">// 明显用了platform框架, 根据 .name = "s3c2410-rtc" 去找 platform_device_register</span></span><br><span class="line">    <span class="comment">// 在 "/arch/arm/plat-s3c24xx/devs.c" 下找到了 s3c_device_rtc. 但没有被内核调用. 后面再说.</span></span><br><span class="line">s3c_rtc_probe();                                    <span class="comment">// platform 的 driver 和 device 匹配后, 自动调用 probe</span></span><br><span class="line">    <span class="comment">// 一系列的RTC硬件相关操作, 忽略</span></span><br><span class="line">    rtc_device_register();                          <span class="comment">// 此函数位于 "class.c"</span></span><br><span class="line">        rtc_dev_prepare();                          <span class="comment">// 此函数位于 "rtc-dev.c"</span></span><br><span class="line">            rtc-&gt;dev.devt = MKDEV(MAJOR(rtc_devt), rtc-&gt;id);</span><br><span class="line">            cdev_init();                            <span class="comment">// =====&gt; cdev_init</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// device_create 里最终调用的就是 device_register.</span></span><br><span class="line">        <span class="comment">// rtc-&gt;dev.devt 的值已经在 rtc_dev_prepare 设置好了.</span></span><br><span class="line">        device_register();                          <span class="comment">// =====&gt; 等效于 device_create.</span></span><br><span class="line">        rtc_dev_add_device();</span><br><span class="line">            cdev_add();                             <span class="comment">// =====&gt; cdev_add</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这两个函数似乎也和设备注册相关. 详请不明</span></span><br><span class="line">        rtc_sysfs_add_device();</span><br><span class="line">        rtc_proc_add_device();</span><br></pre></td></tr></table></figure>
<h1 id="RTC-测试"><a href="#RTC-测试" class="headerlink" title="RTC 测试"></a>RTC 测试</h1><p>前面的分析源码说过, <code>s3c_device_rtc</code> 没有被调用, 因此当前的系统也无法使用rtc.<br>这里就加入rtc功能, 并测试.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Ubuntu 主机端</span></span><br><span class="line"><span class="comment"># pwd = ./linux-2.6.22.6</span></span><br><span class="line"><span class="comment"># 打开 ./arch/arm/plat-s3c24xx/common-smdk.c</span></span><br><span class="line">    <span class="comment"># 找到数组 static struct platform_device __initdata *smdk_devs[]</span></span><br><span class="line">    <span class="comment"># 加入一行   &amp;s3c_device_rtc,</span></span><br><span class="line">    <span class="comment"># 此数组会被 "smdk_machine_init" 调用, 里面有 "platform_add_devices",</span></span><br><span class="line">    <span class="comment"># 此函数会对数组里的内容依次进行 "platform_device_register"</span></span><br><span class="line"></span><br><span class="line">$ make clean                                    <span class="comment"># 没把握的话, clean一下</span></span><br><span class="line">$ make uImage</span><br><span class="line"><span class="comment"># 烧录新的uImage</span></span><br><span class="line"><span class="comment"># 重启开发板进入uboot烧录界面, 按k准备烧录内核. 略过不表</span></span><br><span class="line">$ sudo dnw ./arch/arm/boot/uImage</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开发板端, 开始测试</span></span><br><span class="line">$ ls /dev/rtc* -l                               <span class="comment"># 查看设备, 有 rtc0</span></span><br><span class="line">$ date                                          <span class="comment"># 显示系统时间</span></span><br><span class="line">Mon Apr  3 06:53:50 UTC 2006</span><br><span class="line"></span><br><span class="line">$ date 020811002018.30                          <span class="comment"># 设置系统时间 date [MMDDhhmm[[CC]YY][.ss]]</span></span><br><span class="line">Thu Feb  8 11:00:30 UTC 2018</span><br><span class="line">$ hwclock -w                                    <span class="comment"># 把系统时间写入RTC. HardWare CLOCK</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 断电, 重启.</span></span><br><span class="line">$ date</span><br><span class="line">Thu Feb  8 11:02:01 UTC 2018                    <span class="comment"># 设置的时间还在.</span></span><br></pre></td></tr></table></figure>
<hr>
<p><strong><em>原创于 <a href="https://draapho.github.io/">DRA&amp;PHO</a></em></strong></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/18/">18</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="//schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.jpg"
               alt="draapho" />
          <p class="site-author-name" itemprop="name">draapho</p>
          <p class="site-description motion-element" itemprop="description">Embedded System, IoT, M2M</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">121</span>
              <span class="site-state-item-name">posts</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">14</span>
                <span class="site-state-item-name">categories</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">82</span>
                <span class="site-state-item-name">tags</span>
              
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://au.linkedin.com/in/kim-huanqing-yu-67424638" target="_blank" title="Linkedin">
                  
                    <i class="fa fa-fw fa-linkedin-square"></i>
                  
                  Linkedin
                </a>
              </span>
            
          
        </div>

        
        

        
        

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">draapho</span>
</div>

<div class="powered-by">
  Powered by <a class="theme-link" href="https://hexo.io">Hexo</a>
</div>

<div class="theme-info">
  Theme -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.2"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.2"></script>



  



  




  
  
  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length == 0) {
       search_path = "search.xml";
    }
    var path = "/" + search_path;
    // monitor main search box;

    function proceedsearch() {
      $("body").append('<div class="popoverlay">').css('overflow', 'hidden');
      $('.popup').toggle();

    }
    // search function;
    var searchFunc = function(path, search_id, content_id) {
    'use strict';
    $.ajax({
        url: path,
        dataType: "xml",
        async: true,
        success: function( xmlResponse ) {
            // get the contents from search data
            isfetched = true;
            $('.popup').detach().appendTo('.header-inner');
            var datas = $( "entry", xmlResponse ).map(function() {
                return {
                    title: $( "title", this ).text(),
                    content: $("content",this).text(),
                    url: $( "url" , this).text()
                };
            }).get();
            var $input = document.getElementById(search_id);
            var $resultContent = document.getElementById(content_id);
            $input.addEventListener('input', function(){
                var matchcounts = 0;
                var str='<ul class=\"search-result-list\">';
                var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                $resultContent.innerHTML = "";
                if (this.value.trim().length > 1) {
                // perform local searching
                datas.forEach(function(data) {
                    var isMatch = false;
                    var content_index = [];
                    var data_title = data.title.trim().toLowerCase();
                    var data_content = data.content.trim().replace(/<[^>]+>/g,"").toLowerCase();
                    var data_url = decodeURIComponent(data.url);
                    var index_title = -1;
                    var index_content = -1;
                    var first_occur = -1;
                    // only match artiles with not empty titles and contents
                    if(data_title != '') {
                        keywords.forEach(function(keyword, i) {
                            index_title = data_title.indexOf(keyword);
                            index_content = data_content.indexOf(keyword);
                            if( index_title >= 0 || index_content >= 0 ){
                                isMatch = true;
								if (i == 0) {
                                    first_occur = index_content;
                                }
                            } 
							
                        });
                    }
                    // show search results
                    if (isMatch) {
                        matchcounts += 1;
                        str += "<li><a href='"+ data_url +"' class='search-result-title'>"+ data_title +"</a>";
                        var content = data.content.trim().replace(/<[^>]+>/g,"");
                        if (first_occur >= 0) {
                            // cut out 100 characters
                            var start = first_occur - 20;
                            var end = first_occur + 80;
                            if(start < 0){
                                start = 0;
                            }
                            if(start == 0){
                                end = 50;
                            }
                            if(end > content.length){
                                end = content.length;
                            }
                            var match_content = content.substring(start, end);
                            // highlight all keywords
                            keywords.forEach(function(keyword){
                                var regS = new RegExp(keyword, "gi");
                                match_content = match_content.replace(regS, "<b class=\"search-keyword\">"+keyword+"</b>");
                            });

                            str += "<p class=\"search-result\">" + match_content +"...</p>"
                        }
                        str += "</li>";
                    }
                })};
                str += "</ul>";
                if (matchcounts == 0) { str = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>' }
                if (keywords == "") { str = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>' }
                $resultContent.innerHTML = str;
            });
            proceedsearch();
        }
    });}

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched == false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };

    });

    $('.popup-btn-close').click(function(e){
      $('.popup').hide();
      $(".popoverlay").remove();
      $('body').css('overflow', '');
    });
    $('.popup').click(function(e){
      e.stopPropagation();
    });
  </script>


  

  

  

  


</body>
</html>
