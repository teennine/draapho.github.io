<!doctype html>




<html class="theme-next mist">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.2" />






<meta name="description" content="Embedded System, IoT, M2M">
<meta property="og:type" content="website">
<meta property="og:title" content="DRA&amp;PHO">
<meta property="og:url" content="https://draapho.github.io/page/10/index.html">
<meta property="og:site_name" content="DRA&amp;PHO">
<meta property="og:description" content="Embedded System, IoT, M2M">
<meta property="og:locale" content="en">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="DRA&amp;PHO">
<meta name="twitter:description" content="Embedded System, IoT, M2M">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: false,
    duoshuo: {
      userId: '0',
      author: 'Author'
    }
  };
</script>




  <link rel="canonical" href="https://draapho.github.io/page/10/"/>


  <title> DRA&PHO </title>
</head>

<body itemscope itemtype="//schema.org/WebPage" lang="en">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="//schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">DRA&PHO</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">thinking & logging</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            Categories
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            Search
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup">
 <span class="search-icon fa fa-search"></span>
 <input type="text" id="local-search-input">
 <div id="local-search-result"></div>
 <span class="popup-btn-close">close</span>
</div>


    </div>
  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/08/30/1721-uboot-modify/" itemprop="url">
                  uboot之定制指令
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2017-08-30T00:00:00+10:00" content="2017-08-30">
              2017-08-30
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/embedded-linux/" itemprop="url" rel="index">
                    <span itemprop="name">embedded linux</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h1><ul>
<li><a href="https://draapho.github.io/2017/11/23/1734-linux-content/">嵌入式linux学习目录</a></li>
<li><a href="https://draapho.github.io/2017/11/24/1735-jz2440-basic/">jz2440分区及启动的基础概念</a></li>
<li><a href="https://draapho.github.io/2017/07/07/1719-uboot-makefile/">uboot之makefile分析</a></li>
<li><a href="https://draapho.github.io/2017/08/25/1720-uboot-source/">uboot之源码分析</a></li>
<li><a href="https://draapho.github.io/2017/08/30/1721-uboot-modify/">uboot之定制指令</a></li>
</ul>
<p>本文基于 u-boot-1.1.6, 使用jz2440开发板. 若要使用最新的u-boot版本见: <a href="http://www.denx.de/wiki/U-Boot/WebHome" target="_blank" rel="noopener">u-boot官网</a>  <a href="ftp://ftp.denx.de/pub/u-boot/" target="_blank" rel="noopener">u-boot下载</a></p>
<h1 id="hello-world"><a href="#hello-world" class="headerlink" title="hello world"></a>hello world</h1><ol>
<li>新建文件 <code>./common/cmd_hello.c</code>, 按照其他 cmd_XXX 文件内容, 依样画葫芦即可.</li>
<li>打开文件 <code>./common/Makefile</code>, 在 <code>COBJS = ...</code> 一行, 加入 <code>cmd_hello.o</code> 即可.</li>
<li>Linux主机下, <code>make</code> 指令重新编译 u-boot, 并生成 <code>u-boot.bin</code> 文件</li>
<li>烧录并执行, 测试新指令即可, 譬如在uboot命令行下, 输入 <code>hello DRA&amp;PHO</code>.</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;common.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;command.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">do_hello</span> <span class="params">(<span class="keyword">cmd_tbl_t</span> *cmdtp, <span class="keyword">int</span> flag, <span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">"hello world!, %d\n"</span>, argc);</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;argc; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"argv[%d]: %s\n"</span>, i, argv[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">U_BOOT_CMD(</span><br><span class="line">    hello,  CFG_MAXARGS,    <span class="number">1</span>,  do_hello,</span><br><span class="line">    <span class="string">"hello   - print hello world and arguments\n"</span>,</span><br><span class="line">    <span class="string">"[arg [arg ...]]\n    - print hello and arguments\n"</span></span><br><span class="line">    <span class="string">"\ttest purpose, learn to write uboot command\n"</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><p>我们用倒推法, 从关键的 <code>U_BOOT_CMD</code> 宏定义开始分析.<br>找到其宏定义所在的文件 <code>./include/command.h</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">39</span>  <span class="class"><span class="keyword">struct</span> <span class="title">cmd_tbl_s</span> &#123;</span></span><br><span class="line"><span class="number">40</span>      <span class="keyword">char</span>        *name;      <span class="comment">/* Command Name         */</span>          <span class="comment">// 指令名称</span></span><br><span class="line"><span class="number">41</span>      <span class="keyword">int</span>     maxargs;    <span class="comment">/* maximum number of arguments  */</span>      <span class="comment">// 参数最大数量</span></span><br><span class="line"><span class="number">42</span>      <span class="keyword">int</span>     repeatable; <span class="comment">/* autorepeat allowed?      */</span>          <span class="comment">// 空格键是否可自动重复指令</span></span><br><span class="line"><span class="number">44</span>      <span class="keyword">int</span>     (*cmd)(struct cmd_tbl_s *, <span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">char</span> *[]);     <span class="comment">// 指令函数</span></span><br><span class="line"><span class="number">45</span>      <span class="keyword">char</span>        *usage;     <span class="comment">/* Usage message    (short) */</span>      <span class="comment">// 短帮助说明</span></span><br><span class="line"><span class="number">47</span>      <span class="keyword">char</span>        *help;      <span class="comment">/* Help  message    (long)  */</span>      <span class="comment">// 长帮助说明</span></span><br><span class="line"><span class="number">53</span>  &#125;;</span><br><span class="line"><span class="number">55</span>  <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">cmd_tbl_s</span>    <span class="title">cmd_tbl_t</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="number">57</span>  <span class="keyword">extern</span> <span class="keyword">cmd_tbl_t</span>  __u_boot_cmd_start;</span><br><span class="line"><span class="number">58</span>  <span class="keyword">extern</span> <span class="keyword">cmd_tbl_t</span>  __u_boot_cmd_end;</span><br><span class="line">    <span class="comment">// 这两个变量不存在与任何的C或者汇编文件中, 其来源于 "./board/100ask24x0/u-boot.lds" 链接脚本里面</span></span><br><span class="line"></span><br><span class="line"><span class="number">93</span>  <span class="meta">#<span class="meta-keyword">define</span> Struct_Section  __attribute__ ((unused,section (<span class="meta-string">".u_boot_cmd"</span>)))</span></span><br><span class="line">    <span class="comment">// 指定变量存放的段位置, 由链接脚本决定.</span></span><br><span class="line"></span><br><span class="line"><span class="number">97</span>  <span class="meta">#<span class="meta-keyword">define</span> U_BOOT_CMD(name,maxargs,rep,cmd,usage,help) \</span></span><br><span class="line"><span class="number">98</span>  <span class="keyword">cmd_tbl_t</span> __u_boot_cmd_#<span class="meta">#name Struct_Section = &#123;#name, maxargs, rep, cmd, usage, help&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 已 U_BOOT_CMD(hello,  CFG_MAXARGS, 1, do_hello, ...); 为例, 展开后为</span></span><br><span class="line">    <span class="keyword">cmd_tbl_t</span> __u_boot_cmd_hello __attribute__ ((unused,section (<span class="string">".u_boot_cmd"</span>))) = &#123;</span><br><span class="line">    <span class="comment">// 这个变量结构被指定存放在 ".u_boot_cmd" 段内</span></span><br><span class="line">        hello,                                                      <span class="comment">// 指令名称 hello</span></span><br><span class="line">        CFG_MAXARGS,                                                <span class="comment">// 参数最大数量</span></span><br><span class="line">        <span class="number">1</span>,                                                          <span class="comment">// 可重复指令</span></span><br><span class="line">        do_hello,                                                   <span class="comment">// 指令函数</span></span><br><span class="line">        <span class="string">"hello   - print hello world and arguments\n"</span>,              <span class="comment">// 短帮助说明</span></span><br><span class="line">        <span class="string">"..."</span>                                                       <span class="comment">// 长帮助说明</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>清楚了指令的结构体存放方式后, 需要考虑uboot是如何识别输入的指令, 并执行其指定的函数 <code>do_XXX</code><br>这个文件位于 <code>./common/command.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">346</span> <span class="keyword">cmd_tbl_t</span> *find_cmd (<span class="keyword">const</span> <span class="keyword">char</span> *cmd) &#123;</span><br><span class="line"><span class="number">360</span>     <span class="keyword">for</span> (cmdtp = &amp;__u_boot_cmd_start;                           <span class="comment">// 在".u_boot_cmd"段内查找指令</span></span><br><span class="line"><span class="number">361</span>          cmdtp != &amp;__u_boot_cmd_end;</span><br><span class="line"><span class="number">362</span>          cmdtp++) &#123;</span><br><span class="line"><span class="number">363</span>          <span class="keyword">if</span> (<span class="built_in">strncmp</span> (cmd, cmdtp-&gt;name, len) == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="number">364</span>             <span class="keyword">if</span> (len == <span class="built_in">strlen</span> (cmdtp-&gt;name))</span><br><span class="line"><span class="number">365</span>                 <span class="keyword">return</span> cmdtp;   <span class="comment">/* full match */</span></span><br><span class="line"><span class="number">367</span>             cmdtp_temp = cmdtp; <span class="comment">/* abbreviated command ? */</span></span><br><span class="line"><span class="number">368</span>             n_found++;</span><br><span class="line"><span class="number">369</span>         &#125;</span><br><span class="line"><span class="number">370</span>     &#125;</span><br><span class="line"><span class="number">371</span>     <span class="keyword">if</span> (n_found == <span class="number">1</span>) &#123;         <span class="comment">/* exactly one match */</span></span><br><span class="line"><span class="number">372</span>         <span class="keyword">return</span> cmdtp_temp;</span><br><span class="line"><span class="number">373</span>     &#125;</span><br><span class="line"><span class="number">376</span> &#125;</span><br></pre></td></tr></table></figure>
<p>此时, 通过查找 find_cmd 函数, 发现被多次调用, 其中一条路径是指令自动完成, 此处忽略.<br>可以发现它也被 <code>./common/main.c</code> 的 <code>run_command</code> 调用了</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">301</span>  <span class="function"><span class="keyword">void</span> <span class="title">main_loop</span> <span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 源码分析中, 已经分析到此函数. 用于自动启动kernel, 或者等待终端输入指令并执行</span></span><br><span class="line"><span class="number">488</span>     <span class="keyword">for</span> (;;) &#123;                                  <span class="comment">// 死循环, 等待终端输入</span></span><br><span class="line"><span class="number">497</span>         len = readline (CFG_PROMPT);            <span class="comment">// 读取整行, 会存放到 console_buffer 中</span></span><br><span class="line"><span class="number">501</span>         <span class="built_in">strcpy</span> (lastcommand, console_buffer);   <span class="comment">// 赋值给 lastcommand, 譬如 hello 指令</span></span><br><span class="line"><span class="number">521</span>         rc = run_command (lastcommand, flag);   <span class="comment">// 执行 lastcommand</span></span><br><span class="line"><span class="number">527</span>     &#125;</span><br><span class="line"><span class="number">529</span>  &#125;</span><br><span class="line"></span><br><span class="line"><span class="number">1280</span> <span class="function"><span class="keyword">int</span> <span class="title">run_command</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *cmd, <span class="keyword">int</span> flag)</span> </span>&#123;</span><br><span class="line"><span class="number">1361</span>    <span class="keyword">if</span> ((cmdtp = find_cmd(argv[<span class="number">0</span>])) == <span class="literal">NULL</span>) &#123;...&#125;          <span class="comment">// 查找指令</span></span><br><span class="line"><span class="number">1391</span>    <span class="keyword">if</span> ((cmdtp-&gt;cmd) (cmdtp, flag, argc, argv) != <span class="number">0</span>) &#123;...&#125;  <span class="comment">// 执行指令函数, 譬如调用 do_hello</span></span><br><span class="line"><span class="number">1403</span> &#125;</span><br></pre></td></tr></table></figure>
<p>至此, 指令部分的实现分析完成. 再倒过来总结一下:</p>
<ul>
<li>main_loop 中, 终端等待用户输入指令, 譬如 “hello”</li>
<li>run_command 先查找指令是否存在, 调用find_cmd</li>
<li>find_cmd 会在 “.u_boot_cmd” 段内查找指令是否存在</li>
<li>因此, 增减指令很简单, 只有两个关键点:<ul>
<li>使用 <code>U_BOOT_CMD</code> 宏定义, 定义好指令结构, 编译器会自动存放进”.u_boot_cmd” 段</li>
<li>实现指令函数. 习惯上将其命名为 “do_XXX”, 如 “do_hello”.</li>
</ul>
</li>
<li>指令存在的话, 执行指令函数, 即通过 (cmdtp-&gt;cmd) (cmdtp, flag, argc, argv) 的形式调用 do_hello</li>
<li>执行完成后, 继续死循环等待下一条输入</li>
</ul>
<hr>
<p><strong><em>原创于 <a href="https://draapho.github.io/">DRA&amp;PHO</a></em></strong></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/08/25/1720-uboot-source/" itemprop="url">
                  uboot之源码分析
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2017-08-25T00:00:00+10:00" content="2017-08-25">
              2017-08-25
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/embedded-linux/" itemprop="url" rel="index">
                    <span itemprop="name">embedded linux</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h1><ul>
<li><a href="https://draapho.github.io/2017/11/23/1734-linux-content/">嵌入式linux学习目录</a></li>
<li><a href="https://draapho.github.io/2017/11/24/1735-jz2440-basic/">jz2440分区及启动的基础概念</a></li>
<li><a href="https://draapho.github.io/2017/07/07/1719-uboot-makefile/">uboot之makefile分析</a></li>
<li><a href="https://draapho.github.io/2017/08/25/1720-uboot-source/">uboot之源码分析</a></li>
<li><a href="https://draapho.github.io/2017/08/30/1721-uboot-modify/">uboot之定制指令</a></li>
</ul>
<p>本文基于 u-boot-1.1.6, 使用jz2440开发板. 若要使用最新的u-boot版本见: <a href="http://www.denx.de/wiki/U-Boot/WebHome" target="_blank" rel="noopener">u-boot官网</a>  <a href="ftp://ftp.denx.de/pub/u-boot/" target="_blank" rel="noopener">u-boot下载</a></p>
<h1 id="u-boot功能"><a href="#u-boot功能" class="headerlink" title="u-boot功能:"></a>u-boot功能:</h1><ul>
<li>本质是单片机程序</li>
<li>硬件相关初始化<ul>
<li>关看门狗</li>
<li>初始化时钟</li>
<li>初始化SDRAM</li>
<li>从Flash读取内核</li>
</ul>
</li>
<li>最终目的: 启动内核</li>
<li>为开发方便, 还支持:<ul>
<li>烧写flash</li>
<li>网卡</li>
<li>USB</li>
<li>串口</li>
</ul>
</li>
</ul>
<p><img src="https://draapho.github.io/images/1720/uboot-start.png" alt="uboot-start"></p>
<h1 id="查看内存地址分配"><a href="#查看内存地址分配" class="headerlink" title="查看内存地址分配"></a>查看内存地址分配</h1><p>可以使用指令 <code>readelf -s u-boot | grep _start</code> 查看uboot的内存地址分配<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ readelf -s u-boot|grep _start</span><br><span class="line">    63: 33f80118     0 NOTYPE  LOCAL  DEFAULT    1 _start_armboot</span><br><span class="line">   218: 33fb0798     4 OBJECT  LOCAL  DEFAULT   10 mem_malloc_start</span><br><span class="line">   906: 33fb5a0c     4 OBJECT  LOCAL  DEFAULT   10 bin_start_address</span><br><span class="line">  1303: 33f9f274    88 FUNC    LOCAL  DEFAULT    1 setup_start_tag</span><br><span class="line">  1507: 33f80000     0 NOTYPE  GLOBAL DEFAULT    1 _start   // 等同于 config.mk 中的 TEXT_BASE值</span><br><span class="line">  1657: 33f80044     0 NOTYPE  GLOBAL DEFAULT    1 _armboot_start</span><br><span class="line">  1776: 33f80048     0 NOTYPE  GLOBAL DEFAULT    1 _bss_start</span><br><span class="line">  1869: 33fb06ac     0 NOTYPE  GLOBAL DEFAULT  ABS __bss_start</span><br><span class="line">  2038: 33fb016c     0 NOTYPE  GLOBAL DEFAULT  ABS __u_boot_cmd_start</span><br></pre></td></tr></table></figure></p>
<p><img src="https://draapho.github.io/images/1720/uboot-ram.gif" alt="uboot-ram"></p>
<h1 id="一-汇编初始化-start-s"><a href="#一-汇编初始化-start-s" class="headerlink" title="一 汇编初始化, start.s"></a>一 汇编初始化, start.s</h1><p>由链接脚本 <code>./board/100ask24x0/u-boot.lds</code> 可知,<br>uboot启动后, 首先执行的就是 <code>cpu/arm920t/start.s</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">41 .globl _start                        // 程序入口</span><br><span class="line">42 _start:	b       reset               // 跳转到reset执行</span><br><span class="line"></span><br><span class="line">75 _TEXT_BASE:                          // _TEXT_BASE值, 可知等同于 _start</span><br><span class="line">76	    .word	TEXT_BASE               // 赋值</span><br><span class="line">79 _armboot_start:                      // _armboot_start 值等同于 TEXT_BASE</span><br><span class="line">80	    .word _start                    // 赋值 _start 给 _armboot_start</span><br><span class="line"></span><br><span class="line">122 reset:                      </span><br><span class="line">124 /* set the cpu to SVC32 mode */     // 1. 将CPU设置为SVC32管理模式</span><br><span class="line">131 /* turn off the watchdog */         // 2. 关闭看门狗</span><br><span class="line">150 /* mask all IRQs ... - default */   // 3. 关中断</span><br><span class="line"></span><br><span class="line">                                        // 4. 初始化SDRAM</span><br><span class="line">174 #ifndef CONFIG_SKIP_LOWLEVEL_INIT     // 一个宏定义开关</span><br><span class="line">175 	adr	r0, _start                    // 读取当前地址, 如果是从nand flash启动, 这段代码被自动拷贝到片内4K RAM, 初始地址为0</span><br><span class="line">                                          // 反之, 如果代码是直接复制到SDRAM中并运行(如调试器), 则_start和_TEXT_BASE值相等</span><br><span class="line">176 	ldr	r1, _TEXT_BASE                // TEXT_BASE 由 &quot;./board/100ask24x0/config.mk&quot; 赋值为 0x33F80000</span><br><span class="line">                                          // 可在linux用指令 &quot;grep -nr TEXT_BASE *&quot; 搜索</span><br><span class="line">177 	cmp     r0, r1                    // 比较两个值. 不等的话, 说明片外SDRAM还没有被初始化过</span><br><span class="line">178 	blne	cpu_init_crit             // 初始化片外SDRAM的控制 (关MMU, 初始化存储控制器)</span><br><span class="line">179 #endif</span><br><span class="line"></span><br><span class="line">182 stack_setup:                        // 5. 设置栈指针, 栈指针向下递减, 推指针向上递增.</span><br><span class="line">183 	ldr	r0, _TEXT_BASE		          // 从 _TEXT_BASE 开始分配空间. _TEXT_BASE	上面是uboot代码段</span><br><span class="line">184 	sub	r0, r0, #CFG_MALLOC_LEN	      // uboot 自己用的 malloc 堆空间</span><br><span class="line">185 	sub	r0, r0, #CFG_GBL_DATA_SIZE    // 全局变量, 保存uboot系统参数的预留空间</span><br><span class="line">187 #ifdef CONFIG_USE_IRQ</span><br><span class="line">188 	sub	r0, r0, #(CONFIG_STACKSIZE_IRQ+CONFIG_STACKSIZE_FIQ)    // IRQ 以及 FIQ, 中断模式的栈</span><br><span class="line">189 #endif</span><br><span class="line">190 	sub	sp, r0, #12		            // 再减去12字节后, 就是sp栈指针的起始位置</span><br><span class="line"></span><br><span class="line">193 bl clock_init                       // 6. 初始化系统时钟, 设置为400MHz</span><br><span class="line"></span><br><span class="line">197 relocate:                           // 7. 拷贝代码. 把uboot代码从nand/nor flash拷贝到片外 SDRAM 中</span><br><span class="line"></span><br><span class="line">219 clear_bss:                          // 8. 清bss. 将未初始化过的全局变量设为0. Block Started by Symbol     </span><br><span class="line"></span><br><span class="line">261 _start_armboot:	.word start_armboot // 9. 调用 start_armboot, c语言函数.</span><br></pre></td></tr></table></figure>
<h1 id="二-板级初始化-board-c"><a href="#二-板级初始化-board-c" class="headerlink" title="二 板级初始化, board.c"></a>二 板级初始化, board.c</h1><p><code>grep -nwr start_armboot *</code>, 找出 <code>start_armboot</code> 源码文件和行号.<br>可知, 其位于 <code>./lib_arm/board.c</code> 的236行.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">216</span> <span class="keyword">init_fnc_t</span> *init_sequence[] = &#123;...&#125;;    <span class="comment">// 初始化函数组</span></span><br><span class="line"></span><br><span class="line"><span class="number">236</span> <span class="function"><span class="keyword">void</span> <span class="title">start_armboot</span> <span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"><span class="number">248</span>     gd = (<span class="keyword">gd_t</span>*)(_armboot_start - CFG_MALLOC_LEN - <span class="keyword">sizeof</span>(<span class="keyword">gd_t</span>));</span><br><span class="line">        <span class="comment">// 实际指向的就是 CFG_GBL_DATA_SIZE 段, 下面是清零, 对应的结构体是 gd_t</span></span><br><span class="line"></span><br><span class="line"><span class="number">258</span>     <span class="keyword">for</span> (init_fnc_ptr = init_sequence; *init_fnc_ptr; ++init_fnc_ptr) &#123;&#125;</span><br><span class="line">        <span class="comment">// 依次调用初始化函数, 如果返回值为0, 则初始化失败, 系统出错!</span></span><br><span class="line">        <span class="comment">// 在init的过程中, 相关的函数对 gd_t 内容赋值.</span></span><br><span class="line"></span><br><span class="line"><span class="number">266</span>     size = flash_init ();               <span class="comment">// 初始化nor flash</span></span><br><span class="line"><span class="number">267</span>     display_flash_config (size);</span><br><span class="line"></span><br><span class="line"><span class="number">297</span>     mem_malloc_init (_armboot_start - CFG_MALLOC_LEN);  <span class="comment">// 堆地址的初始化</span></span><br><span class="line"></span><br><span class="line"><span class="number">301</span>     nand_init();	                    <span class="comment">// 初始化 nand flash</span></span><br><span class="line"></span><br><span class="line"><span class="number">310</span>     env_relocate ();                    <span class="comment">// 加载uboot的环境变量</span></span><br><span class="line"></span><br><span class="line">...     <span class="comment">// 网卡, devices_init, 显示终端, 控制台, 其它驱动等等 初始化, 略过不表</span></span><br><span class="line"></span><br><span class="line"><span class="number">403</span>     main_loop ();                       <span class="comment">// 初始化结束, 跳转到 main.c 文件的 void main_loop(void)</span></span><br><span class="line"><span class="number">407</span> &#125;</span><br></pre></td></tr></table></figure>
<h1 id="三-识别终端指令-main-c"><a href="#三-识别终端指令-main-c" class="headerlink" title="三 识别终端指令, main.c"></a>三 识别终端指令, main.c</h1><p><code>grep -nr &quot;main_loop (void)&quot; *</code>, 可找到 <code>./common/main.c</code> 的301行 main_loop<br>整个文件的最核心指令就是 run_command(), 即识别和运行指令函数.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">301</span> <span class="function"><span class="keyword">void</span> <span class="title">main_loop</span> <span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="number">404</span>     s = getenv (<span class="string">"bootdelay"</span>);           <span class="comment">// 获取 bootdelay 环境变量</span></span><br><span class="line"><span class="number">405</span>     bootdelay = s ? (<span class="keyword">int</span>)simple_strtol(s, <span class="literal">NULL</span>, <span class="number">10</span>) : CONFIG_BOOTDELAY;</span><br><span class="line"></span><br><span class="line"><span class="number">432</span>     s = getenv (<span class="string">"bootcmd"</span>);             <span class="comment">// 加载 bootcmd 环境变量, 此变量为linux加载和启动指令</span></span><br><span class="line"><span class="number">436</span>     <span class="keyword">if</span> (bootdelay &gt;= <span class="number">0</span> &amp;&amp; s &amp;&amp; !abortboot (bootdelay)) &#123;    <span class="comment">// 倒计时结束, 自动加载linux</span></span><br><span class="line"><span class="number">443</span>         <span class="built_in">printf</span>(<span class="string">"Booting Linux ...\n"</span>);  <span class="comment">// 终端打印信息</span></span><br><span class="line"><span class="number">444</span>         run_command (s, <span class="number">0</span>);             <span class="comment">// 运行 bootcmd 的指令.</span></span><br><span class="line"><span class="number">454</span>     &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// abortboot 函数内会判断倒计时, 并获取按键操作, 只有 ' ' 空格才能跳出启动</span></span><br><span class="line">        <span class="comment">// 457-467行不会运行, 因为没有宏定义 CONFIG_MENUKEY</span></span><br><span class="line"><span class="number">478</span>     run_command(<span class="string">"menu"</span>, <span class="number">0</span>);             <span class="comment">// 执行 "menu" 指令, 打印jz2440定制的菜单信息</span></span><br><span class="line"></span><br><span class="line"><span class="number">488</span>     <span class="keyword">for</span> (;;) &#123;                          <span class="comment">// 死循环, 等待终端输入指令</span></span><br><span class="line"><span class="number">497</span>         len = readline (CFG_PROMPT);    <span class="comment">// 读取终端输入, 提示符为 "OpenJTAG&gt; "</span></span><br><span class="line"><span class="number">521</span>         rc = run_command (lastcommand, flag);   <span class="comment">// 执行输入的指令</span></span><br><span class="line"><span class="number">527</span>     &#125;</span><br><span class="line"><span class="number">529</span> &#125; </span><br><span class="line"></span><br><span class="line">        <span class="comment">// 指令数据结构被放在 __u_boot_cmd 段内, 对应的指令函数可以在 ./common/cmd_***.c 内找到</span></span><br><span class="line"><span class="number">1280</span>    <span class="function"><span class="keyword">int</span> <span class="title">run_command</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *cmd, <span class="keyword">int</span> flag)</span> </span>&#123;</span><br><span class="line"><span class="number">1361</span>        <span class="keyword">if</span> ((cmdtp = find_cmd(argv[<span class="number">0</span>])) == <span class="literal">NULL</span>) &#123;...&#125;      <span class="comment">// 查找指令是否存在</span></span><br><span class="line"><span class="number">1391</span>        <span class="keyword">if</span> ((cmdtp-&gt;cmd) (cmdtp, flag, argc, argv) != <span class="number">0</span>) &#123;&#125; <span class="comment">// 调用指令函数</span></span><br><span class="line"><span class="number">1403</span>    &#125;</span><br></pre></td></tr></table></figure>
<h1 id="四-加载和启动linux"><a href="#四-加载和启动linux" class="headerlink" title="四 加载和启动linux"></a>四 加载和启动linux</h1><h2 id="bootcmd-指令分析"><a href="#bootcmd-指令分析" class="headerlink" title="bootcmd 指令分析"></a>bootcmd 指令分析</h2><p>在uboot命令行下, 输入 <code>printenv</code> 可以查看uboot的环境变量<br>可以找到如下信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">bootcmd=nand read.jffs2 0x30007FC0 kernel; bootm 0x30007FC0</span><br><span class="line">    // 启动指令分为了两条:</span><br><span class="line">    // 1. nand read.jffs2 0x30007FC0 kernel</span><br><span class="line">        // 从 nand flash 的 kernel 分区读取数据, 放到地址 0x30007FC0 处(SDRAM)</span><br><span class="line">    // 2. bootm 0x30007FC0</span><br><span class="line">        // 从 0x30007FC0 启动linux</span><br><span class="line"></span><br><span class="line">bootdelay=2</span><br><span class="line">    // 启动延时参数为2S</span><br><span class="line">    // 因此uboot的环境变量可以是参数设置, 也可以是命令行, 命令行的本质是字符串</span><br></pre></td></tr></table></figure></p>
<h2 id="flash-分区信息"><a href="#flash-分区信息" class="headerlink" title="flash 分区信息"></a>flash 分区信息</h2><p>可以通过 “./include/configs/100ask24x0.h” 中的 MTDPARTS_DEFAULT 来分析获得flash分区情况<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MTDPARTS_DEFAULT <span class="meta-string">"mtdparts=nandflash0:256k@0(bootloader),"</span> \</span></span><br><span class="line">                            <span class="string">"128k(params),"</span> \</span><br><span class="line">                            <span class="string">"2m(kernel),"</span> \</span><br><span class="line">                            <span class="string">"-(root)"</span></span><br><span class="line"><span class="comment">// nandflash0: 分区位于 nandflash 上</span></span><br><span class="line"><span class="comment">// 256k@0(bootloader), 第一个分区从0地址开始, 占用256k, 分区名称 bootloader</span></span><br><span class="line"><span class="comment">// 128k(params), 第二个分区紧邻第一个分区, 占用128K, 分区名称 params</span></span><br><span class="line"><span class="comment">// 2m(kernel), 第三个分区紧邻第二个分区, 占用2m字节, 分区名称 kernel</span></span><br><span class="line"><span class="comment">// -(root), 剩余的空间全部分配给第四个分区, 名称为 root</span></span><br></pre></td></tr></table></figure></p>
<p>也可以在uboot下, 使用 “mtdparts” 可以查看 flash 的分区情况<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">OpenJTAG&gt; mtdparts</span><br><span class="line"> <span class="comment">#: name                size            offset          mask_flags</span></span><br><span class="line"> 0: bootloader          0x00040000      0x00000000      0</span><br><span class="line"> 1: params              0x00020000      0x00040000      0</span><br><span class="line"> 2: kernel              0x00200000      0x00060000      0</span><br><span class="line"> 3: root                0x0fda0000      0x00260000      0</span><br></pre></td></tr></table></figure></p>
<h2 id="加载linux内核"><a href="#加载linux内核" class="headerlink" title="加载linux内核"></a>加载linux内核</h2><p>执行 <code>nand read.jffs2 0x30007FC0 kernel</code> 指令, 源码在 <code>./common/cmd_nand.c</code> 的 do_nand 函数</p>
<ul>
<li>jffs2 是读取的格式, 但此处并非是指 kernel 是jffs2格式. jffs2方式无需块对齐和页对齐, 提高通用性.</li>
<li>可知 kernel 分区大小为 0x200000 (2M), 起始地址为 0x60000</li>
<li>所以整条指令等价于: nand read.jffs2 0x30007FC0(目标地址) 0x60000(源地址) 0x200000(字节大小)</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// nand     read.jffs2  0x30007FC0  kernel </span></span><br><span class="line">    <span class="comment">// argv[0]  argv[1]     argv[2]     argv[3]</span></span><br><span class="line"></span><br><span class="line"><span class="number">166</span> <span class="function"><span class="keyword">int</span> <span class="title">do_nand</span><span class="params">(<span class="keyword">cmd_tbl_t</span> * cmdtp, <span class="keyword">int</span> flag, <span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line"><span class="number">316</span>     <span class="keyword">if</span> (<span class="built_in">strncmp</span>(cmd, <span class="string">"read"</span>, <span class="number">4</span>) == <span class="number">0</span> || <span class="built_in">strncmp</span>(cmd, <span class="string">"write"</span>, <span class="number">5</span>) == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="number">322</span>         addr = (ulong)simple_strtoul(argv[<span class="number">2</span>], <span class="literal">NULL</span>, <span class="number">16</span>);                    <span class="comment">// 目标地址 addr = 0x30007FC0</span></span><br><span class="line"><span class="number">326</span>         <span class="keyword">if</span> (arg_off_size(argc - <span class="number">3</span>, argv + <span class="number">3</span>, nand, &amp;off, &amp;size) != <span class="number">0</span>) &#123;...&#125; <span class="comment">// 获取源地址以及长度</span></span><br><span class="line">            <span class="comment">// arg_off_size 中, 如果发现导入的参数是分区名字, 就会调用 find_dev_and_part() 来获取改分区的地址和长度</span></span><br><span class="line">            <span class="comment">// 最终会将源地址以及长度放入 &amp;off, &amp;size 中</span></span><br><span class="line"><span class="number">336</span>         opts.buffer = (u_char*) addr;                                       <span class="comment">// sdram, 直接就是一片buffer</span></span><br><span class="line"><span class="number">337</span>         opts.length = size;</span><br><span class="line"><span class="number">338</span>         opts.offset = off;</span><br><span class="line"><span class="number">340</span>         ret = nand_read_opts(nand, &amp;opts);                                  <span class="comment">// 读取nand到buffer中</span></span><br><span class="line"><span class="number">416</span>     <span class="built_in">printf</span>(<span class="string">" %d bytes %s: %s\n"</span>, size, read ? <span class="string">"read"</span> : <span class="string">"written"</span>, ret ? <span class="string">"ERROR"</span> : <span class="string">"OK"</span>); <span class="comment">// 打印进度</span></span><br><span class="line"><span class="number">419</span>     <span class="keyword">return</span> ret == <span class="number">0</span> ? <span class="number">0</span> : <span class="number">1</span>;                        返回读取结果</span><br><span class="line"><span class="number">511</span> &#125;</span><br></pre></td></tr></table></figure>
<h2 id="启动linux内核"><a href="#启动linux内核" class="headerlink" title="启动linux内核"></a>启动linux内核</h2><p>执行 <code>bootm 0x30007FC0</code> 指令, 源码在 <code>./common/cmd_bootm.c</code> 的 do_bootm 函数</p>
<ul>
<li>设置 0x30007FC0 这个奇怪的值, 是有原因的. 简而言之, 是为了避免拷贝内核两次, 加快启动速度</li>
<li>kernel 最后编译时的指令是 <code>make uImage</code>, 因此其格式是 uImage</li>
<li>相比于纯压缩文件 zImage 的内核文件, uImage 在 zImage之前加上了长度为 0x40 的头部信息 (image_header_t)</li>
<li>0x30007FC0 + 0x40 = 0x30008000, 正好就是 uImage 头部信息要求的加载地址.</li>
<li>而 0x30008000 这个地址, 是有linux源码在 <code>Makefile</code> 里写死的. 可搜索关键字 <code>zreladdr-y</code> 和 <code>ZRELADDR</code><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="number">149</span> <span class="keyword">image_header_t</span> header;              <span class="comment">// uImage的头部信息, 占用0x40字节</span></span><br><span class="line">        <span class="comment">// ih_load, Data Load Address,   加载地址, 如果发现加载地址不对, do_bootm会重新移动内核文件到此地址</span></span><br><span class="line">        <span class="comment">// ih_ep,   Entry Point Address, 入口地址, 跳转到此地址开始执行linux内核</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// bootm    0x30007FC0</span></span><br><span class="line">    <span class="comment">// argv[0]  argv[1]</span></span><br><span class="line"><span class="number">153</span> <span class="function"><span class="keyword">int</span> <span class="title">do_bootm</span> <span class="params">(<span class="keyword">cmd_tbl_t</span> *cmdtp, <span class="keyword">int</span> flag, <span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line"><span class="number">163</span>     <span class="keyword">image_header_t</span> *hdr = &amp;header;                              <span class="comment">// 指针 hdr 指向头部信息</span></span><br><span class="line"><span class="number">171</span>     addr = simple_strtoul(argv[<span class="number">1</span>], <span class="literal">NULL</span>, <span class="number">16</span>);                   <span class="comment">// 获取地址, 0x30007FC0</span></span><br><span class="line"><span class="number">183</span>     memmove (&amp;header, (<span class="keyword">char</span> *)addr, <span class="keyword">sizeof</span>(<span class="keyword">image_header_t</span>));    <span class="comment">// 读取头部信息</span></span><br><span class="line"><span class="number">229</span>     data = addr + <span class="keyword">sizeof</span>(<span class="keyword">image_header_t</span>);                       <span class="comment">// data为linux内核起始地址</span></span><br><span class="line"><span class="number">321</span>     <span class="keyword">if</span>(ntohl(hdr-&gt;ih_load) == data) &#123;</span><br><span class="line"><span class="number">322</span>         <span class="built_in">printf</span> (<span class="string">"   XIP %s ... "</span>, name);                        <span class="comment">// 一致, 不用移动了</span></span><br><span class="line"><span class="number">323</span>     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="number">340</span>         memmove ((<span class="keyword">void</span> *) ntohl(hdr-&gt;ih_load), (uchar *)data, len);     <span class="comment">// 否则, 把内核移动到加载地址</span></span><br><span class="line"><span class="number">342</span>     &#125;</span><br><span class="line"><span class="number">418</span>     do_bootm_linux  (cmdtp, flag, argc, argv, addr, len_ptr, verify);   <span class="comment">// 启动linux</span></span><br><span class="line"><span class="number">477</span> &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><code>do_bootm_linux</code> 函数位于 <code>./lib_arm/armlinux.c</code>,<br><strong>注意</strong>, cmd_bootm.c文件内的那个do_bootm_linux不会被调用, 因为没有宏定义 CONFIG_PPC</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">79</span>  <span class="function"><span class="keyword">void</span> <span class="title">do_bootm_linux</span> <span class="params">(...)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 此函数主要做两件事情:</span></span><br><span class="line">    <span class="comment">// 1. uboot 需要告诉内核一些系统参数 (内存大小, 终端波特率等等)</span></span><br><span class="line">    <span class="comment">// 2. 跳转到入口地址, 启动内核</span></span><br><span class="line"><span class="number">85</span>    	<span class="keyword">void</span> (*theKernel)(<span class="keyword">int</span> zero, <span class="keyword">int</span> arch, uint params);         <span class="comment">// linux启动函数</span></span><br><span class="line"><span class="number">86</span>      <span class="keyword">image_header_t</span> *hdr = &amp;header;                              <span class="comment">// uImage 头部信息</span></span><br><span class="line"><span class="number">87</span>      <span class="keyword">bd_t</span> *bd = gd-&gt;bd;                                          <span class="comment">// 处于 CFG_GBL_DATA_SIZE 段内</span></span><br><span class="line"><span class="number">90</span>      <span class="keyword">char</span> *commandline = getenv (<span class="string">"bootargs"</span>);                    <span class="comment">// 获取 bootargs 参数</span></span><br><span class="line">        </span><br><span class="line"><span class="number">93</span>      theKernel = (<span class="keyword">void</span> (*)(<span class="keyword">int</span>, <span class="keyword">int</span>, uint))ntohl(hdr-&gt;ih_ep);    <span class="comment">// ih_ep, 即linux入口地址</span></span><br><span class="line"></span><br><span class="line"><span class="number">235</span>     setup_start_tag (bd);                                       <span class="comment">// 一系列的TAG参数设置, 准备传递给linux</span></span><br><span class="line">        <span class="comment">// 对jz2440, TAG地址是 0x30000100. </span></span><br><span class="line">        <span class="comment">// 在 "./board/100ask24x0/100ask24x0.c" 中, gd-&gt;bd-&gt;bi_boot_params = 0x30000100;</span></span><br><span class="line"><span class="number">237</span>	    setup_serial_tag (&amp;params);</span><br><span class="line"><span class="number">240</span>	    setup_revision_tag (&amp;params);</span><br><span class="line"><span class="number">243</span>	    setup_memory_tags (bd);</span><br><span class="line"><span class="number">246</span>	    setup_commandline_tag (bd, commandline);                    <span class="comment">// 告知linux文件系统的位置</span></span><br><span class="line"><span class="number">250</span>	    setup_initrd_tag (bd, initrd_start, initrd_end);</span><br><span class="line"><span class="number">253</span>	    setup_videolfb_tag ((<span class="keyword">gd_t</span> *) gd);</span><br><span class="line"><span class="number">255</span>	    setup_end_tag (bd);                                         <span class="comment">// 参数设置结束</span></span><br><span class="line"></span><br><span class="line"><span class="number">259</span>     <span class="built_in">printf</span> (<span class="string">"\nStarting kernel ...\n\n"</span>);</span><br><span class="line"><span class="number">270</span>     theKernel (<span class="number">0</span>, bd-&gt;bi_arch_number, bd-&gt;bi_boot_params);      <span class="comment">// 调用入口地址, 传入参数, 启动linux</span></span><br><span class="line"><span class="number">271</span> &#125;</span><br></pre></td></tr></table></figure>
<hr>
<p><strong><em>原创于 <a href="https://draapho.github.io/">DRA&amp;PHO</a></em></strong></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/07/07/1719-uboot-makefile/" itemprop="url">
                  uboot之makefile分析
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2017-07-07T00:00:00+10:00" content="2017-07-07">
              2017-07-07
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/embedded-linux/" itemprop="url" rel="index">
                    <span itemprop="name">embedded linux</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h1><ul>
<li><a href="https://draapho.github.io/2017/11/23/1734-linux-content/">嵌入式linux学习目录</a></li>
<li><a href="https://draapho.github.io/2017/11/24/1735-jz2440-basic/">jz2440分区及启动的基础概念</a></li>
<li><a href="https://draapho.github.io/2017/07/07/1719-uboot-makefile/">uboot之makefile分析</a></li>
<li><a href="https://draapho.github.io/2017/08/25/1720-uboot-source/">uboot之源码分析</a></li>
<li><a href="https://draapho.github.io/2017/08/30/1721-uboot-modify/">uboot之定制指令</a></li>
</ul>
<p>本文基于 u-boot-1.1.6, 使用jz2440开发板. 若要使用最新的u-boot版本见: <a href="http://www.denx.de/wiki/U-Boot/WebHome" target="_blank" rel="noopener">u-boot官网</a>  <a href="ftp://ftp.denx.de/pub/u-boot/" target="_blank" rel="noopener">u-boot下载</a></p>
<h1 id="u-boot-编译过程"><a href="#u-boot-编译过程" class="headerlink" title="u-boot 编译过程"></a>u-boot 编译过程</h1><ol>
<li>解压缩 u-boot-1.1.6</li>
<li>打补丁 针对特定开发板发布的补丁. 打补丁方法<br><code>uboot目录下$ patch -p1 &lt; ../补丁文件</code>  p1表示忽略补丁目标目录的第一层</li>
<li>配置 <code>make 100ask24x0_config</code></li>
<li>编译: <code>make</code>, 获取 <code>u-boot.bin</code> 文件</li>
<li>烧录, 多种方式, 可以用jlink烧录到 NOR Flash 中</li>
</ol>
<h1 id="u-boot功能"><a href="#u-boot功能" class="headerlink" title="u-boot功能:"></a>u-boot功能:</h1><ul>
<li>本质是单片机程序</li>
<li>硬件相关初始化<ul>
<li>关看门狗</li>
<li>初始化时钟</li>
<li>初始化SDRAM</li>
<li>从Flash读取内核</li>
</ul>
</li>
<li>最终目的: 启动内核</li>
<li>为开发方便, 还支持:<ul>
<li>烧写flash</li>
<li>网卡</li>
<li>USB</li>
<li>串口</li>
</ul>
</li>
</ul>
<h1 id="u-boot的README"><a href="#u-boot的README" class="headerlink" title="u-boot的README"></a>u-boot的README</h1><p>要了解 u-boot 的架构和设计思路, 建议先看自带的 <code>README</code> 文件. 重要信息如下:</p>
<ul>
<li><code>include/configs/&lt;board_name&gt;.h</code>  板级配置头文件</li>
<li><code>make NAME_config</code>                加载配置, 准备编译</li>
<li><code>make</code> or <code>make all</code>              编译生成bin文件</li>
<li><code>Monitor Commands - Overview:</code>    u-boot 指令概览</li>
<li><code>Environment Variables:</code>          u-boot 环境变量</li>
<li><code>Linux HOWTO:</code>                    编译linux uImage</li>
<li><code>Boot Linux:</code>                     u-boot 启动Linux相关设置</li>
</ul>
<p>自己设置板级配置的步骤: (位于 README line 2375)</p>
<ol>
<li>Add a new configuration option for your board to the toplevel<br>“Makefile” and to the “MAKEALL” script, using the existing<br>entries as examples. Note that here and at many other places<br>boards and other names are listed in alphabetical sort order. Please<br>keep this order.</li>
<li>Create a new directory to hold your board specific code. Add any<br>files you need. In your board directory, you will need at least<br>the “Makefile”, a “<board>.c”, “flash.c” and “u-boot.lds”.</board></li>
<li>Create a new configuration file “include/configs/<board>.h” for<br>your board</board></li>
<li>If you’re porting U-Boot to a new CPU, then also create a new<br>directory to hold your CPU specific code. Add any files you need.</li>
<li>Run “make <board>_config” with your new name.</board></li>
<li>Type “make”, and you should get a working “u-boot.srec” file<br>to be installed on your target system.</li>
<li>Debug and solve any problems that might arise.</li>
</ol>
<h1 id="u-boot的Makefile"><a href="#u-boot的Makefile" class="headerlink" title="u-boot的Makefile"></a>u-boot的Makefile</h1><p>分析 <code>100ask24x0</code> 即jz2440板子的Makefile实现. Linux下可以使用grep搜索.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># pwd = u-boot-1.1.6 文件夹下</span></span><br><span class="line">grep -n 100ask24x0 ./Makefile       <span class="comment"># 在Makefile文件下查找 100ask24x0, 并显示行号</span></span><br><span class="line">grep -nr 100ask24x0 *               <span class="comment"># 当前目录递归查找 100ask24x0</span></span><br><span class="line">grep -nwr 100ask24x0 *              <span class="comment"># w=word, 100ask24x0 作为一个单词查找</span></span><br><span class="line">grep -nd skip 100ask24x0 *          <span class="comment"># 仅在当前目录查找, 不显示子目录信息</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 特别强大的一条指令, 可针对指定文件搜索指定关键字!</span></span><br><span class="line"><span class="comment"># 先用find找出所有的Makefile文件, 然后在Makefile文件内查找 uImage 关键字.</span></span><br><span class="line">find ./ -name <span class="string">"Makefile"</span> | xargs grep -nw --color <span class="string">"uboot"</span></span><br></pre></td></tr></table></figure></p>
<h2 id="‘make-100ask24x0-config’-指令分析"><a href="#‘make-100ask24x0-config’-指令分析" class="headerlink" title="‘make 100ask24x0_config’ 指令分析"></a>‘make 100ask24x0_config’ 指令分析</h2><p><code>make 100ask24x0_config</code> 其指令结构和 <code>make clean</code> 是一样的.<br>因此在 Makefile 里找到 <code>100ask24x0_config</code> 为目标的行即可:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1886    100ask24x0_config	:	unconfig    </span><br><span class="line">1887	    @$(MKCONFIG) $(@:_config=) arm arm920t 100ask24x0 NULL s3c24x0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 目标为 100ask24x0_config, 没有依赖</span></span><br><span class="line"><span class="comment"># 执行 make 100ask24x0_config 后, 实际运行的就是第二行的指令</span></span><br><span class="line"><span class="comment"># 找到并替换里面的变量:</span></span><br><span class="line"><span class="comment">#   MKCONFIG	:= $(SRCTREE)/mkconfig</span></span><br><span class="line"><span class="comment">#   SRCTREE		:= $(CURDIR)</span></span><br><span class="line"><span class="comment">#   $(@:_config=) 其中 $(@) 表示目标, 即 `100ask24x0_config:_config=空`, 最终得到 `100ask24x0`</span></span><br><span class="line"><span class="comment"># 整句替换下来的指令就变成了:</span></span><br><span class="line">    ./mkconfig 100ask24x0 arm arm920t 100ask24x0 NULL s3c24x0</span><br></pre></td></tr></table></figure></p>
<p>因此, 我们需要去当前文件夹下查找 <code>mkconfig</code> 这个脚本文件.<br>下面直接删减成最终执行的样子, 前面加上原来的行号便于学习比较<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 输入为: ./mkconfig 100ask24x0 arm arm920t 100ask24x0 NULL s3c24x0</span></span><br><span class="line"><span class="comment"># 对应的变量:  $0        $1      $2   $3       $4        $5    $6</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印信息</span></span><br><span class="line">23  BOARD_NAME=<span class="string">"<span class="variable">$1</span>"</span>                             <span class="comment"># BOARD_NAME=100ask24x0</span></span><br><span class="line">28  <span class="string">"Configuring for <span class="variable">$&#123;BOARD_NAME&#125;</span> board..."</span>    <span class="comment"># Configuring for 100ask24x0 board...</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 重新创建一系列的软链接:</span></span><br><span class="line">46  <span class="built_in">cd</span> ./include</span><br><span class="line">47  rm -f asm</span><br><span class="line">48  ln -s asm-<span class="variable">$2</span> asm                            <span class="comment"># asm-&gt;asm-arm, 建立一个软连接, 使用asm-arm</span></span><br><span class="line">51  rm -f asm-<span class="variable">$2</span>/arch                           <span class="comment"># asm-arm/arch</span></span><br><span class="line">56  ln -s <span class="variable">$&#123;LNPREFIX&#125;</span>arch-<span class="variable">$6</span> asm-<span class="variable">$2</span>/arch        <span class="comment"># LNPREFIX. 因此 asm-arm/arch-&gt;arch-s3c24x0</span></span><br><span class="line">60  rm -f asm-<span class="variable">$2</span>/proc</span><br><span class="line">61	ln -s <span class="variable">$&#123;LNPREFIX&#125;</span>proc-armv asm-<span class="variable">$2</span>/proc      <span class="comment"># asm-arm/proc-&gt;proc-armv, </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建 config.mk 文件</span></span><br><span class="line">67  <span class="built_in">echo</span> <span class="string">"ARCH   = <span class="variable">$2</span>"</span> &gt;  config.mk             <span class="comment"># &gt;  新建, "ARCH   = arm"</span></span><br><span class="line">68  <span class="built_in">echo</span> <span class="string">"CPU    = <span class="variable">$3</span>"</span> &gt;&gt; config.mk             <span class="comment"># &gt;&gt; 追加, "CPU    = arm920t"</span></span><br><span class="line">69  <span class="built_in">echo</span> <span class="string">"BOARD  = <span class="variable">$4</span>"</span> &gt;&gt; config.mk             <span class="comment"># &gt;&gt; 追加, "BOARD  = 100ask24x0"</span></span><br><span class="line">71  [ <span class="string">"<span class="variable">$5</span>"</span> ] &amp;&amp; [ <span class="string">"<span class="variable">$5</span>"</span> != <span class="string">"NULL"</span> ] &amp;&amp; <span class="built_in">echo</span> <span class="string">"VENDOR = <span class="variable">$5</span>"</span> &gt;&gt; config.mk   <span class="comment"># $5 = NULL, 不写VENDOR字段</span></span><br><span class="line">73  [ <span class="string">"<span class="variable">$6</span>"</span> ] &amp;&amp; [ <span class="string">"<span class="variable">$6</span>"</span> != <span class="string">"NULL"</span> ] &amp;&amp; <span class="built_in">echo</span> <span class="string">"SOC    = <span class="variable">$6</span>"</span> &gt;&gt; config.mk   <span class="comment"># "SOC = s3c24x0"</span></span><br><span class="line"><span class="comment"># 可以使用 `cat ./include/config.mk` 查看该文件的内容.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建 config.h 文件. 为了 `#include &lt;configs/100ask24x0.h&gt;`</span></span><br><span class="line">82  &gt; config.h                                                      <span class="comment"># &gt;  新建 config.h</span></span><br><span class="line">84  <span class="built_in">echo</span> <span class="string">"/* Automatically generated - do not edit */"</span> &gt;&gt;config.h   <span class="comment"># &gt;&gt; 追加写入</span></span><br><span class="line">85  <span class="built_in">echo</span> <span class="string">"#include &lt;configs/<span class="variable">$1</span>.h&gt;"</span> &gt;&gt;config.h                       <span class="comment"># &gt;&gt; 追加写入, $1=100ask24x0</span></span><br><span class="line"><span class="comment"># 可以使用 `cat ./include/config.h` 查看该文件的内容.</span></span><br></pre></td></tr></table></figure></p>
<h2 id="‘make’-指令分析"><a href="#‘make’-指令分析" class="headerlink" title="‘make’ 指令分析"></a>‘make’ 指令分析</h2><p><code>make</code> 实际上执行的是 <code>make all</code>, Makefile 中比较重要的几行为:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">116 # load ARCH, BOARD, and CPU configuration</span><br><span class="line">117 include $(OBJTREE)/include/config.mk</span><br><span class="line">118 export	ARCH CPU BOARD VENDOR SOC</span><br><span class="line"># ./include/config.mk 这个文件由 `make 100ask24x0_config` 指令生成, 可获得如下变量</span><br><span class="line"># ARCH   = arm</span><br><span class="line"># CPU    = arm920t</span><br><span class="line"># BOARD  = 100ask24x0</span><br><span class="line"># SOC    = s3c24x0</span><br><span class="line"></span><br><span class="line">164 include $(TOPDIR)/config.mk</span><br><span class="line"># u-boot-1.1.6 根目录下的配置文件, 里面有一些变量的定义</span><br><span class="line"></span><br><span class="line">169 OBJS  = cpu/$(CPU)/start.o</span><br><span class="line">193 LIBS  = lib_generic/libgeneric.a</span><br><span class="line">194 LIBS += board/$(BOARDDIR)/lib$(BOARD).a</span><br><span class="line">195 LIBS += cpu/$(CPU)/lib$(CPU).a</span><br><span class="line">197 LIBS += cpu/$(CPU)/$(SOC)/lib$(SOC).a</span><br><span class="line">199 LIBS += lib_$(ARCH)/lib$(ARCH).a</span><br><span class="line"># 加载几个板级参数相关的变量值. 特别注意 start.o 这个文件, 是整个u-boot最先运行的文件</span><br><span class="line"></span><br><span class="line">239 ALL = $(obj)u-boot.srec $(obj)u-boot.bin $(obj)System.map $(U_BOOT_NAND)</span><br><span class="line">241 all:		$(ALL)</span><br><span class="line"># `make` 指令的入口就在这里. 可以根据 ALL 目标后面的依赖开始看这个 make 的过程</span><br><span class="line"></span><br><span class="line">262 $(obj)u-boot:		depend version $(SUBDIRS) $(OBJS) $(LIBS) $(LDSCRIPT)</span><br><span class="line">263		    UNDEF_SYM=`$(OBJDUMP) -x $(LIBS) |sed  -n -e &apos;s/.*\(__u_boot_cmd_.*\)/-u\1/p&apos;|sort|uniq`;\</span><br><span class="line">264		    cd $(LNDIR) &amp;&amp; $(LD) $(LDFLAGS) $$UNDEF_SYM $(__OBJS) \</span><br><span class="line">265             --start-group $(__LIBS) --end-group $(PLATFORM_LIBS) \</span><br><span class="line">266             -Map u-boot.map -o u-boot</span><br><span class="line"># 比较重要的一个指令. 可以运行 `make`, 在最后会看到这条指令的展开式, 用这种倒推的方式比较方便. 其展开如下:</span><br><span class="line"></span><br><span class="line">make[1]: Leaving directory &apos;/home/draapho/jz2440/uboot/u-boot-1.1.6/common&apos;</span><br><span class="line"># 这句不重要, 但这句的位置很明显, 所以写在这里了.</span><br><span class="line"></span><br><span class="line">UNDEF_SYM=`arm-linux-objdump -x lib_generic/libgeneric.a board/100ask24x0/lib100ask24x0.a cpu/arm920t/libarm920t.a cpu/arm920t/s3c24x0/libs3c24x0.a lib_arm/libarm.a fs/cramfs/libcramfs.a fs/fat/libfat.a fs/fdos/libfdos.a fs/jffs2/libjffs2.a fs/reiserfs/libreiserfs.a fs/ext2/libext2fs.a net/libnet.a disk/libdisk.a rtc/librtc.a dtt/libdtt.a drivers/libdrivers.a drivers/nand/libnand.a drivers/nand_legacy/libnand_legacy.a drivers/usb/libusb.a drivers/sk98lin/libsk98lin.a common/libcommon.a |sed  -n -e &apos;s/.*\(__u_boot_cmd_.*\)/-u\1/p&apos;|sort|uniq`;\</span><br><span class="line"># 整个语句有点复杂, 用了一系列管道指令, 将最终结果赋值给 UNDEF_SYM 这么一个变量</span><br><span class="line"># 对 &quot;UNDEF_SYM=`$(OBJDUMP) -x $(LIBS) |sed  -n -e &apos;s/.*\(__u_boot_cmd_.*\)/-u\1/p&apos;|sort|uniq`;\&quot; 的展开</span><br><span class="line"># 其中 &quot;board/100ask24x0/lib100ask24x0.a cpu/arm920t/libarm920t.a cpu/arm920t/s3c24x0/libs3c24x0.a lib_arm/libarm.a&quot; 就是对 $(LIBS) 的展开</span><br><span class="line">  </span><br><span class="line">cd /home/draapho/jz2440/uboot/u-boot-1.1.6 &amp;&amp; </span><br><span class="line"># &quot;cd $(LNDIR) &amp;&amp;&quot; 的展开, 进入 u-boot-1.1.6 目录. </span><br><span class="line"></span><br><span class="line">arm-linux-ld -Bstatic -T /home/draapho/jz2440/uboot/u-boot-1.1.6/board/100ask24x0/u-boot.lds -Ttext 0x33F80000  $UNDEF_SYM cpu/arm920t/start.o \</span><br><span class="line"># &quot;$(LD) $(LDFLAGS) $$UNDEF_SYM $(__OBJS) \&quot; 的展开</span><br><span class="line"># $(LD) 就是 arm-linux-ld 链接指令. 其中 &quot;LD	= $(CROSS_COMPILE)ld&quot;, 定义在 &quot;./config.mk&quot;, $(CROSS_COMPILE) 在 Makefile 下面. </span><br><span class="line"># $(LDFLAGS) 给出了链接指令的参数, 定义在 &quot;./config.mk&quot;, 形式为 &quot;LDFLAGS += -Bstatic -T $(LDSCRIPT) -Ttext $(TEXT_BASE) $(PLATFORM_LDFLAGS)&quot;</span><br><span class="line"># 根据 &quot;cpu/arm920t/start.o&quot;, 可以知道 start.s 的文件位置, 便于以后查看. (由u-boot.lds可知, 这是u-boot第一个运行的代码段)</span><br><span class="line"># !!! 其中 $(LDSCRIPT) 和 $(TEXT_BASE) 很重要 !!!</span><br><span class="line">    # &quot;LDSCRIPT := $(TOPDIR)/board/$(BOARDDIR)/u-boot.lds&quot;, 定义在 &quot;./config.mk&quot;. 可以查看链接脚本</span><br><span class="line">    # &quot;TEXT_BASE = 0x33F80000&quot;, 定义在 &quot;./board/100ask24x0/config.mk&quot;. 这个参数明显是板级相关的. 也可以使用 0x33F80000 来搜索.</span><br><span class="line"></span><br><span class="line">                --start-group lib_generic/libgeneric.a board/100ask24x0/lib100ask24x0.a cpu/arm920t/libarm920t.a cpu/arm920t/s3c24x0/libs3c24x0.a lib_arm/libarm.a fs/cramfs/libcramfs.a fs/fat/libfat.a fs/fdos/libfdos.a fs/jffs2/libjffs2.a fs/reiserfs/libreiserfs.a fs/ext2/libext2fs.a net/libnet.a disk/libdisk.a rtc/librtc.a dtt/libdtt.a drivers/libdrivers.a drivers/nand/libnand.a drivers/nand_legacy/libnand_legacy.a drivers/usb/libusb.a drivers/sk98lin/libsk98lin.a common/libcommon.a --end-group -L /usr/local/gcc-3.4.5-glibc-2.3.6/bin/../lib/gcc/arm-linux/3.4.5 -lgcc \</span><br><span class="line">                -Map u-boot.map -o u-boot</span><br><span class="line"># 依旧属于 arm-linux-ld 的指令, 这里就是对 &quot;$(__LIBS)&quot; 和 &quot;$(PLATFORM_LIBS)&quot; 的展开, 忽略这一段, 对理解没有影响.</span><br></pre></td></tr></table></figure></p>
<h2 id="‘u-boot-lds’-链接脚本分析"><a href="#‘u-boot-lds’-链接脚本分析" class="headerlink" title="‘u-boot.lds’ 链接脚本分析"></a>‘u-boot.lds’ 链接脚本分析</h2><p>根据对 Makefile 的分析, 可以知道uboot代码的偏移地址被设置成了 <code>-Ttext 0x33F80000</code> 这么一个值.<br>其含义就是, <strong>给u-boot的代码段分配的空间位于SDRAM最顶部的512K.</strong><br>jz2440使用的SDRAM大小为 64M, 即 0x400_0000, 预留512K (0x8_0000)给u-boot代码, 得到地址 0x3F8_0000.<br>因为 s3c24x0 给SDRAM分配的地址是从 0x3000_0000 开始的, 所以有了 0x33F8_0000 这么一个值. </p>
<p>链接脚本 <code>./board/100ask24x0/u-boot.lds</code> 也很重要. 从中可以知道u-boot整个代码段的分配情况. 下面来分析一下:<br>链接脚本的作用就是安排目标文件在可执行文件中的顺序, 便于链接器生成最终的可执行文件.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">OUTPUT_FORMAT(&quot;elf32-littlearm&quot;, &quot;elf32-littlearm&quot;, &quot;elf32-littlearm&quot;)</span><br><span class="line">/*OUTPUT_FORMAT(&quot;elf32-arm&quot;, &quot;elf32-arm&quot;, &quot;elf32-arm&quot;)*/</span><br><span class="line">OUTPUT_ARCH(arm)</span><br><span class="line">ENTRY(_start)</span><br><span class="line">SECTIONS</span><br><span class="line">&#123;</span><br><span class="line">    // . 表示当前位置, 设置当前位置为 0. 实际物理地址需要加上偏移量 0x33F80000</span><br><span class="line">	. = 0x00000000;</span><br><span class="line"></span><br><span class="line">	. = ALIGN(4);                   // 4字节对齐</span><br><span class="line">	.text      :                    // 代码段</span><br><span class="line">	&#123;</span><br><span class="line">	  cpu/arm920t/start.o	(.text) // 第一段代码放 start.s</span><br><span class="line">      board/100ask24x0/boot_init.o (.text)  // 第二段代码放 boot_init.c (非必须)</span><br><span class="line">	  *(.text)                      // 其它的代码段</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	. = ALIGN(4);</span><br><span class="line">	.rodata : &#123; *(.rodata) &#125;        // 只读数据段, RO段</span><br><span class="line"></span><br><span class="line">	. = ALIGN(4);</span><br><span class="line">	.data : &#123; *(.data) &#125;            // 数据段, RW段</span><br><span class="line"></span><br><span class="line">	. = ALIGN(4);</span><br><span class="line">	.got : &#123; *(.got) &#125;              // uboot自定义, 非标准段</span><br><span class="line"></span><br><span class="line">	. = .;</span><br><span class="line">	__u_boot_cmd_start = .;         // 赋值 __u_boot_cmd_start, 命令段起始位置</span><br><span class="line">	.u_boot_cmd : &#123; *(.u_boot_cmd) &#125;// uboot 命令段, uboot通过宏定义, 将命令放在该段</span><br><span class="line">	__u_boot_cmd_end = .;           // 赋值 __u_boot_cmd_end, 命令段结束位置</span><br><span class="line"></span><br><span class="line">	. = ALIGN(4);</span><br><span class="line">	__bss_start = .;                // 赋值 __bss_start</span><br><span class="line">	.bss : &#123; *(.bss) &#125;              // bss 段</span><br><span class="line">	_end = .;                       // 赋值 _end</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<p><strong><em>原创于 <a href="https://draapho.github.io/">DRA&amp;PHO</a></em></strong></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/07/06/1718-linux-samba/" itemprop="url">
                  Ubuntu下配置支持Windows访问的samba共享
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2017-07-06T00:00:00+10:00" content="2017-07-06">
              2017-07-06
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/embedded-linux/" itemprop="url" rel="index">
                    <span itemprop="name">embedded linux</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>家用电脑, 环境的搭建思路可参考<a href="https://draapho.github.io/2017/02/16/1705-linux-env/">嵌入式linux环境搭建-主机端</a></p>
<p>单位电脑, 没有使用nfs共享文件.<br>用的环境是: VMware Ubuntu 16.04 + Windows 7 + VMware 文件共享<br>尝试编译uboot时, 弹出一个错误提示</p>
<blockquote>
<p>ln: creating symbolic link XXXXXX : Operation not supported</p>
</blockquote>
<p>问题根源和解决方法:<br>出现这类问题，主要是由于在编译的时候，要用ln去建立一些软链接，而这些文件是从Windows中，通过VMWare虚拟机共享进Linux的，Windows不支持软链接，所以，编译会报错。<br>解决办法就是，在VMWare下的Linux中，建立Samba服务， 然后新创建新samba用户和文件夹，然后在windows中就可以访问到该文件夹了。</p>
<p>相比于nfs共享文件, 唯一的缺点是: 文件存放在虚拟机中, 需要始终打开虚拟机才能在windows下访问文件. 因此文件的备份和修复也稍微麻烦一点. 优点是, 不需要付费软件.</p>
<hr>
<p>下文转载自 <a href="http://blog.csdn.net/i_chips/article/details/19191957" target="_blank" rel="noopener">Ubuntu下配置支持Windows访问的samba共享</a></p>
<hr>
<h1 id="一、安装Ubuntu-samba服务器"><a href="#一、安装Ubuntu-samba服务器" class="headerlink" title="一、安装Ubuntu samba服务器"></a>一、安装Ubuntu samba服务器</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install samba</span><br><span class="line">$ sudo apt-get install smbclient <span class="comment"># Linux客户端测试用</span></span><br></pre></td></tr></table></figure>
<h1 id="二、创建samba配置文件"><a href="#二、创建samba配置文件" class="headerlink" title="二、创建samba配置文件"></a>二、创建samba配置文件</h1><ol>
<li><p>备份原配置文件</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo cp /etc/samba/smb.conf /etc/samba/smb.conf.bak</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建共享目录</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo mkdir -p /home/share</span><br><span class="line"><span class="comment"># 一般来说，该目录的权限为755，将其改为777之后，Owner之外的其他用户才有权限写入。</span></span><br><span class="line">$ sudo chmod 777 /home/share</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改配置文件</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ sudo vim /etc/samba/smb.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># ===== 文件内容, 在smb.conf最后添加： =====</span></span><br><span class="line">[share]</span><br><span class="line">    path = /home/share</span><br><span class="line">    browseable = yes</span><br><span class="line">    writable = yes</span><br><span class="line">    comment = smb share <span class="built_in">test</span></span><br><span class="line"><span class="comment"># ===== 结束修改, 保存退出vim =====</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>另外，总结一下常见的samba配置及说明：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">[share]                           # 该共享的共享名</span><br><span class="line">    comment = smb share test  # 该共享的备注</span><br><span class="line">    path = /home/share        # 共享路径</span><br><span class="line">    allow hosts = host(subnet) # 设置该Samba服务器允许的工作组或者域</span><br><span class="line">    deny hosts = host(subnet) # 设置该Samba服务器拒绝的工作组或者域</span><br><span class="line">    available = yes|no        # 设置该共享目录是否可用</span><br><span class="line">    browseable = yes|no       # 设置该共享目录是否可显示</span><br><span class="line">    writable = yes|no         # 指定了这个目录缺省是否可写，也可以用readonly = no来设置可写</span><br><span class="line">    public = yes|no           # 指明该共享资源是否能给游客帐号访问，guest ok = yes其实和public = yes是一样的</span><br><span class="line">    user = user, @group       # user设置所有可能使用该共享资源的用户，也可以用@group代表group这个组的所有成员，不同的项目之间用空格或者逗号隔开</span><br><span class="line">    valid users = user, @group # 指定能够使用该共享资源的用户和组</span><br><span class="line">    invalid users = user, @group # 指定不能够使用该共享资源的用户和组</span><br><span class="line">    read list = user, @group  # 指定只能读取该共享资源的用户和组</span><br><span class="line">    write list = user, @group # 指定能读取和写该共享资源的用户和组</span><br><span class="line">    admin list = user, @group # 指定能管理该共享资源（包括读写和权限赋予等）的用户和组</span><br><span class="line">    hide dot files = yes|no   # 指明是否像UNIX那样隐藏以“.”号开头的文件</span><br><span class="line">    create mode = 0755        # 指明新建立的文件的属性，一般是0755</span><br><span class="line">    directory mode = 0755     # 指明新建立的目录的属性，一般是0755</span><br><span class="line">    sync always = yes|no      # 指明对该共享资源进行写操作后是否进行同步操作</span><br><span class="line">    short preserve case = yes|no # 指明是否区分文件名大小写</span><br><span class="line">    preserve case = yes|no    # 指明是否保持大小写</span><br><span class="line">    case sensitive = yes|no   # 指明是否对大小写敏感，一般选no，不然可能引起错误</span><br><span class="line">    mangle case = yes|no      # 指明混合大小写</span><br><span class="line">    default case = upper|lower # 指明缺省的文件名是全部大写还是小写</span><br><span class="line">    force user = testuser     # 强制把建立文件的属主是谁。如果我有一个目录，让guest可以写，那么guest就可以删除，如果我用force user= testuser强制建立文件的属主是testuser，同时限制create mask = 0755，这样guest就不能删除了</span><br><span class="line">    wide links = yes|no       # 指明是否允许共享外符号连接，比如共享资源里面有个连接指向非共享资源里面的文件或者目录，如果设置wide links = no将使该连接不可用</span><br><span class="line">    max connections = 100     # 设定最大同时连接数</span><br><span class="line">    delete readonly = yes|no  # 指明能否删除共享资源里面已经被定义为只读的文件</span><br></pre></td></tr></table></figure>
<h1 id="三、创建samba用户"><a href="#三、创建samba用户" class="headerlink" title="三、创建samba用户"></a>三、创建samba用户</h1><p>注意，创建samba用户之前，必须先确保有一个同名的linux用户，否则samba用户会创建失败。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo smbpasswd -a <span class="variable">$USER</span></span><br></pre></td></tr></table></figure></p>
<h1 id="四、重启samba服务"><a href="#四、重启samba服务" class="headerlink" title="四、重启samba服务"></a>四、重启samba服务</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo service smbd restart</span><br></pre></td></tr></table></figure>
<h1 id="五-客户端访问测试"><a href="#五-客户端访问测试" class="headerlink" title="五. 客户端访问测试"></a>五. 客户端访问测试</h1><ol>
<li><p>Linux客户端访问测试</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ smbclient -L //localhost/share</span><br></pre></td></tr></table></figure>
</li>
<li><p>Windows客户端访问测试<br> 可以访问如下地址 <code>\\Linux的IP或者主机名\share</code></p>
</li>
<li><p>我一般会把虚拟机端Linux的IP搞成静态地址, 这样远程登录也更方便</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ ifconfig                          <span class="comment"># 查看IP信息</span></span><br><span class="line">$ sudo vim /etc/network/interfaces</span><br><span class="line"></span><br><span class="line">    <span class="comment"># ===== 文件内容, 大致修改如下: =====</span></span><br><span class="line">    auto lo</span><br><span class="line">    iface lo inet loopback</span><br><span class="line">    auto eth0</span><br><span class="line"></span><br><span class="line">    iface eth0 inet static          <span class="comment"># 使用静态地址</span></span><br><span class="line">    address  192.168.0.100          <span class="comment"># 设置静态地址</span></span><br><span class="line">    netmask  255.255.255.0</span><br><span class="line">    gateway  192.168.0.1            <span class="comment"># 网关</span></span><br><span class="line">    dns-nameservers   8.8.8.8  192.168.0.1 </span><br><span class="line">    <span class="comment"># ===== 结束修改, 保存退出vim =====</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>如果public = no，此时需要输入samba用户密码；<br>如果public = yes，则作为nobody用户直接访问。<br>另外，在Windows客户端使用 <code>net use * /del /y</code> 这条命令可以清理访问缓存。</p>
<hr>
<p>转载自 <a href="http://blog.csdn.net/i_chips/article/details/19191957" target="_blank" rel="noopener">Ubuntu下配置支持Windows访问的samba共享</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/05/31/1717-scrum/" itemprop="url">
                  敏捷开发 Scrum 学习
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2017-05-31T00:00:00+10:00" content="2017-05-31">
              2017-05-31
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/software/" itemprop="url" rel="index">
                    <span itemprop="name">software</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="学习资源推荐"><a href="#学习资源推荐" class="headerlink" title="学习资源推荐"></a>学习资源推荐</h1><ul>
<li><a href="http://scrumtrainingseries.com/" target="_blank" rel="noopener">Scrum Training Series</a>, 通俗易懂的视频教程</li>
<li><a href="http://www.scrumreferencecard.com/" target="_blank" rel="noopener">Scrum Reference Card</a>, Scrum 参考卡</li>
<li><a href="http://scrummasterchecklist.org/" target="_blank" rel="noopener">The Scrum Master Checklist</a>, Scrum Master 职能清单</li>
<li><a href="http://www.scrumguides.org/download.html" target="_blank" rel="noopener">The Scrum Guide™</a>, Scrum 指导手册下载 (多国语言)</li>
<li>测试. 建议测试完后, 再看一下 <a href="http://scrumtrainingseries.com/" target="_blank" rel="noopener">Scrum Training Series</a> 视频<ul>
<li><a href="https://www.proprofs.com/quiz-school/story.php?title=mte3mjcynamkcf" target="_blank" rel="noopener">Scrum Assessment</a></li>
<li><a href="https://www.proprofs.com/quiz-school/story.php?title=quizscrum" target="_blank" rel="noopener">Scrum (Programming) Quiz</a></li>
<li><a href="https://www.proprofs.com/quiz-school/story.php?title=certified-scrum-master-test" target="_blank" rel="noopener">Certified Scrum Master Test</a></li>
<li><a href="https://www.proprofs.com/quiz-school/story.php?title=NjAyMjg5#" target="_blank" rel="noopener">Scrum Training Series, Part 1: Introduction To Scrum</a></li>
<li><a href="https://www.proprofs.com/quiz-school/story.php?title=NzA4NjI0OO75" target="_blank" rel="noopener">Scrum 30题</a></li>
</ul>
</li>
</ul>
<h1 id="Scrum-核心点概要"><a href="#Scrum-核心点概要" class="headerlink" title="Scrum 核心点概要"></a>Scrum 核心点概要</h1><p><img src="https://draapho.github.io/images/1717/Sprint.JPG" alt="Sprint"></p>
<h2 id="敏捷开发宣言"><a href="#敏捷开发宣言" class="headerlink" title="敏捷开发宣言"></a>敏捷开发宣言</h2><ul>
<li><strong>Individuals and interactions</strong> over processes and tools</li>
<li><strong>Working software</strong> over comprehensive documentation</li>
<li><strong>Customer collaboration</strong> over contract negotiation</li>
<li><strong>Responding to change</strong> over following a plan</li>
</ul>
<h2 id="Scrum-Team-Roles"><a href="#Scrum-Team-Roles" class="headerlink" title="Scrum Team Roles"></a>Scrum Team Roles</h2><ul>
<li><strong>Product Owner</strong>, 产品负责人<ol>
<li>核心工作是确定产品需求, 确定产品是否可接受/可发布. 并确保研发团队专注于该产品的开发(挡住干系人对研发团队可能的干扰)</li>
<li>管理和维护 <code>PBI</code>, 并设定优先级.</li>
<li>确保 <code>PBI</code> 对整个团队清晰可见, 高度透明, 并清楚的知道最高优先项.</li>
<li>需要与第三方(利益相关者/老板/客户)确定需求, 接纳或拒绝新需求.</li>
<li>第三方只能和产品负责人讨论产品进度/好坏之类的问题, 甚至发牢骚. 不得直接干预研发团队!</li>
<li>一般地, 此职位可由项目经理担任. 需要特别注意公司老板不得越过项目经理去分配任务!</li>
<li>产品负责人只需要粗颗粒的拆分一下需求, 更细粒度的拆分由研发团队一起完成.</li>
<li><strong>Focused more on the what than on how</strong>. 侧重于要产品实现什么, 而不是怎么实现的问题.</li>
<li>仅对产品负责, 并不是研发团队的管理人员! Scrum 要求研发团队自我管理.</li>
</ol>
</li>
<li><strong>Development Team</strong>, 研发团队<ol>
<li>产品的技术实现团队, 由4-9人组成较为合适. 譬如 UI设计师x1, 行业专家x1, 软件开发x2, 测试x1.</li>
<li>跨职能, 职责包括需求分析和拆解, 设计, 编码, 测试以及部署.</li>
<li>团队成员自我组织和管理, 高度协作. 相互平等, 没有领导者!</li>
<li>整个团队最好在一起工作, 可以大大提高效率.</li>
<li>在 <code>Sprint Planning Meeting</code> 上, 把 <code>PBI</code> 拆解为 <code>Sprint Tasks</code> 放在 <code>Sprint Backlog</code> 一栏.</li>
<li>以 <code>Sprint</code> 为周期, 都要尽可能的完成一个可演示/可发布的产品版本.</li>
</ol>
</li>
<li><strong>Scrum Master</strong>, Scrum大师 (被误解最多的一个职位)<ol>
<li>Scrum的起步很困难, 因此有了Scrum大师来帮助整个团队理解Scrum的理论, 实践方式, 以及内在精神. 排除实践过程中可能走得弯路.</li>
<li>Scrum大师没有任何决策权, 也不是一个管理岗位. 主要作用就是帮助团队学习使用Scrum框架, 消除误解, 排除干扰和障碍.</li>
<li>这个角色的初衷, 类似于婴儿学步阶段需要有个引导者, 这样可以学的快, 少摔跤. 但没有这个角色, 并不是说就学不会走路了.</li>
<li>实际项目中, 很少有团队会去请一个Scrum大师… 因此这个职位可以被分解为两部分: 理解Scrum, 严格执行Scrum的实践要求.</li>
<li>Scrum的理论和精神已经摆在那里, 因此可以团队成员一起学习讨论, 在实践中进行案例分析, 自学之.</li>
<li>严格执行Scrum的实践, 主要包括: 建立一个舒适的会议环境, 安排和控制会议时间, 确保会议内容仅与项目相关. 建议找一个项目之外的人来做.</li>
</ol>
</li>
</ul>
<h2 id="The-Sprint"><a href="#The-Sprint" class="headerlink" title="The Sprint"></a>The Sprint</h2><ul>
<li><code>Sprint</code> 是Scrum的核心, 时间跨度为2周到一个月.</li>
<li><code>Sprint</code> 由 <code>Sprint Planning</code>, <code>Daily Scrums</code>, 开发工作, <code>Sprint Review</code>, <code>Sprint Retrospective</code> 组成</li>
<li>一个 Sprint 周期内, 可以看成是一个完整的瀑布模式:<ul>
<li>不能改变设定的目标</li>
<li>必须有测试, 不能降低检测标准</li>
<li>目标实现的范围可以和 <code>Product Owner</code> 重新讨论和确定</li>
<li>最终实现一个可用的, 完全测试过的, 可潜在发布的软件版本.</li>
</ul>
</li>
<li>仅<code>Product Owner</code> 有权取消一个 <code>Sprint</code>. 很少出现这种情况, 写在这里只是为了明确职责.</li>
<li><code>Done</code>的定义<ul>
<li>Scrum团队的每个人都清除的知道 <code>Done</code> 意味着什么.</li>
<li><code>Done</code> 可以是大家共同理解的惯例, 标准或指南</li>
<li><code>Done</code> 也可以由 <code>Development Team</code> 在 <code>Sprint Planning Meeting</code> 上确定.</li>
</ul>
</li>
</ul>
<h2 id="Scrum-Meetings"><a href="#Scrum-Meetings" class="headerlink" title="Scrum Meetings"></a>Scrum Meetings</h2><p><img src="https://draapho.github.io/images/1717/meeting_flow.JPG" alt="meeting_flow"></p>
<p><img src="https://draapho.github.io/images/1717/meeting_schedule.JPG" alt="meeting_schedule"></p>
<ul>
<li><strong>Backlog Refinement Meeting</strong> PBI修整会议<ol>
<li>所有Scrum人员参与, 可以在每个Sprint执行过程中拿出点时间(如2小时)进行一次, 为下一次的 <code>Sprint Planning</code> 做准备</li>
<li>主要任务是将部分高优先级的粗颗粒<code>PBI</code>分解为细颗粒 <code>PBI</code>, 并确定对<code>Product Owner</code>而言何为 <code>Done</code></li>
<li>细化程度为 <a href="http://xp123.com/articles/invest-in-good-stories-and-smart-tasks/" target="_blank" rel="noopener"><strong>INVEST</strong>: Independent, Negotiable, Valuable, Estimable, Small, Testable 或 <strong>SMART</strong>: Specific, Measurable, Achievable, Relevant, Time-boxed</a>, 以及 <strong>3W</strong>: Who, What, Why</li>
</ol>
</li>
<li><strong>Sprint Planning Meeting</strong> 计划会议<ol>
<li>所有Scrum人员参与. 时间控制在4-8小时左右.</li>
<li><code>Sprint Planning</code> 需要确定在一个<code>Sprint</code>周期内, 做什么以及怎么做.</li>
<li><code>Product Owner</code> 维护 <code>PBI</code> 的优先级. 每次总是讨论最高优先级的 <code>PBI</code></li>
<li><code>Product Owner</code> 不应对 <code>Development Team</code> 施加进度压力. 产品开发复杂度远大于外行的想象, 直接干预容易在后期造成技术负债.</li>
<li><code>Development Team</code> 确定何为 <code>Done</code>. 需要特别注意还要考虑代码的向后兼容性, 必要时甚至重构.</li>
<li><code>Development Team</code> 进一步拆分 <code>PBI</code> 为 <code>Sprint Task</code>, 并认领这些任务.</li>
<li><code>Development Team</code> 需要相互协作和评估, 设定在一个 <code>Sprint</code> 周期内可完成的目标.<br>初期, 开发人员容易接受过多的任务, 而不是过少的任务. 这会导致一个 <code>Sprint</code> 内无法完成承诺的任务!<br>注意, 这里不单是指编码工作, 还包含了设计, 代码重构, 完整的测试, 以及潜在的发布, 是一整个瀑布开发的模式.</li>
</ol>
</li>
<li><strong>Daily Scrum Meeting</strong> 日会<ol>
<li>每天同一时间, 同一地点, <code>Development Team</code> 花费15分钟相互报告情况.</li>
<li>内容为: 昨天做了什么, 今天要做什么, 是否遇到障碍. 这样可确保任务透明, 成员自律而高效.</li>
<li>站着开会, 以保持会议简短. 如果有额外需要关注的话题, 在该会议结束后, 相关人员参与即可.</li>
<li><code>Product Owner</code> 可以选择参与. 但团队的领导或主管不要参与!</li>
<li>日会讨论时, 可能会讨论出其他不相干的话题(sidebar), 则可以日会后仅相关人员参与. 不要占用日会时间.</li>
</ol>
</li>
<li><strong>Sprint Review Meeting</strong> 评审会议<ol>
<li>一个<code>Sprint</code>周期到达后, 就需要开评审会议, 以确定成果. <code>Development Team</code> 展示一个可潜在交付的软件版本.</li>
<li>所有Scrum人员, 以及干系人都可以参加, <code>Development Team</code> 进行现场演示以获得干系人的反馈 (不是写文案做报告).</li>
<li><code>Product Owner</code> 逐条检查在 <code>Sprint Backlog</code> 里的 <code>PBI</code>, 宣布哪些<code>Done</code>, 哪些没有完成(即将完成也是没完成!). </li>
<li><code>Product Owner</code> 将没完成的 <code>PBI</code> 放回 <code>Product Backlog</code>, 重新设定优先级</li>
<li><code>Product Owner</code> 配合干系人, 将他们新的意见转换为需求, 放入 <code>Product Backlog</code>, 设定优先级</li>
</ol>
</li>
<li><strong>Sprint Retrospective Meeting</strong> 回顾会议<ol>
<li>所有Scrum人员参与, 可以放在<code>Sprint Review Meeting</code> 之后, 花费1-3小时.</li>
<li>回顾上一个 Sprint 执行过程中的经验得失 (譬如交流是否顺畅, 开发工具的使用, 学习心得) . 是否有改进余地.</li>
<li><code>Scrum Master</code> 需要引导与会人真实的表达了自己的想法, 达到解决障碍和问题, 改进流程的目的. </li>
<li>回顾会议不是为了评估谁好谁坏, 决定日后如何分配奖金. 追求的是共同进步, 一起完成项目, 追求团队的成功.</li>
<li>这一部分, 我理解的不是很好.</li>
</ol>
</li>
</ul>
<h2 id="Scrum-Artifacts"><a href="#Scrum-Artifacts" class="headerlink" title="Scrum Artifacts"></a>Scrum Artifacts</h2><ul>
<li><strong>Product Backlog</strong><ol>
<li>一个展示区, 用于展示项目所期望的功能, 可以随时增减. 说明要做什么(开发目标)</li>
<li>所有干系人可见, 所有干系人(包括团队)均可添加条目</li>
<li><code>Product Owner</code> 持续地按优先级在 <code>Product Backlog</code> 区域排列 <code>PBI</code></li>
<li>顶部为细颗粒<code>PBI</code>, 底部为粗颗粒<code>PBI</code>.</li>
</ol>
</li>
<li><strong>Product Backlog Item</strong>, 简称<code>PBI</code><ol>
<li>由 <code>Backlog Refinement Meeting</code> 分解条目, 安排优先级.</li>
<li><code>PBI</code> 通常写成 <code>User Story</code>, 工作规模控制在 2-3个人工作2-3天可完成.</li>
</ol>
</li>
<li><strong>Sprint Backlog</strong><ol>
<li>在 <code>Sprint Planning Meeting</code> 上, <code>Development Team</code> 和 <code>Product Owner</code> 协商承诺的<code>PBI</code>组成</li>
<li>整个Scrum人员可见. 在Sprint执行期间, 承诺范围和任务目标不可改变.</li>
<li>在Sprint执⾏行期间, 团队将发现兑现既定范围承诺还需要的附加任务, 则放到 <code>Sprint Backlog</code> 中.</li>
<li>放在这里的 <code>PBI</code> 需要定义好 <code>Done</code>. 注意考虑复用性和向后兼容性, 以防止潜在的技术债务.</li>
</ol>
</li>
<li><strong>Sprint Task</strong> (optional)<ol>
<li>对如何完成一条PBI的若干简单描述. 该任务必须细化到一天以内即可完成</li>
<li>在Sprint执行期间, 每个人都可主动认领任务</li>
<li>由整个团队拥有, 需要协作.</li>
<li>这是一个可选项, 而非必须项. 过度使用并不利于提高效率.</li>
</ol>
</li>
<li><strong>Increment</strong><ol>
<li><code>Increment</code> 是一个 Sprint 完成的所有产品待办列表项的总和</li>
<li>完成一个 Sprint 时, 新的 <code>Increment</code> 必须是 <code>Done</code> 的, 并可用和潜在可发布.</li>
</ol>
</li>
</ul>
<h2 id="若干种Sprint的展示板"><a href="#若干种Sprint的展示板" class="headerlink" title="若干种Sprint的展示板"></a>若干种Sprint的展示板</h2><p><img src="https://draapho.github.io/images/1717/Sprint_backlog_1.JPG" alt="Sprint_backlog_1"></p>
<p><img src="https://draapho.github.io/images/1717/Sprint_backlog_2.JPG" alt="Sprint_backlog_2"></p>
<p><img src="https://draapho.github.io/images/1717/Sprint_backlog_3.JPG" alt="Sprint_backlog_3"></p>
<p><img src="https://draapho.github.io/images/1717/Sprint_backlog_4.JPG" alt="Sprint_backlog_4"></p>
<hr>
<p><strong><em>原创于 <a href="https://draapho.github.io/">DRA&amp;PHO</a></em></strong></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/05/29/1716-AI-IoT/" itemprop="url">
                  AI和物联网的潜在应用
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2017-05-29T00:00:00+10:00" content="2017-05-29">
              2017-05-29
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/thoughts/" itemprop="url" rel="index">
                    <span itemprop="name">thoughts</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>基于目前AI和物联网的发展, 在可见的未来必然有无数的领域受到严重影响.<br>就我思考的范围而言, 此文列举出技术上基本可行的几种应用, 只是需要在商业模式, 技术细节上需要进一步考虑.</p>
<h1 id="AI的发展模式"><a href="#AI的发展模式" class="headerlink" title="AI的发展模式"></a>AI的发展模式</h1><p>AlphoGo 在围棋上的完胜绝对是意义非凡. AlphoGo是真AI, 而不单单是一堆0,1+逻辑运算的机器.</p>
<p>数学上有个概念叫建模, 本质上就是一种抽象. 只是这种抽象需要用数学表达出来, 便于他人理解和使用.<br>有了这么一个模型后, 就能描述系统的因果关系和相互关系.</p>
<p>大家都知道数学建模很难, 但实际上, 不严格的建模无处不在, 人类的经验就是对某个事物/系统/过程的一种建模结果,<br>依靠这种经验, 人去判断事物/系统/过程的因果关系和相互关系. 但经验很难学习和表达!</p>
<p>AlphoGo 就是基于人类的过往经验和自我训练, 形成了自己的对围棋的一套认知, 一组经验.<br>这种经验的形成设计者可以去查看前因后果, 但恐怕很难去描述和理解.</p>
<p>关键点就是:</p>
<ul>
<li><strong>AlphoGo 对围棋进行了抽象, 有自己对围棋的经验, 或者说”理解”.</strong>, 其抽象能力高于所有的人类棋手!</li>
<li>围棋有规则, 有边界, 但无法穷举运算. 也就是需要一定程度的抽象来解决问题.</li>
<li>智力至少是和抽象能力正相关的. 智商高的一般抽象能力更强, “理解”的更快更深更透.</li>
</ul>
<h2 id="现阶段的AI"><a href="#现阶段的AI" class="headerlink" title="现阶段的AI"></a>现阶段的AI</h2><p>目前阶段的AI需要人类设定目标和范围, 需要大量的数据进行前期训练已获得对抽象能力, 或曰”经验”.<br>通过良好的训练, 这种”经验”可以远胜于人类! 而且人类很难去理解.</p>
<p>这一阶段的AI必然被广泛应用于特定目标, 譬如股市, 人像识别, 军事领域.<br>人们对这一阶段的AI也会觉得比较放心, 因为目标是人给的, 训练数据也是人给的.<br>至少这台机器只有智力, 没有创造力! 但毫无疑问, 即使在这一阶段, 也会造成大量人员的事业, 金融业已经发生了!</p>
<p>训练好的机器可以单机运行, 因此AI机器人从技术上讲, 已经可行了. 譬如蔬果采集机器人.</p>
<h2 id="第二阶段的AI"><a href="#第二阶段的AI" class="headerlink" title="第二阶段的AI"></a>第二阶段的AI</h2><p>第一阶段的AI, 最繁琐的部分就是前期训练, 让AI获取数据, 用以获取”经验”<br>自然而然, 人们会想着办法偷懒, 让机器自己去获取数据, 自我训练. 这不就是”自我学习”么.<br>这阶段依然是安全的, AI有如一个听话懂事又聪明的小孩, 给定目标, 拼命学习, 执行任务.<br>但是, 其实人们已经渐渐失去了对AI的控制, AI能自学后, 人们越来越难理解AI的”思考”方式, 追踪整个过程变得复杂而不现实.</p>
<p>这一阶段, AI飞速发展, 在各个特定领域展露手脚… (人们或许可以自娱自乐获取财富? 或是踩脚踏车?)</p>
<h2 id="第三阶段的AI"><a href="#第三阶段的AI" class="headerlink" title="第三阶段的AI"></a>第三阶段的AI</h2><p>量变是会造成质变的. 当人们越来越依赖于AI的时候, 或许不仅会让AI自学, 还会为了解决更复杂的问题, 让不同的AI相互交流和学习.<br>譬如做城市规划的AI, 必然可以读取人口预测AI, 建筑规划AI, 地质天气信息预测AI,<br>说不定为了达到目标, 这个大AI还会自动分配一个小任务: 城市人口迁徙预测AI (分配目标, 自学去)<br>这个时候, 人们已经完全无法了解城市规划AI所做决定的前因后果了… 这个AI的目的可能是明确的, 但其边界已经不由人类控制.</p>
<p>如果此时给AI若干终极问题 (目标明确, 边界由AI自行决定):</p>
<ul>
<li>帮助人类永生 (即人类一直繁衍生存下去) …</li>
<li>让所有人幸福 …</li>
<li>探索宇宙 …</li>
</ul>
<p>希望到这时候, AI还没有学会用欺骗来达到目的, 这样人们可能还有机会提前知道AI给出的解决方案, 来决定是不是要拔电源…</p>
<h1 id="物联网的基础模式"><a href="#物联网的基础模式" class="headerlink" title="物联网的基础模式"></a>物联网的基础模式</h1><p>目前物联网发展日趋成熟, 共享单车的技术方案充分展示了这种技术上的成熟度!</p>
<p><img src="https://draapho.github.io/images/1716/IoT_structure.png" alt="IoT_structure"></p>
<h2 id="节点端"><a href="#节点端" class="headerlink" title="节点端"></a>节点端</h2><p>主要功能就是信息的采集和发送.<br>主要技术难点是供电持久性, 便携性, 稳定可靠性.<br>部分涉及音视频传输的节点, 技术上就更复杂.<br>不同的应用领域有不同的需求, 是一个需要定制的设备.</p>
<h2 id="云端"><a href="#云端" class="headerlink" title="云端"></a>云端</h2><p>云端即数据库, 进行数据的收集, 存储和再分析. 需要注意安全性, 吞吐量.<br>未来, 数据即价值所在. 因为目前的AI需要前期大量的数据来训练, 训练成功后有无穷的潜力.</p>
<h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><p>没啥好说的, 目前高度集中于两种展示平台:</p>
<ul>
<li>浏览器</li>
<li>苹果手机APP</li>
<li>android手机APP</li>
</ul>
<h1 id="潜在的商业应用"><a href="#潜在的商业应用" class="headerlink" title="潜在的商业应用"></a>潜在的商业应用</h1><p>天马行空, 随便聊聊. 作为一个技术人员, 可以肯定技术上已经可行或即将可行.</p>
<h2 id="一般的物联网应用"><a href="#一般的物联网应用" class="headerlink" title="一般的物联网应用"></a>一般的物联网应用</h2><p>更多在于发现潜在的商业机会, 挖掘特定行业的物联需求.<br>技术实现有一定复杂度(跨度太大, 从硬件到云端, 完全自行开发不现实).</p>
<h2 id="物联网方案公司"><a href="#物联网方案公司" class="headerlink" title="物联网方案公司"></a>物联网方案公司</h2><p>考虑到大多数初创公司没有能力进行全程研发, 建立物联网方案公司, 帮助其解决技术难题.<br>自我定位要准确: 帮助别的公司完成研发, 要考虑别的公司的核心利益.<br>因此, 采集的核心数据要开放出来, 不能私有.<br>对没有研发能力的公司可以收取服务费维持系统运行,<br>对于发展到一定程度, 希望全部自己控制的公司可以进行技术买断.</p>
<p>收费模式为: 低进入费, 稳定的服务费, 高买断费.</p>
<h2 id="共享汽车"><a href="#共享汽车" class="headerlink" title="共享汽车"></a>共享汽车</h2><p>灵感来源于共享单车和无人驾驶车.<br>若无人驾驶车量产后, 政府允许真的无人汽车自主运行. 那汽车租赁有机会在城市里蚕食掉大部分私车市场.<br>因为呼之即来, 挥之即去(就近自动找停车位). 不用担心停车, 维护问题. 每辆车的高频率使用也意味着单次出行的低成本.</p>
<h2 id="农业收割"><a href="#农业收割" class="headerlink" title="农业收割"></a>农业收割</h2><p>单机版AI+机器人, 可以完成非标准化的蔬果采摘工作.<br>提前训练好AI, 用来识别特定的水果, 以及采摘方式.<br>将此AI植入合适的机器人, 即可实现高效的自动农业收割.</p>
<p>当然, 都AI机器人了, 自然也是结合物联网上传采摘了多少果子之类的简单功能了.</p>
<hr>
<p><strong><em>原创于 <a href="https://draapho.github.io/">DRA&amp;PHO</a></em></strong></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/05/17/1715-c/" itemprop="url">
                  C语言知识巩固
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2017-05-17T00:00:00+10:00" content="2017-05-17">
              2017-05-17
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/software/" itemprop="url" rel="index">
                    <span itemprop="name">software</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="常数的数据类型"><a href="#常数的数据类型" class="headerlink" title="常数的数据类型"></a>常数的数据类型</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> 1234            <span class="comment">// default type, int</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> 123456l         <span class="comment">// long</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> 1234u           <span class="comment">// unsigned int</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> 123456ul        <span class="comment">// unsigned long</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> 123.4f          <span class="comment">// float</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> 1e-2f           <span class="comment">// float</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> 123.4           <span class="comment">// default type, double</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> 1e-2            <span class="comment">// default type, double</span></span></span><br></pre></td></tr></table></figure>
<h1 id="字符和字符串"><a href="#字符和字符串" class="headerlink" title="字符和字符串"></a>字符和字符串</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> X    <span class="meta-string">'x'</span>        <span class="comment">// 直接使用字母, 会自动转换为ASCII编码</span></span></span><br><span class="line">#define CR   '\015'     // 八进制表示CR, 以\0开头</span><br><span class="line">#define CR   '\13'      // 十进制表示CR, 以\开头</span><br><span class="line">#define CR   '\x0D'     // 十六进制表示CR, 以\x开头</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CR   <span class="meta-string">'\r'</span>       <span class="comment">// 特殊表示法</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串, 独立使用多个双引号, 也表示一串字符串</span></span><br><span class="line"><span class="keyword">char</span> short_str[] = <span class="string">"hello,"</span> <span class="string">" world"</span> <span class="string">"!"</span>;</span><br><span class="line"><span class="keyword">char</span> long_str[] = <span class="string">"this is a very very long string,"</span></span><br><span class="line">                  <span class="string">"so you can set it in multi lines "</span></span><br><span class="line">                  <span class="string">"by this way"</span></span><br></pre></td></tr></table></figure>
<h1 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"># <span class="number">1.</span> == 和 != 优先级高于位操作符 &amp; | ^</span><br><span class="line"><span class="keyword">if</span> ((x &amp; MASK) == <span class="number">0</span>)        <span class="comment">// (x &amp; MASK) 括号不能省!</span></span><br><span class="line"><span class="keyword">if</span> ( x &amp; y == <span class="number">0</span>)            <span class="comment">// 含义为 x &amp; (y==0)</span></span><br><span class="line"></span><br><span class="line"># <span class="number">2.</span> 赋值运算符优先级最低 (只比逗号高一级别)</span><br><span class="line"><span class="keyword">if</span> ((c = getchar()) != EOF) <span class="comment">// c获得输入值, 然后判断是否是结束符</span></span><br><span class="line"><span class="keyword">if</span> (c = getchar() != EOF)   <span class="comment">// 含义为 c = (getchar() != EOF), 所以c的赋值为 TRUE 或者 FALSE</span></span><br><span class="line"></span><br><span class="line"># <span class="number">3.</span> &amp;&amp; 的优先级 高于 ||</span><br><span class="line"><span class="keyword">if</span> ((cond1 || cond2) &amp;&amp; cond3)  <span class="comment">// 先或再与</span></span><br><span class="line"><span class="keyword">if</span> (cond1 || cond2 &amp;&amp; cond3)    <span class="comment">// 含义为 cond1 || (cond2 &amp;&amp; cond3)</span></span><br><span class="line"></span><br><span class="line"># <span class="number">4.</span> 算数运算优先级高于位移运算</span><br><span class="line">(msb &lt;&lt; <span class="number">4</span>) + lsb            <span class="comment">// 先位移, 再做加法</span></span><br><span class="line">msb &lt;&lt; <span class="number">4</span> + lsb              <span class="comment">// 含义为 msb &lt;&lt; (4 + lsb)</span></span><br><span class="line"></span><br><span class="line"># <span class="number">5.</span> 先-&gt;/./&amp;, 然后++/--, 最后 *,</span><br><span class="line">++p-&gt;len                    <span class="comment">// ++(p-&gt;len), len值++</span></span><br><span class="line">p-&gt;len++                    <span class="comment">// (p-&gt;len)++, len值++</span></span><br><span class="line">(++p)-&gt;len                  <span class="comment">// 先加p的值, 然后取len值</span></span><br><span class="line">p++-&gt;len                    <span class="comment">// (p++)-&gt;len 先加p的值, 然后取len值</span></span><br><span class="line">p-&gt;++len                    <span class="comment">// p-&gt;(++len) 语法错误, 不知道len是什么!</span></span><br><span class="line"></span><br><span class="line">++*p                        <span class="comment">// ++(*p), 内容++</span></span><br><span class="line">(*p)++                      <span class="comment">// 内容++</span></span><br><span class="line">*p++                        <span class="comment">// *(p++), 地址++, 然后取内容</span></span><br><span class="line"></span><br><span class="line">++*p-&gt;str                   <span class="comment">// ++(*p-&gt;str). str指向的内容++</span></span><br><span class="line">(*p-&gt;str)++                 <span class="comment">// str指向的内容++</span></span><br><span class="line">*p-&gt;str++                   <span class="comment">// *(p-&gt;str), (p-&gt;str)++. 取出str的内容, 然后str地址++</span></span><br><span class="line">*p++-&gt;str                   <span class="comment">// *p-&gt;str, p++. 取出str的内容, 然后p++</span></span><br><span class="line">*++p-&gt;str                   <span class="comment">// *(++p-&gt;str). str地址++, 然后取str的内容</span></span><br><span class="line">*p-&gt;++str                   <span class="comment">// *p-&gt;(++str) 语法错误, 不知道str是什么!</span></span><br><span class="line"></span><br><span class="line">++*p.len                    <span class="comment">// ++*(p.len), 多数情况下p是指针, 因此语法错误</span></span><br><span class="line">++(*p).len                  <span class="comment">// ++(p-&gt;len), str值++</span></span><br><span class="line">(*p++).len                  <span class="comment">// p++-&gt;len, p地址++, 然后取str值</span></span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>优先级</th>
<th>运算符</th>
<th>说明</th>
<th>结合方向</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>后置 <code>++</code> <code>--</code></td>
<td>自增++ 自减–</td>
<td>左到右</td>
</tr>
<tr>
<td>　　</td>
<td><code>[]</code></td>
<td>数组下标</td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>()</code></td>
<td>（表达式）/函数名(形参表)</td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>.</code></td>
<td>对象.成员名</td>
<td></td>
</tr>
<tr>
<td>　</td>
<td><code>-&gt;</code></td>
<td>对象指针-&gt;成员名</td>
<td>　</td>
</tr>
<tr>
<td>2</td>
<td><code>-</code></td>
<td>负号</td>
<td>右到左</td>
</tr>
<tr>
<td></td>
<td><code>(类型)</code></td>
<td>强制类型转换</td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>++</code> <code>--</code> 前置</td>
<td>++自增 –自减</td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>*</code></td>
<td>*指针表达式</td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>&amp;</code></td>
<td>&amp;左值表达式</td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>!</code></td>
<td>!表达式</td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>~</code></td>
<td>~表达式</td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>sizeof</code></td>
<td>sizeof 表达式/sizeof(类型)</td>
<td></td>
</tr>
<tr>
<td>　3</td>
<td><code>*</code> <code>/</code> <code>%</code></td>
<td>乘 除 取余</td>
<td>左到右</td>
</tr>
<tr>
<td>4</td>
<td><code>+</code> <code>-</code></td>
<td>加 减</td>
<td>左到右</td>
</tr>
<tr>
<td>5</td>
<td><code>&lt;&lt;</code> <code>&gt;&gt;</code></td>
<td>左移 右移</td>
<td>左到右</td>
</tr>
<tr>
<td>6</td>
<td><code>&gt;</code> <code>&gt;=</code> <code>&lt;</code> <code>&lt;=</code></td>
<td>大于(等于) 小于(等于)</td>
<td>左到右</td>
</tr>
<tr>
<td>7</td>
<td><code>==</code> <code>!=</code></td>
<td>等于 不等于</td>
<td>左到右</td>
</tr>
<tr>
<td>8</td>
<td><code>&amp;</code></td>
<td>按位与</td>
<td>左到右</td>
</tr>
<tr>
<td>9</td>
<td><code>^</code></td>
<td>按位异或</td>
<td>左到右</td>
</tr>
<tr>
<td>10</td>
<td><code>l</code> (竖杠)</td>
<td>按位或</td>
<td>左到右</td>
</tr>
<tr>
<td>11</td>
<td><code>&amp;&amp;</code></td>
<td>逻辑与</td>
<td>左到右</td>
</tr>
<tr>
<td>12</td>
<td><code>ll</code> (竖杠)</td>
<td>逻辑或</td>
<td>左到右</td>
</tr>
<tr>
<td>13</td>
<td><code>?:</code></td>
<td>表达式1? 表达式2: 表达式3</td>
<td>右到左</td>
</tr>
<tr>
<td>14</td>
<td><code>=</code> <code>/=</code> <code>*=</code> <code>%=</code> <code>+=</code> <code>-=</code></td>
<td>赋值运算符</td>
<td>右到左</td>
</tr>
<tr>
<td></td>
<td><code>&lt;&lt;=</code> <code>&gt;&gt;=</code> <code>&amp;=</code> <code>^=</code> <code>l=</code> (竖杠)</td>
<td>位赋值运算符</td>
<td></td>
</tr>
<tr>
<td>15</td>
<td><code>,</code></td>
<td>表达式,表达式,…</td>
<td>左到右</td>
</tr>
</tbody>
</table>
<h1 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以 const 为例, volitale是一样的.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>;          <span class="comment">// int是const</span></span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span>;          <span class="comment">// int是const</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>*;        <span class="comment">// char是const</span></span><br><span class="line"><span class="keyword">char</span> <span class="keyword">const</span>*;        <span class="comment">// char是const</span></span><br><span class="line"><span class="keyword">char</span>* <span class="keyword">const</span>;        <span class="comment">// *(指针)是const</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span>;  <span class="comment">// char和*都是const</span></span><br><span class="line"><span class="keyword">char</span> <span class="keyword">const</span>* <span class="keyword">const</span>;  <span class="comment">//char和*都是const</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>register</code>, 建议编译器把该变量直接放到寄存器中, 而不是内存中. 以提高运算速度!<ul>
<li>注意, 只是<strong>建议</strong>, 因此编译器可以忽略这个关键字</li>
<li>变量必须是能被CPU寄存器接收的数据类型, 如 <code>int</code></li>
<li>现代编译器的优化效率很高, 因此 <code>register</code> 很少使用.</li>
<li><strong>还有一点</strong>. 譬如 <code>register int val;</code> 这时 <code>&amp;val</code> 会报错! 因为取的是内存地址, 而val是在寄存器内, 所以不存在内存地址!</li>
</ul>
</li>
<li><code>auto</code>, 老版本C用于声明这是一个局部变量(与<code>static</code>相反). 新版本用于声明一个自动类型的变量.<ul>
<li>这个关键字是真没人去用. 因为函数内默认就是局部变量.</li>
<li>习惯写C的人, 基本习惯了先选好一个数据类型.</li>
</ul>
</li>
</ul>
<h1 id="宏定义"><a href="#宏定义" class="headerlink" title="宏定义"></a>宏定义</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// #, Stringfication! 将宏变量直接转变为字符串(加上双引号)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> debug(v)        printf(#v <span class="meta-string">"=%x\n"</span>, v)</span></span><br><span class="line"></span><br><span class="line">debug(value);           <span class="comment">// 宏展开为 printf("value" "=%x\n", value)</span></span><br><span class="line">                        <span class="comment">// 若value值为0xFF, 执行结果就是打印出: value=0xFF</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// ##, Concatenator! 宏变量连接符, 多用于自动生成变量名</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CAT(x,y)        x##y</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LINK(a,b,c)     a##_##b##_##c</span></span><br><span class="line"></span><br><span class="line">CAT(var, <span class="number">12</span>);           <span class="comment">// 宏展开为 var12</span></span><br><span class="line">LINK(name,age,sex);     <span class="comment">// 宏展开为 name_age_sex</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// __VA_ARGS__, 宏定义可变参数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DRV_DEBUG 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DRV_DEBUG</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> DRV_PRINT(fmt, ...) printf(fmt, __VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> DRV_PRINT(fmt, ...)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译器内置的宏定义:</span></span><br><span class="line">__LINE__                <span class="comment">// 在源代码中插入当前源代码行号；</span></span><br><span class="line">__FILE__                <span class="comment">// 在源文件中插入当前源文件名；</span></span><br><span class="line">__DATE__                <span class="comment">// 在源文件中插入当前的编译日期</span></span><br><span class="line">__TIME__                <span class="comment">// 在源文件中插入当前编译时间；</span></span><br><span class="line">__STDC__                <span class="comment">// 当要求程序严格遵循ANSI C标准时该标识被赋值为1；</span></span><br><span class="line">__cplusplus             <span class="comment">// 当编写C++程序时该标识符被定义。</span></span><br></pre></td></tr></table></figure>
<h1 id="typedef-的用法"><a href="#typedef-的用法" class="headerlink" title="typedef 的用法"></a>typedef 的用法</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 我习惯将所有typedef定义为形如 uint8_t, 即已 "_t" 结尾</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">&#125; <span class="keyword">point_t</span>;                          <span class="comment">// 数据结构</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*<span class="keyword">pfun_t</span>)</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;    <span class="comment">// 函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> <span class="keyword">array80_t</span>[<span class="number">80</span>];         <span class="comment">// 数组</span></span><br></pre></td></tr></table></figure>
<h1 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *name[] = &#123; <span class="string">"None"</span>, <span class="string">"Jan"</span>, <span class="string">"Feb"</span>, <span class="string">"Mar"</span> &#125;;     <span class="comment">// 指针数组 name</span></span><br><span class="line"><span class="keyword">int</span> *daytab[<span class="number">13</span>];    <span class="comment">// 指针数组 daytab</span></span><br><span class="line"><span class="keyword">int</span> (*daytab)[<span class="number">13</span>];  <span class="comment">// 数组指针 daytab, 譬如 int a[3][13], 则可以 p=a; p++后就指向了 &amp;a[1][0]</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">f</span><span class="params">()</span></span>;           <span class="comment">// f 函数的返回值为指针类型</span></span><br><span class="line"><span class="keyword">int</span> (*pf)();        <span class="comment">// 函数指针 pf</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这两个是极端复杂的例子, 实际代码建议先用 typedef 定义好一层, 然后再嵌套使用, 会容易理解的多!</span></span><br><span class="line"><span class="keyword">char</span> (*(*x[<span class="number">3</span>])())[<span class="number">5</span>];   <span class="comment">// x: array[3] of pointer to function returning pointer to array[5] of char</span></span><br><span class="line">                        <span class="comment">// x,一个指针数组, 这些指针指向函数, 函数的返回值是数组指针...</span></span><br><span class="line"><span class="keyword">char</span> (*(*x())[])();     <span class="comment">// x: function returning pointer to array[] of pointer to function returning char</span></span><br><span class="line">                        <span class="comment">// x,一个函数, 返回值为一个指针. 这个指针指向一个函数指针列表. 函数指针列表指向的函数是返回 char 类型的.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 举个例子 -----&gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">foo</span><span class="params">()</span>    </span>&#123; <span class="keyword">return</span> <span class="string">'a'</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">bar</span><span class="params">()</span>    </span>&#123; <span class="keyword">return</span> <span class="string">'b'</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">blurga</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">'c'</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">bletch</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">'d'</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> (*gfunclist[])() = &#123;foo, bar, blurga, bletch&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> (*(*x())[])()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="title">char</span> <span class="params">(*funclist[<span class="number">4</span>])</span><span class="params">()</span> </span>= &#123;foo, bar, blurga, bletch&#125;;</span><br><span class="line">    <span class="keyword">return</span> &amp;funclist;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%c\n"</span>,gfunclist[<span class="number">0</span>]());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> (*(*fs)[<span class="number">4</span>])();</span><br><span class="line">    fs = x();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%c\n"</span>,(*fs)[<span class="number">1</span>]());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更容易读懂的版本 -----&gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">char</span> <span class="params">(*<span class="keyword">pfun_t</span>)</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">foo</span><span class="params">()</span>    </span>&#123; <span class="keyword">return</span> <span class="string">'a'</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">bar</span><span class="params">()</span>    </span>&#123; <span class="keyword">return</span> <span class="string">'b'</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">blurga</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">'c'</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">bletch</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">'d'</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pfun_t</span> gfunclist[] = &#123;foo, bar, blurga, bletch&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pfun_t</span>* x()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">pfun_t</span> funclist[<span class="number">4</span>] = &#123;foo, bar, blurga, bletch&#125;;</span><br><span class="line">    <span class="keyword">return</span> funclist;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%c\n"</span>,gfunclist[<span class="number">0</span>]());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pfun_t</span> *fs;</span><br><span class="line">    fs = x();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%c\n"</span>,fs[<span class="number">1</span>]());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="结构体和位域"><a href="#结构体和位域" class="headerlink" title="结构体和位域"></a>结构体和位域</h1><ul>
<li><code>Bit-fields</code> 位域, 一般不建议使用. 编译器相关且机器相关, 因此可移植性很差.</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> is;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> keyword : <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="keyword">extern</span> : <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="keyword">static</span> : <span class="number">1</span>;</span><br><span class="line">    &#125; flags;</span><br><span class="line">&#125; bit_union;</span><br></pre></td></tr></table></figure>
<h1 id="printf-及-scanf"><a href="#printf-及-scanf" class="headerlink" title="printf 及 scanf"></a>printf 及 scanf</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 打印任意字符串的安全方法</span></span><br><span class="line"><span class="built_in">printf</span>(s);                      <span class="comment">// FAILS if s contains %</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s"</span>, s);                <span class="comment">// SAFE</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用可变参数的方法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">minprintf</span><span class="params">(<span class="keyword">char</span> *fmt, ...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    va_list ap; <span class="comment">/* points to each unnamed arg in turn */</span></span><br><span class="line">    va_start(ap, fmt); <span class="comment">/* make ap point to 1st unnamed arg */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// do something ...</span></span><br><span class="line">    ival = va_arg(ap, <span class="keyword">int</span>);</span><br><span class="line">    <span class="comment">// do something ...</span></span><br><span class="line"></span><br><span class="line">    va_end(ap);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 宏定义 printf</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DRV_PRINT(fmt, ...) printf(fmt, __VA_ARGS__)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// scanf 避免溢出的方法</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>, buf);               <span class="comment">// 可能溢出!</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%20s"</span>, buf);             <span class="comment">// 最多读取20个字符串</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 自己写个scanner.</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">scanner</span><span class="params">(<span class="keyword">char</span> *buffer, <span class="keyword">size_t</span> buflen)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> format[<span class="number">32</span>];</span><br><span class="line">    <span class="keyword">if</span> (buflen == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">snprintf</span>(format, <span class="keyword">sizeof</span>(format), <span class="string">"%%%ds"</span>, (<span class="keyword">int</span>)(buflen<span class="number">-1</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">scanf</span>(format, buffer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="http://net.pku.edu.cn/~course/cs101/2008/resource/The_C_Programming_Language.pdf" target="_blank" rel="noopener">The C programming Language</a></li>
<li>[Cheat Sheets of the C standard library][<a href="http://ws3.ntcu.edu.tw/ACS099133/cheatsheet/c-libraries-cheatsheet.pdf" target="_blank" rel="noopener">http://ws3.ntcu.edu.tw/ACS099133/cheatsheet/c-libraries-cheatsheet.pdf</a>]</li>
</ul>
<hr>
<p><strong><em>原创于 <a href="https://draapho.github.io/">DRA&amp;PHO</a></em></strong></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/9/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><span class="page-number current">10</span><a class="page-number" href="/page/11/">11</a><span class="space">&hellip;</span><a class="page-number" href="/page/18/">18</a><a class="extend next" rel="next" href="/page/11/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="//schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.jpg"
               alt="draapho" />
          <p class="site-author-name" itemprop="name">draapho</p>
          <p class="site-description motion-element" itemprop="description">Embedded System, IoT, M2M</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">122</span>
              <span class="site-state-item-name">posts</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">12</span>
                <span class="site-state-item-name">categories</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">80</span>
                <span class="site-state-item-name">tags</span>
              
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://au.linkedin.com/in/kim-huanqing-yu-67424638" target="_blank" title="Linkedin">
                  
                    <i class="fa fa-fw fa-linkedin-square"></i>
                  
                  Linkedin
                </a>
              </span>
            
          
        </div>

        
        

        
        

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">draapho</span>
</div>

<div class="powered-by">
  Powered by <a class="theme-link" href="https://hexo.io">Hexo</a>
</div>

<div class="theme-info">
  Theme -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.2"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.2"></script>



  



  




  
  
  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length == 0) {
       search_path = "search.xml";
    }
    var path = "/" + search_path;
    // monitor main search box;

    function proceedsearch() {
      $("body").append('<div class="popoverlay">').css('overflow', 'hidden');
      $('.popup').toggle();

    }
    // search function;
    var searchFunc = function(path, search_id, content_id) {
    'use strict';
    $.ajax({
        url: path,
        dataType: "xml",
        async: true,
        success: function( xmlResponse ) {
            // get the contents from search data
            isfetched = true;
            $('.popup').detach().appendTo('.header-inner');
            var datas = $( "entry", xmlResponse ).map(function() {
                return {
                    title: $( "title", this ).text(),
                    content: $("content",this).text(),
                    url: $( "url" , this).text()
                };
            }).get();
            var $input = document.getElementById(search_id);
            var $resultContent = document.getElementById(content_id);
            $input.addEventListener('input', function(){
                var matchcounts = 0;
                var str='<ul class=\"search-result-list\">';
                var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                $resultContent.innerHTML = "";
                if (this.value.trim().length > 1) {
                // perform local searching
                datas.forEach(function(data) {
                    var isMatch = false;
                    var content_index = [];
                    var data_title = data.title.trim().toLowerCase();
                    var data_content = data.content.trim().replace(/<[^>]+>/g,"").toLowerCase();
                    var data_url = decodeURIComponent(data.url);
                    var index_title = -1;
                    var index_content = -1;
                    var first_occur = -1;
                    // only match artiles with not empty titles and contents
                    if(data_title != '') {
                        keywords.forEach(function(keyword, i) {
                            index_title = data_title.indexOf(keyword);
                            index_content = data_content.indexOf(keyword);
                            if( index_title >= 0 || index_content >= 0 ){
                                isMatch = true;
								if (i == 0) {
                                    first_occur = index_content;
                                }
                            } 
							
                        });
                    }
                    // show search results
                    if (isMatch) {
                        matchcounts += 1;
                        str += "<li><a href='"+ data_url +"' class='search-result-title'>"+ data_title +"</a>";
                        var content = data.content.trim().replace(/<[^>]+>/g,"");
                        if (first_occur >= 0) {
                            // cut out 100 characters
                            var start = first_occur - 20;
                            var end = first_occur + 80;
                            if(start < 0){
                                start = 0;
                            }
                            if(start == 0){
                                end = 50;
                            }
                            if(end > content.length){
                                end = content.length;
                            }
                            var match_content = content.substring(start, end);
                            // highlight all keywords
                            keywords.forEach(function(keyword){
                                var regS = new RegExp(keyword, "gi");
                                match_content = match_content.replace(regS, "<b class=\"search-keyword\">"+keyword+"</b>");
                            });

                            str += "<p class=\"search-result\">" + match_content +"...</p>"
                        }
                        str += "</li>";
                    }
                })};
                str += "</ul>";
                if (matchcounts == 0) { str = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>' }
                if (keywords == "") { str = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>' }
                $resultContent.innerHTML = str;
            });
            proceedsearch();
        }
    });}

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched == false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };

    });

    $('.popup-btn-close').click(function(e){
      $('.popup').hide();
      $(".popoverlay").remove();
      $('body').css('overflow', '');
    });
    $('.popup').click(function(e){
      e.stopPropagation();
    });
  </script>


  

  

  

  


</body>
</html>
