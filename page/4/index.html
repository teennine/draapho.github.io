<!doctype html>




<html class="theme-next mist">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.2" />






<meta name="description" content="Embedded System, IoT, M2M">
<meta property="og:type" content="website">
<meta property="og:title" content="DRA&amp;PHO">
<meta property="og:url" content="https://draapho.github.io/page/4/index.html">
<meta property="og:site_name" content="DRA&amp;PHO">
<meta property="og:description" content="Embedded System, IoT, M2M">
<meta property="og:locale" content="en">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="DRA&amp;PHO">
<meta name="twitter:description" content="Embedded System, IoT, M2M">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: false,
    duoshuo: {
      userId: '0',
      author: 'Author'
    }
  };
</script>




  <link rel="canonical" href="https://draapho.github.io/page/4/"/>


  <title> DRA&PHO </title>
</head>

<body itemscope itemtype="//schema.org/WebPage" lang="en">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="//schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">DRA&PHO</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">thinking & logging</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            Categories
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            Search
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup">
 <span class="search-icon fa fa-search"></span>
 <input type="text" id="local-search-input">
 <div id="local-search-result"></div>
 <span class="popup-btn-close">close</span>
</div>


    </div>
  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/01/26/1812-drv-nor/" itemprop="url">
                  驱动之NOR Flash
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2018-01-26T00:00:00+11:00" content="2018-01-26">
              2018-01-26
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/embedded-linux/" itemprop="url" rel="index">
                    <span itemprop="name">embedded linux</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h1><ul>
<li><a href="https://draapho.github.io/2017/11/23/1734-linux-content/">嵌入式linux学习目录</a></li>
<li><a href="https://draapho.github.io/2018/01/22/1809-drv-blk/">驱动之块设备-框架</a></li>
<li><a href="https://draapho.github.io/2018/01/24/1810-drv-nand1/">驱动之NAND Flash框架</a></li>
<li><a href="https://draapho.github.io/2018/01/25/1811-drv-nand2/">驱动之NAND Flash源码</a></li>
<li><a href="https://draapho.github.io/2018/01/26/1812-drv-nor/">驱动之NOR Flash</a></li>
<li><a href="https://draapho.github.io/2018/02/06/1813-drv-net/">驱动之网卡驱动</a></li>
</ul>
<p>本文使用 linux-2.6.22.6 内核, 使用jz2440开发板.</p>
<h1 id="NOR-Flash-基础知识"><a href="#NOR-Flash-基础知识" class="headerlink" title="NOR Flash 基础知识"></a>NOR Flash 基础知识</h1><h2 id="NAND-和-NOR-Flash的比较"><a href="#NAND-和-NOR-Flash的比较" class="headerlink" title="NAND 和 NOR Flash的比较"></a>NAND 和 NOR Flash的比较</h2><table>
<thead>
<tr>
<th>NOR FLASH</th>
<th>NAND FLASH</th>
</tr>
</thead>
<tbody>
<tr>
<td>接口时序同SRAM,易使用</td>
<td>地址/数据线复用，数据位较窄</td>
</tr>
<tr>
<td>读取速度较快</td>
<td>读取速度较慢</td>
</tr>
<tr>
<td>擦除速度慢，以64-128KB的块为单位</td>
<td>擦除速度快，以8－32KB的块为单位</td>
</tr>
<tr>
<td>写入速度慢</td>
<td>写入速度快</td>
</tr>
<tr>
<td>随机存取速度较快，支持XIP(eXecute In Place，芯片内执行)，适用于代码存储。在嵌入式系统中，常用于存放引导程序、根文件系统等。</td>
<td>顺序读取速度较快，随机存取速度慢，适用于数据存储(如大容量的多媒体应用)。在嵌入式系统中，常用于存放用户文件系统等。</td>
</tr>
<tr>
<td>单片容量较小，1-32MB</td>
<td>单片容量较大，8-128MB，提高了单元密度</td>
</tr>
<tr>
<td>最大擦写次数10万次</td>
<td>最大擦写次数100万次</td>
</tr>
</tbody>
</table>
<h2 id="硬件接口"><a href="#硬件接口" class="headerlink" title="硬件接口"></a>硬件接口</h2><p>看相关数据手册, 以jz2440v3开发板为例:</p>
<ul>
<li><code>MX29LV160DBTI-70G.pdf</code> NOR Flash 数据手册</li>
<li><code>S3C2440A_UserManual_Rev13.pdf</code> CPU 数据手册</li>
</ul>
<p><img src="https://draapho.github.io/images/1812/nor1.JPG" alt="nor1.png"></p>
<p>注意几点:</p>
<ul>
<li>NOR Flash 的特性和RAM一样, 可以直接用物理地址来操作.<ul>
<li>当开发板以NOR Flash启动时, 0开始的地址就是指向NOR Flash的.</li>
</ul>
</li>
<li>NOR Flash 数据位宽有两种接法, 16bit 和 8bit. jz2440用的16bit接法<ul>
<li>因此, 用uboot测试时, 需要使用 <code>mw.w</code> <code>md.w</code> 来操作内存地址</li>
<li><code>mw</code> Memory Write. uboot下的写内存指令</li>
<li><code>md</code> Memory Display. uboot下的读内存指令</li>
<li>使用16bit接法时, CPU的地址线0是不接的. 因而指令上有个错位.</li>
<li>譬如: jz2440发出 (555h&lt;&lt;1), NOR Flash才能收到555h这个地址.</li>
</ul>
</li>
<li>NOR Flash 有两种模式, jedec, cfi<ul>
<li>jedec, 无法直接从芯片内读取详细信息, 需要根据芯片ID软件查表.</li>
<li>cfi, Common Flash Interface, 可以直接查询芯片详细信息.</li>
<li>目前大多数 NOR Flash 都支持 cfi 规范.</li>
</ul>
</li>
</ul>
<h2 id="读写实验"><a href="#读写实验" class="headerlink" title="读写实验"></a>读写实验</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 开发板 uboot 命令行, 确保是从 NOR Flash 启动的uboot!</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取 ID. 2440的A1接到NOR的A0，所以2440发出的地址全部要左移一位</span></span><br><span class="line">mw.w aaa aa             <span class="comment"># Addr = 555&lt;&lt;1</span></span><br><span class="line">mw.w 554 55             <span class="comment"># Addr = 2AA&lt;&lt;1</span></span><br><span class="line">mw.w aaa 90             <span class="comment"># Addr = 555&lt;&lt;1</span></span><br><span class="line">md.w 0 1</span><br><span class="line"><span class="comment"># 显示 00c2, Manifacture ID</span></span><br><span class="line">md.w 2 1                <span class="comment"># Addr = 1&lt;&lt;1</span></span><br><span class="line"><span class="comment"># 显示 2249, 表示型号 MX29LV160DB</span></span><br><span class="line">mw.w 0 f0               <span class="comment"># Reset Mode, 退出读ID</span></span><br></pre></td></tr></table></figure>
<h1 id="NOR-Flash-系统框架"><a href="#NOR-Flash-系统框架" class="headerlink" title="NOR Flash 系统框架"></a>NOR Flash 系统框架</h1><h2 id="系统自带驱动"><a href="#系统自带驱动" class="headerlink" title="系统自带驱动"></a>系统自带驱动</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Ubuntu 主机端</span></span><br><span class="line"><span class="comment"># pwd = ./linux-2.6.22.6</span></span><br><span class="line"></span><br><span class="line">$ make clean</span><br><span class="line">$ make menuconfig                                       <span class="comment"># 增加对NOR Flash的支持</span></span><br><span class="line"><span class="comment"># -&gt; Device Drivers</span></span><br><span class="line"><span class="comment">#   -&gt; Memory Technology Device (MTD) support</span></span><br><span class="line"><span class="comment">#     -&gt; Mapping drivers for chip access</span></span><br><span class="line"><span class="comment">#       &lt;M&gt; CFI Flash device in physical memory map     # CFI NOR Flash, 直接做物理映射就可以了</span></span><br><span class="line"><span class="comment">#       (0x0) Physical start address of flash mapping   # 物理基地址, 从0开始的</span></span><br><span class="line"><span class="comment">#       (0x2000000) Physical length of flash mapping    # 要映射的长度, 就是芯片的大小</span></span><br><span class="line"><span class="comment">#       (2)   Bank width in octets (NEW)                # 数据线位宽, 2就是2字节,  16bit</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 比较 .config 会发现多了如下配置. 从而可以找到文件 "drivers/mtd/chips/phram.c"</span></span><br><span class="line"><span class="comment"># CONFIG_MTD_PHYSMAP=m</span></span><br><span class="line"><span class="comment"># CONFIG_MTD_PHYSMAP_START=0</span></span><br><span class="line"><span class="comment"># CONFIG_MTD_PHYSMAP_LEN=0x2000000</span></span><br><span class="line"><span class="comment"># CONFIG_MTD_PHYSMAP_BANKWIDTH=2</span></span><br><span class="line"></span><br><span class="line">$ make modules                                          <span class="comment"># 会生成 physmap.ko</span></span><br><span class="line">cp ./drivers/mtd/maps/physmap.ko ~/share/jz2440/drivers/nor/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 开发板端, 开始测试</span></span><br><span class="line"><span class="comment"># pwd = ~/share/jz2440/drivers/nor/                     # NOR flash驱动目录, nfs</span></span><br><span class="line">$ ls /dev/mtd*                                          <span class="comment"># 查看一下mtd现有设备</span></span><br><span class="line">$ insmod physmap.ko                                     <span class="comment"># 加载驱动</span></span><br><span class="line">$ ls /dev/mtd*                                          <span class="comment"># 增加了若干mtd设备</span></span><br><span class="line">$ cat /proc/mtd</span><br></pre></td></tr></table></figure>
<h2 id="框架分析"><a href="#框架分析" class="headerlink" title="框架分析"></a>框架分析</h2><p>其基本框架和 NAND Flash 是一样的</p>
<p><img src="https://draapho.github.io/images/1812/nor2.png" alt="nor2.png"></p>
<p>下面, 分析一下 CFI NOR Flash 的内核代码框架</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// -----&gt; /drivers/mtd/maps/physmap.c</span></span><br><span class="line">module_init(physmap_init)</span><br><span class="line">    platform_driver_register(&amp;physmap_flash_driver);    <span class="comment">// 上来就是自己玩platform框架</span></span><br><span class="line">    platform_device_register(&amp;physmap_flash);</span><br><span class="line"></span><br><span class="line"># 匹配后, 自然是调用probe函数</span><br><span class="line">physmap_flash_probe</span><br><span class="line">    probe_type = rom_probe_types;                       <span class="comment">// "cfi_probe" "jedec_probe" 都是用于NOR Flash的</span></span><br><span class="line">    do_map_probe(*probe_type, &amp;info-&gt;<span class="built_in">map</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// -----&gt; /drivers/mtd/chips/chipreg.c</span></span><br><span class="line">    do_map_probe</span><br><span class="line">        drv = get_mtd_chip_driver(name);</span><br><span class="line">            list_entry(pos, typeof(*<span class="keyword">this</span>), <span class="built_in">list</span>)        <span class="comment">// this 是 mtd_chip_driver 类型</span></span><br><span class="line">        drv-&gt;probe(<span class="built_in">map</span>);</span><br><span class="line">        <span class="comment">// 搜索 mtd_chip_driver 查看来源. 可以猜出和文件 cfi_probe.c 有关.</span></span><br><span class="line">        <span class="comment">// 实际调用了 cfi_probe      // -----&gt; drivers/mtd/chips/cfi_probe.c</span></span><br><span class="line">    <span class="comment">// -----&gt; 结束, chipreg.c</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// add_mtd_partitions                               // 有分区则进行分区, 最终也会调用 add_mtd_device</span></span><br><span class="line">    add_mtd_device                                      <span class="comment">// 添加mtd设备</span></span><br><span class="line">    <span class="comment">// 然后就会跳到 mtdcore.c 后面和 NAND Flash 一样了. 或参考下面的一个例子</span></span><br><span class="line">    <span class="comment">// 最终会去注册 字符设备 和 块设备</span></span><br><span class="line"><span class="comment">// -----&gt; 结束, physmap.c</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// -----&gt; drivers/mtd/chips/cfi_probe.c</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">mtd_chip_driver</span> <span class="title">cfi_chipdrv</span>;</span>              <span class="comment">// .probe = cfi_probe</span></span><br><span class="line">cfi_probe</span><br><span class="line">    mtd_do_chip_probe(<span class="built_in">map</span>, &amp;cfi_chip_probe);            <span class="comment">// 识别cfi设备</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// -----&gt; drivers/mtd/chips/gen_probe.c</span></span><br><span class="line">    mtd_do_chip_probe</span><br><span class="line">        genprobe_ident_chips</span><br><span class="line">            cp-&gt;probe_chip                              <span class="comment">// 调用 cfi_chip_probe.probe_chip</span></span><br><span class="line">            <span class="comment">// 实际调用函数 cfi_probe_chip</span></span><br><span class="line">        check_cmd_set                                   <span class="comment">// 初始化 mtd_info 结构体</span></span><br><span class="line">    <span class="comment">// -----&gt; 结束, gen_probe.c</span></span><br><span class="line"></span><br><span class="line">cfi_probe_chip</span><br><span class="line">    cfi_send_gen_cmd                                    <span class="comment">// 发送CFI指令, 获取芯片信息</span></span><br><span class="line"><span class="comment">// -----&gt; 结束, cfi_probe.c</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// drivers/mtd/chips/jedec_probe.c 有 jedec_probe. 用于jedec设备</span></span><br><span class="line"><span class="comment">// drivers/mtd/chips/map_rom.c 有 map_rom_probe. 应该是用于CPU内置的ROM.</span></span><br></pre></td></tr></table></figure>
<p>这样就比较清楚了, 整个Linux代码尽可能的做到功能上的(代码上没有完全做到)分层分离.<br>大框架下有小框架. 譬如 NOR Flash 属于整个MTD大框架的一部分. 但其内部也有自己的一套小框架.</p>
<p>在 NOR Flash 这个例子里面,<br>将通用的底层驱动代码放在文件 <code>/drivers/mtd/maps/physmap.c</code><br>然后probe时, 具体的硬件操作被拆分三个部分 <code>cfi_probe.c</code> <code>jedec_probe.c</code> <code>map_rom.c</code><br>由于probe里面也有共性的东西, 又被提炼成 <code>gen_probe.c</code> 放在一起.</p>
<p>最后, 看一个最简单的例子, ram模拟mtd设备. 将底层硬件相关操作减到了最少.<br>这个RAM mtd设备和 NAND/NOR Flash 平级, 挂在 <code>mtdcore.c</code> 下.<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// -----&gt; /drivers/mtd/devices/phram.c</span></span><br><span class="line">module_param_call(phram, phram_setup, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="number">000</span>);         <span class="comment">// 由uboot传递参数进来</span></span><br><span class="line">phram_setup</span><br><span class="line">    register_device(name, start, len);</span><br><span class="line">        <span class="keyword">new</span>-&gt;mtd.XXX = XXX;                                     <span class="comment">// 初始化 mtd_info 结构体</span></span><br><span class="line">        add_mtd_device                                          <span class="comment">// 添加 mtd设备</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// -----&gt; /drivers/mtd/mtdcore.c                        // mtd 设备核心</span></span><br><span class="line">        add_mtd_device</span><br><span class="line">            <span class="keyword">not</span> = list_entry(<span class="keyword">this</span>, struct mtd_notifier, <span class="built_in">list</span>);  <span class="comment">// struct mtd_notifier 结构体是关键</span></span><br><span class="line">            <span class="keyword">not</span>-&gt;add(mtd);                                      <span class="comment">// 调用了add</span></span><br><span class="line">            <span class="comment">// 搜索 mtd_notifier 查看来源, 可知:</span></span><br><span class="line">            <span class="comment">// 实际调用了 mtd_notify_add         // -----&gt; drivers/mtd/mtdchar.c</span></span><br><span class="line">            <span class="comment">// 实际调用了 blktrans_notify_add    // -----&gt; drivers/mtd/mtd_blkdevs.c</span></span><br><span class="line">        <span class="comment">// -----&gt; 结束, mtdcore.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//可见, 核心内容就是 初始化mtd_info结构体, 然后 add_mtd_device</span></span><br><span class="line"><span class="comment">// -----&gt; 结束, phram.c</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// -----&gt; drivers/mtd/mtdchar.c                                 // 将mtd设备挂载成字符设备</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">mtd_notifier</span> <span class="title">notifier</span>;</span>                            <span class="comment">// .add = mtd_notify_add</span></span><br><span class="line">mtd_notify_add</span><br><span class="line">    class_device_create(<span class="string">"mtd%d"</span>)                                <span class="comment">// mtd字符设备, 可读写</span></span><br><span class="line">    class_device_create(<span class="string">"mtd%dro"</span>)                              <span class="comment">// mtd只读字符设备</span></span><br><span class="line">init_mtdchar                                                    <span class="comment">// mtdchar.c 的 module_init</span></span><br><span class="line">    register_chrdev(MTD_CHAR_MAJOR, <span class="string">"mtd"</span>, &amp;mtd_fops)           <span class="comment">// 注册为字符设备</span></span><br><span class="line"><span class="comment">// -----&gt; 结束, mtdchar.c 完成了字符设备的核心步骤.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// -----&gt; drivers/mtd/mtd_blkdevs.c                             // 将mtd设备挂载成块设备</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">mtd_notifier</span> <span class="title">blktrans_notifier</span>;</span>                   <span class="comment">// .add = blktrans_notify_add</span></span><br><span class="line">blktrans_notify_add</span><br><span class="line">    tr = list_entry(<span class="keyword">this</span>, struct mtd_blktrans_ops, <span class="built_in">list</span>);       <span class="comment">// 一样的, 搜索 mtd_blktrans_ops</span></span><br><span class="line">    tr-&gt;add_mtd(tr, mtd);</span><br><span class="line">    <span class="comment">// 可以找到两个文件有初始化, 很明显是块设备读写还是只读的区别. 选取 /drivers/mtd/mtdblock.c</span></span><br><span class="line">    <span class="comment">// 实际调用了 mtdblock_add_mtd</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// -----&gt; /drivers/mtd/mtdblock.c</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">mtd_blktrans_ops</span> <span class="title">mtdblock_tr</span>;</span>                 <span class="comment">// .add_mtd = mtdblock_add_mtd</span></span><br><span class="line">    mtdblock_add_mtd</span><br><span class="line">        add_mtd_blktrans_dev</span><br><span class="line">            alloc_disk                                          <span class="comment">// 分配 gendisk</span></span><br><span class="line">            add_disk                                            <span class="comment">// 注册为块设备</span></span><br><span class="line">    init_mtdblock                                               <span class="comment">// mtdblock.c 的 module_init</span></span><br><span class="line">        register_mtd_blktrans</span><br><span class="line">            register_blkdev                                     <span class="comment">// 获得主设备号</span></span><br><span class="line">            blk_init_queue                                      <span class="comment">// 设置缓冲队列</span></span><br><span class="line">    <span class="comment">// -----&gt; 结束, mtdblock.c 完成了块设备的核心步骤.</span></span><br><span class="line"><span class="comment">// -----&gt; 结束, mtd_blkdevs</span></span><br></pre></td></tr></table></figure></p>
<h1 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h1><h2 id="s3c-nor-c"><a href="#s3c-nor-c" class="headerlink" title="s3c_nor.c"></a>s3c_nor.c</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 参考 drivers\mtd\maps\physmap.c</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/slab.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/platform_device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/mtd/mtd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/mtd/map.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/mtd/partitions.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/io.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">"GPL"</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">"DRAAPHO"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">map_info</span> *<span class="title">s3c_nor_map</span>;</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">mtd_info</span> *<span class="title">s3c_nor_mtd</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">mtd_partition</span> <span class="title">s3c_nor_parts</span>[] = &#123;</span>             <span class="comment">// 复杂一点, 做一个分区信息</span></span><br><span class="line">    [<span class="number">0</span>] = &#123;</span><br><span class="line">        .name   = <span class="string">"bootloader_nor"</span>,</span><br><span class="line">        .size   = <span class="number">0x00040000</span>,</span><br><span class="line">        .offset = <span class="number">0</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    [<span class="number">1</span>] = &#123;</span><br><span class="line">        .name   = <span class="string">"root_nor"</span>,</span><br><span class="line">        .offset = MTDPART_OFS_APPEND,</span><br><span class="line">        .size   = MTDPART_SIZ_FULL,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">s3c_nor_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* 1. 分配map_info结构体 */</span></span><br><span class="line">    s3c_nor_map = kzalloc(<span class="keyword">sizeof</span>(struct map_info), GFP_KERNEL);;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 2. 设置: 物理基地址(phys), 大小(size), 位宽(bankwidth), 虚拟基地址(virt) */</span></span><br><span class="line">    s3c_nor_map-&gt;name = <span class="string">"s3c_nor"</span>;</span><br><span class="line">    s3c_nor_map-&gt;phys = <span class="number">0</span>;                                              <span class="comment">// 对应的物理地址</span></span><br><span class="line">    s3c_nor_map-&gt;size = <span class="number">0x2000000</span>;                                      <span class="comment">// NOR的容量</span></span><br><span class="line">    s3c_nor_map-&gt;bankwidth = <span class="number">2</span>;                                         <span class="comment">// 数据线位宽, 单位字节</span></span><br><span class="line">    s3c_nor_map-&gt;virt = ioremap(s3c_nor_map-&gt;phys, s3c_nor_map-&gt;size);  <span class="comment">// 对应的虚拟地址</span></span><br><span class="line">    simple_map_init(s3c_nor_map);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 3. 使用: 调用NOR FLASH协议层提供的函数来识别 */</span></span><br><span class="line">    printk(<span class="string">"use cfi_probe\n"</span>);</span><br><span class="line">    s3c_nor_mtd = do_map_probe(<span class="string">"cfi_probe"</span>, s3c_nor_map);               <span class="comment">// 直接去调用 .probe = cfi_probe</span></span><br><span class="line">    <span class="keyword">if</span> (!s3c_nor_mtd) &#123;</span><br><span class="line">        printk(<span class="string">"use jedec_probe\n"</span>);</span><br><span class="line">        s3c_nor_mtd = do_map_probe(<span class="string">"jedec_probe"</span>, s3c_nor_map);         <span class="comment">// 失败, 尝试 jedec 模式</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!s3c_nor_mtd) &#123;</span><br><span class="line">        iounmap(s3c_nor_map-&gt;virt);</span><br><span class="line">        kfree(s3c_nor_map);</span><br><span class="line">        <span class="keyword">return</span> -EIO;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 4. add_mtd_partitions */</span></span><br><span class="line">    add_mtd_partitions(s3c_nor_mtd, s3c_nor_parts, <span class="number">2</span>);                  <span class="comment">// 里面调用 add_mtd_device</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">s3c_nor_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    del_mtd_partitions(s3c_nor_mtd);</span><br><span class="line">    iounmap(s3c_nor_map-&gt;virt);</span><br><span class="line">    kfree(s3c_nor_map);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(s3c_nor_init);</span><br><span class="line">module_exit(s3c_nor_exit);</span><br></pre></td></tr></table></figure>
<h2 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h2><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">obj-m       := s3c_nor.o</span><br><span class="line">KERN_SRC    := /home/draapho/share/jz2440/kernel/linux-2.6.22.6/</span><br><span class="line">PWD         := <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"></span><br><span class="line"><span class="section">modules:</span></span><br><span class="line">    make -C <span class="variable">$(KERN_SRC)</span> M=<span class="variable">$(PWD)</span> modules</span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    make -C <span class="variable">$(KERN_SRC)</span> M=<span class="variable">$(PWD)</span> clean</span><br></pre></td></tr></table></figure>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Ubuntu 主机端</span></span><br><span class="line"><span class="comment"># pwd = ~/share/jz2440/drivers/nor/         # NOR flash驱动目录</span></span><br><span class="line">$ make modules                              <span class="comment"># 生成s3c_nor.ko</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 开发板端, 开始测试</span></span><br><span class="line"><span class="comment"># pwd = ~/share/jz2440/drivers/nor/         # NOR flash驱动目录, nfs</span></span><br><span class="line">$ ls /dev/mtd*                              <span class="comment"># 查看现有的mtd设备</span></span><br><span class="line">$ insmod s3c_nor.ko                         <span class="comment"># 加载驱动</span></span><br><span class="line">$ ls /dev/mtd*                              <span class="comment"># 查看新增的mtd设备</span></span><br><span class="line">$ flash_eraseall -j /dev/mtd5               <span class="comment"># 格式化为 jffs2, 注意新增的不一定是mtd5</span></span><br><span class="line">$ mount -t jffs2 /dev/mtdblock5 /mnt        <span class="comment"># 挂载这个设备到 /mnt</span></span><br><span class="line"><span class="comment"># 在 /mnt 下进行文件的创建和操作, 测试该文件系统.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果没有 flash_eraseall 指令, 则需要编译mtd格式化工具 mtd-utils</span></span><br><span class="line"><span class="comment"># Ubuntu 主机端</span></span><br><span class="line">$ tar xjf mtd-utils-05.07.23.tar.bz2</span><br><span class="line">$ <span class="built_in">cd</span> mtd-utils-05.07.23/util</span><br><span class="line">$ vim Makefile</span><br><span class="line">    <span class="comment"># ===== 文件内容, 修改如下内容: =====</span></span><br><span class="line">    <span class="comment">#CROSS=arm-linux-   # 需要交叉编译, 取消注释</span></span><br><span class="line">    CROSS=arm-linux-</span><br><span class="line">    <span class="comment"># ===== 结束修改, 保存退出vim =====</span></span><br><span class="line">$ make</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开发板端</span></span><br><span class="line"><span class="comment"># 通过nfs拷贝到bin目录下即可.</span></span><br><span class="line"><span class="comment"># pwd = ./mtd-utils-05.07.23/util           # nfs文件</span></span><br><span class="line">$ cp flash_erase flash_eraseall /bin</span><br></pre></td></tr></table></figure>
<hr>
<p><strong><em>原创于 <a href="https://draapho.github.io/">DRA&amp;PHO</a></em></strong></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/01/25/1811-drv-nand2/" itemprop="url">
                  驱动之NAND Flash源码
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2018-01-25T00:00:00+11:00" content="2018-01-25">
              2018-01-25
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/embedded-linux/" itemprop="url" rel="index">
                    <span itemprop="name">embedded linux</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h1><ul>
<li><a href="https://draapho.github.io/2017/11/23/1734-linux-content/">嵌入式linux学习目录</a></li>
<li><a href="https://draapho.github.io/2018/01/22/1809-drv-blk/">驱动之块设备-框架</a></li>
<li><a href="https://draapho.github.io/2018/01/24/1810-drv-nand1/">驱动之NAND Flash框架</a></li>
<li><a href="https://draapho.github.io/2018/01/25/1811-drv-nand2/">驱动之NAND Flash源码</a></li>
<li><a href="https://draapho.github.io/2018/01/26/1812-drv-nor/">驱动之NOR Flash</a></li>
<li><a href="https://draapho.github.io/2018/02/06/1813-drv-net/">驱动之网卡驱动</a></li>
</ul>
<p>本文使用 linux-2.6.22.6 内核, 使用jz2440开发板.</p>
<h1 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h1><p>由 <strong>nand flash 系统框架</strong> 分析可知, Linux内核系统以及完成了Nand Flash设备的绝大部分的核心工作.<br>因此Nand Flash驱动真正要做的工作主要就是:</p>
<ul>
<li>分配并初始化 <code>nand_chip</code> 结构体</li>
<li>初始化硬件</li>
<li>调用 <code>nand_scan</code></li>
<li>调用 <code>add_mtd_partitions</code></li>
</ul>
<p>可以参考内核文件的相关源码, 学着写.</p>
<ul>
<li><code>drivers\mtd\nand\at91_nand.c</code></li>
<li><code>drivers\mtd\nand\s3c2410.c</code></li>
</ul>
<p>流程如下图:<br><img src="https://draapho.github.io/images/1810/nand3.jpg" alt="nand3"></p>
<h2 id="s3c-nand-c"><a href="#s3c-nand-c" class="headerlink" title="s3c_nand.c"></a>s3c_nand.c</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/slab.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/platform_device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/mtd/mtd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/mtd/nand.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/mtd/partitions.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/clk.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/io.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/arch/regs-nand.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/arch/nand.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">"GPL"</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">"DRAAPHO"</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">s3c_nand_regs</span> &#123;</span>                              <span class="comment">// 2440芯片NAND Flash相关寄存器</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> nfconf  ;                         <span class="comment">// 物理地址 0x4E000000</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> nfcont  ;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> nfcmd   ;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> nfaddr  ;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> nfdata  ;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> nfeccd0 ;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> nfeccd1 ;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> nfeccd  ;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> nfstat  ;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> nfestat0;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> nfestat1;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> nfmecc0 ;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> nfmecc1 ;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> nfsecc  ;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> nfsblk  ;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> nfeblk  ;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">nand_chip</span> *<span class="title">s3c_nand</span>;</span>                  <span class="comment">// NAND Flash操作的核心结构体</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">mtd_info</span> *<span class="title">s3c_mtd</span>;</span>                    <span class="comment">// 给两个系统函数使用的结构体</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">s3c_nand_regs</span> *<span class="title">s3c_nand_regs</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">mtd_partition</span> <span class="title">s3c_nand_parts</span>[] = &#123;</span>    <span class="comment">// 分区信息</span></span><br><span class="line">    [<span class="number">0</span>] = &#123;</span><br><span class="line">        .name   = <span class="string">"bootloader"</span>,</span><br><span class="line">        .size   = <span class="number">0x00040000</span>,</span><br><span class="line">        .offset = <span class="number">0</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    [<span class="number">1</span>] = &#123;</span><br><span class="line">        .name   = <span class="string">"params"</span>,</span><br><span class="line">        .offset = MTDPART_OFS_APPEND,</span><br><span class="line">        .size   = <span class="number">0x00020000</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    [<span class="number">2</span>] = &#123;</span><br><span class="line">        .name   = <span class="string">"kernel"</span>,</span><br><span class="line">        .offset = MTDPART_OFS_APPEND,</span><br><span class="line">        .size   = <span class="number">0x00200000</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    [<span class="number">3</span>] = &#123;</span><br><span class="line">        .name   = <span class="string">"root"</span>,</span><br><span class="line">        .offset = MTDPART_OFS_APPEND,</span><br><span class="line">        .size   = MTDPART_SIZ_FULL,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不能用Linux默认的片选函数(nand_set_defaults), 自己根据数据手册写一下.</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">s3c2440_select_chip</span><span class="params">(struct mtd_info *mtd, <span class="keyword">int</span> chipnr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (chipnr == <span class="number">-1</span>) &#123;</span><br><span class="line">        s3c_nand_regs-&gt;nfcont |= (<span class="number">1</span>&lt;&lt;<span class="number">1</span>);            <span class="comment">// NFCONT bit1=1, 取消片选</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        s3c_nand_regs-&gt;nfcont &amp;= ~(<span class="number">1</span>&lt;&lt;<span class="number">1</span>);           <span class="comment">// NFCONT bit1=0, 使能片选</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">s3c2440_cmd_ctrl</span><span class="params">(struct mtd_info *mtd, <span class="keyword">int</span> dat, <span class="keyword">unsigned</span> <span class="keyword">int</span> ctrl)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ctrl &amp; NAND_CLE) &#123;</span><br><span class="line">        s3c_nand_regs-&gt;nfcmd = dat;                 <span class="comment">// NFCMMD=dat, 发送命令</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        s3c_nand_regs-&gt;nfaddr = dat;                <span class="comment">// NFADDR=dat, 发送地址</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">s3c2440_dev_ready</span><span class="params">(struct mtd_info *mtd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (s3c_nand_regs-&gt;nfstat &amp; (<span class="number">1</span>&lt;&lt;<span class="number">0</span>));        <span class="comment">// NFSTAT bit0=0, Busy else Ready</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">s3c_nand_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">clk</span> *<span class="title">clk</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 1. 分配nand_chip 和 mtd_info 结构体 */</span></span><br><span class="line">    s3c_nand = kzalloc(<span class="keyword">sizeof</span>(struct nand_chip), GFP_KERNEL);</span><br><span class="line">    s3c_mtd = kzalloc(<span class="keyword">sizeof</span>(struct mtd_info), GFP_KERNEL);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获得寄存器的虚拟地址. 0x4E000000是这些寄存器的起始物理地址</span></span><br><span class="line">    s3c_nand_regs = ioremap(<span class="number">0x4E000000</span>, <span class="keyword">sizeof</span>(struct s3c_nand_regs));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 2. 设置nand_chip */</span></span><br><span class="line">    <span class="comment">/* nand_chip 需要提供 NAND Flash 操作的基本函数. 通用的函数已经由 nand_set_defaults 设置好了.</span></span><br><span class="line"><span class="comment">     * 需要自己设置的函数主要有: 片选,发指令,发地址,发数据,读数据,判断状态的功能</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    s3c_nand-&gt;select_chip = s3c2440_select_chip;    <span class="comment">// 片选函数</span></span><br><span class="line">    s3c_nand-&gt;cmd_ctrl    = s3c2440_cmd_ctrl;       <span class="comment">// 发送指令/地址</span></span><br><span class="line">    s3c_nand-&gt;IO_ADDR_R   = &amp;s3c_nand_regs-&gt;nfdata; <span class="comment">// 读数据的虚拟地址</span></span><br><span class="line">    s3c_nand-&gt;IO_ADDR_W   = &amp;s3c_nand_regs-&gt;nfdata; <span class="comment">// 发数据的虚拟地址</span></span><br><span class="line">    s3c_nand-&gt;dev_ready   = s3c2440_dev_ready;      <span class="comment">// 芯片Busy/Ready的状态反馈</span></span><br><span class="line">    s3c_nand-&gt;ecc.mode    = NAND_ECC_SOFT;          <span class="comment">// ECC校验方式. 软件或硬件.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 3. 硬件相关的设置: 根据NAND FLASH的手册设置时间参数 */</span></span><br><span class="line">    <span class="comment">// 使能NAND控制器的时钟</span></span><br><span class="line">    clk = clk_get(<span class="literal">NULL</span>, <span class="string">"nand"</span>);                    <span class="comment">// 由名称"nand"获得时钟</span></span><br><span class="line">    clk_enable(clk);                                <span class="comment">// 实际上就是 CLKCON bit[4]=1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置 NFCONF 寄存器. 由启动的打印信息可获得 HCLK=100MHz, 设置时序要求.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TACLS    0  <span class="comment">// 发出CLE/ALE之后多长时间才发出nWE信号, 从NAND手册可知CLE/ALE与nWE可以同时发出,所以TACLS=0</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TWRPH0   1  <span class="comment">// nWE的脉冲宽度, HCLK x ( TWRPH0 + 1 ), 从NAND手册可知它要&gt;=12ns, 所以TWRPH0&gt;=1</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TWRPH1   0  <span class="comment">// nWE变为高电平后多长时间CLE/ALE才能变为低电平, 从NAND手册可知它要&gt;=5ns, 所以TWRPH1&gt;=0</span></span></span><br><span class="line">    s3c_nand_regs-&gt;nfconf = (TACLS&lt;&lt;<span class="number">12</span>) | (TWRPH0&lt;&lt;<span class="number">8</span>) | (TWRPH1&lt;&lt;<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置 NFCONT 寄存器. BIT1=1, 取消片选. BIT0=1, 使能NAND控制器</span></span><br><span class="line">    s3c_nand_regs-&gt;nfcont = (<span class="number">1</span>&lt;&lt;<span class="number">1</span>) | (<span class="number">1</span>&lt;&lt;<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 4. 使用: nand_scan */</span></span><br><span class="line">    s3c_mtd-&gt;owner = THIS_MODULE;</span><br><span class="line">    s3c_mtd-&gt;priv  = s3c_nand;</span><br><span class="line">    nand_scan(s3c_mtd, <span class="number">1</span>);                          <span class="comment">// 识别NAND FLASH, 构造mtd_info. 硬件只有1块NAND Flash.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 5. add_mtd_partitions</span></span><br><span class="line"><span class="comment">     * 增加 add_mtd_partitions 函数后,</span></span><br><span class="line"><span class="comment">     * 内核必须去掉自带的NAND Flash驱动, 从NFS启动系统.</span></span><br><span class="line"><span class="comment">     * 确认要做这个实验的时候, 再取消下面的注释, 编译测试</span></span><br><span class="line"><span class="comment">     * 如果不需要分区, 只需调用 add_mtd_device(s3c_mtd);</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// add_mtd_partitions(s3c_mtd, s3c_nand_parts, 4);  // 告知分区要求, 调用 add_mtd_partitions</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">s3c_nand_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    del_mtd_partitions(s3c_mtd);</span><br><span class="line">    iounmap(s3c_nand_regs);</span><br><span class="line">    kfree(s3c_mtd);</span><br><span class="line">    kfree(s3c_nand);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(s3c_nand_init);</span><br><span class="line">module_exit(s3c_nand_exit);</span><br></pre></td></tr></table></figure>
<h2 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h2><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">obj-m       := s3c_nand.o</span><br><span class="line">KERN_SRC    := /home/draapho/share/jz2440/kernel/linux-2.6.22.6/</span><br><span class="line">PWD         := <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"></span><br><span class="line"><span class="section">modules:</span></span><br><span class="line">    make -C <span class="variable">$(KERN_SRC)</span> M=<span class="variable">$(PWD)</span> modules</span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    make -C <span class="variable">$(KERN_SRC)</span> M=<span class="variable">$(PWD)</span> clean</span><br></pre></td></tr></table></figure>
<h2 id="测试1"><a href="#测试1" class="headerlink" title="测试1"></a>测试1</h2><p>源码没有调用 <code>add_mtd_partitions</code> 时, 简单测试一下NAND Flash是否正常工作了.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Ubuntu 主机端</span></span><br><span class="line"><span class="comment"># pwd = ~/share/jz2440/drivers/nand/            # NAND flash驱动目录</span></span><br><span class="line">$ make modules                                  <span class="comment"># 生成s3c_nand.ko, 忽略 s3c_nand_parts 没有使用的警告信息</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 开发板端, 开始测试</span></span><br><span class="line"><span class="comment"># pwd = ~/share/jz2440/drivers/nand/            # NAND flash驱动目录, nfs</span></span><br><span class="line">$ insmod s3c_nand.ko                            <span class="comment"># 加载驱动</span></span><br><span class="line">NAND device: Manufacturer ID: 0xec, Chip ID: 0xda (Samsung NAND 256MiB 3,3V 8-bit)</span><br><span class="line">Scanning device <span class="keyword">for</span> bad blocks</span><br><span class="line">......</span><br><span class="line"><span class="comment"># 打印信息正确识别了 Nand Flash, 说明底层操作都成功了.</span></span><br></pre></td></tr></table></figure>
<h2 id="测试2"><a href="#测试2" class="headerlink" title="测试2"></a>测试2</h2><p>源码调用 <code>add_mtd_partitions</code> 时, 测试过程比较复杂.</p>
<ol>
<li>卸载内核自带的NAND Flash驱动</li>
<li>导致无法从本地Flash启动, 必须设置为从nfs启动</li>
<li>从nfs启动后, 加载 s3c_nand.ko 驱动.</li>
<li>使用工具 <code>mtd-utils</code> 格式化 NAND Flash</li>
<li>格式化后, 就能挂载测试了.</li>
<li>恢复原来的开发环境.</li>
</ol>
<p><strong>这个实验我没有实际去做, 设置和恢复都太麻烦. 而且正常的开发过程是不会这样去操作的.</strong><br>下面给出实验步骤:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 卸载内核自带的NAND Flash驱动</span></span><br><span class="line"><span class="comment"># Ubuntu 主机端</span></span><br><span class="line"><span class="comment"># pwd = ./linux-2.6.22.6_custom  复制一个新的内核源码目录</span></span><br><span class="line"></span><br><span class="line">$ make clean</span><br><span class="line">$ make menuconfig                               <span class="comment"># 去掉自带的HID USB驱动程序</span></span><br><span class="line"><span class="comment"># -&gt; Device Drivers</span></span><br><span class="line"><span class="comment">#   -&gt; Memory Technology Device (MTD) support</span></span><br><span class="line"><span class="comment">#     -&gt; NAND Device Support</span></span><br><span class="line"><span class="comment">#       &lt; &gt; NAND Flash support for S3C2410/S3C2440 SoC  # 取消内置的NAND Flash驱动</span></span><br><span class="line"></span><br><span class="line">$ make uImage</span><br><span class="line"><span class="comment"># 烧录新的uImage</span></span><br><span class="line"><span class="comment"># 重启开发板进入uboot烧录界面, 按k准备烧录内核. 略过不表</span></span><br><span class="line">$ sudo dnw ./arch/arm/boot/uImage</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2. 导致无法从本地Flash启动, 必须设置为从nfs启动.</span><br><span class="line"><span class="comment"># 可参考 "嵌入式linux环境搭建-jz2440开发板" 一文</span></span><br><span class="line"><span class="comment"># 开发板, uboot命令行下</span></span><br><span class="line"><span class="comment"># 要使用nfs功能, 必须正确设置uboot的ip地址, 并且Ubuntu端正确设置了nfs</span></span><br><span class="line"></span><br><span class="line">printenv                                        <span class="comment"># 看下现有的uboot环境, 记好bootargs, 恢复的时候要用的.</span></span><br><span class="line"><span class="comment"># bootargs=noinitrd root=/dev/mtdblock3 init=/linuxrc console=ttySAC0</span></span><br><span class="line"><span class="built_in">set</span> bootargs noinitrd root=/dev/nfs nfsroot=10.0.0.98:/fs ip=10.0.0.111:10.0.0.98:10.0.0.138:255.255.255.0::eth0:off init=/linuxrc console=ttySAC0</span><br><span class="line"><span class="comment"># (简化ip: 'set bootargs noinitrd root=/dev/nfs nfsroot=10.0.0.98:/fs ip=10.0.0.111 init=/linuxrc console=ttySAC0' 也可以工作)</span></span><br><span class="line">save        <span class="comment"># 保存修改</span></span><br><span class="line">reset       <span class="comment"># 重启.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 参数简要说明:</span></span><br><span class="line"><span class="comment"># 'root=/dev/nfs' 加载nfs文件系统</span></span><br><span class="line"><span class="comment"># 'nfsroot=10.0.0.98:/fs' nfs文件系统的来源, 此处是由Ubuntu当nfs服务器, 共享出/fs文件夹</span></span><br><span class="line"><span class="comment"># 'ip=10.0.0.111:10.0.0.98:10.0.0.138:255.255.255.0::eth0:off' 分别表示:</span></span><br><span class="line"><span class="comment">#  ip= 开发板ip : nfs服务器ip: 网关ip : 子网掩码 :: 开发板网口 : off</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">3. 从nfs启动后, 加载 s3c_nand.ko 驱动.</span><br><span class="line"><span class="comment"># Ubuntu 主机端</span></span><br><span class="line"><span class="comment"># pwd = ~/share/jz2440/drivers/nand/            # NAND flash驱动目录</span></span><br><span class="line">$ make modules                                  <span class="comment"># 生成s3c_nand.ko</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 开发板端, 开始测试</span></span><br><span class="line"><span class="comment"># pwd = ~/share/jz2440/drivers/nand/            # NAND flash驱动目录, nfs</span></span><br><span class="line">$ insmod s3c_nand.ko                            <span class="comment"># 加载驱动</span></span><br><span class="line">NAND device: Manufacturer ID: 0xec, Chip ID: 0xda (Samsung NAND 256MiB 3,3V 8-bit)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">4. 使用工具 mtd-utils 格式化 NAND Flash</span><br><span class="line"><span class="comment"># Ubuntu 主机端, 需要先编译mtd-utils</span></span><br><span class="line">$ tar xjf mtd-utils-05.07.23.tar.bz2</span><br><span class="line">$ <span class="built_in">cd</span> mtd-utils-05.07.23/util</span><br><span class="line">$ vim Makefile</span><br><span class="line">    <span class="comment"># ===== 文件内容, 修改如下内容: =====</span></span><br><span class="line">    <span class="comment">#CROSS=arm-linux-   # 需要交叉编译, 取消注释</span></span><br><span class="line">    CROSS=arm-linux-</span><br><span class="line">    <span class="comment"># ===== 结束修改, 保存退出vim =====</span></span><br><span class="line">$ make</span><br><span class="line"><span class="comment"># 拷贝可执行文件到挂载的nfs文件系统的bin目录下</span></span><br><span class="line">$ cp flash_erase flash_eraseall /home/draapho/share/jz2440/nfs/fs_mini_mdev/bin</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">5. 格式化后, 就能挂载测试了.</span><br><span class="line"><span class="comment"># 开发板端 bash</span></span><br><span class="line">$ ls -l /dev/mtd*                               <span class="comment"># 查看一下分区情况, 有0-3共四个分区</span></span><br><span class="line"><span class="comment"># 应该是用 "flash_eraseall /dev/mtd1" 格式化 "params" 分区, 恢复起来最方便.</span></span><br><span class="line">$ flash_eraseall /dev/mtd3                      <span class="comment"># 格式化 root分区 (用的字符设备), 文件格式为yaffs</span></span><br><span class="line">$ mount -t yaffs /dev/mtdblock3 /tmp            <span class="comment"># 以yaffs格式挂载 root分区</span></span><br><span class="line">$ ls /tmp                                       <span class="comment"># 应该只有一个 lost+found 文件.</span></span><br><span class="line"><span class="comment"># 然后可以对这个分区进行文件创建, 读写的操作了.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">6. 恢复原来的开发环境</span><br><span class="line"><span class="comment"># 开发板 uboot:</span></span><br><span class="line"><span class="comment"># 破坏了root区的话, 就恢复root区, 重新烧写文件系统到flash就行了. 猜测使用 params 区做测试是没有影响的.</span></span><br><span class="line"><span class="comment"># 烧录原来的 uImage 到 kernel.</span></span><br><span class="line"><span class="comment"># 改回 uboot 的 bootargs 参数</span></span><br><span class="line"><span class="comment"># 重启, 从NAND Flash正常启动.</span></span><br></pre></td></tr></table></figure>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="http://www.cnblogs.com/TaigaCon/archive/2012/11/17/2775057.html" target="_blank" rel="noopener">Linux操作系统下 NAND FLASH驱动程序框架</a></p>
<hr>
<p><strong><em>原创于 <a href="https://draapho.github.io/">DRA&amp;PHO</a></em></strong></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/01/24/1810-drv-nand1/" itemprop="url">
                  驱动之NAND Flash框架
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2018-01-24T00:00:00+11:00" content="2018-01-24">
              2018-01-24
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/embedded-linux/" itemprop="url" rel="index">
                    <span itemprop="name">embedded linux</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h1><ul>
<li><a href="https://draapho.github.io/2017/11/23/1734-linux-content/">嵌入式linux学习目录</a></li>
<li><a href="https://draapho.github.io/2018/01/22/1809-drv-blk/">驱动之块设备-框架</a></li>
<li><a href="https://draapho.github.io/2018/01/24/1810-drv-nand1/">驱动之NAND Flash框架</a></li>
<li><a href="https://draapho.github.io/2018/01/25/1811-drv-nand2/">驱动之NAND Flash源码</a></li>
<li>[驱动之NOR Flash](<a href="https://draapho.github.io/2018/01/26/1812-drv-nor/">https://draapho.github.io/2018/01/26/1812-drv-nor/</a></li>
<li><a href="https://draapho.github.io/2018/02/06/1813-drv-net/">驱动之网卡驱动</a></li>
</ul>
<p>本文使用 linux-2.6.22.6 内核, 使用jz2440开发板.</p>
<h1 id="NAND-Flash-基础知识"><a href="#NAND-Flash-基础知识" class="headerlink" title="NAND Flash 基础知识"></a>NAND Flash 基础知识</h1><h2 id="NAND-和-NOR-Flash的比较"><a href="#NAND-和-NOR-Flash的比较" class="headerlink" title="NAND 和 NOR Flash的比较"></a>NAND 和 NOR Flash的比较</h2><table>
<thead>
<tr>
<th>NOR FLASH</th>
<th>NAND FLASH</th>
</tr>
</thead>
<tbody>
<tr>
<td>接口时序同SRAM,易使用</td>
<td>地址/数据线复用，数据位较窄</td>
</tr>
<tr>
<td>读取速度较快</td>
<td>读取速度较慢</td>
</tr>
<tr>
<td>擦除速度慢，以64-128KB的块为单位</td>
<td>擦除速度快，以8－32KB的块为单位</td>
</tr>
<tr>
<td>写入速度慢</td>
<td>写入速度快</td>
</tr>
<tr>
<td>随机存取速度较快，支持XIP(eXecute In Place，芯片内执行)，适用于代码存储。在嵌入式系统中，常用于存放引导程序、根文件系统等。</td>
<td>顺序读取速度较快，随机存取速度慢，适用于数据存储(如大容量的多媒体应用)。在嵌入式系统中，常用于存放用户文件系统等。</td>
</tr>
<tr>
<td>单片容量较小，1-32MB</td>
<td>单片容量较大，8-128MB，提高了单元密度</td>
</tr>
<tr>
<td>最大擦写次数10万次</td>
<td>最大擦写次数100万次</td>
</tr>
</tbody>
</table>
<h2 id="硬件接口和时序"><a href="#硬件接口和时序" class="headerlink" title="硬件接口和时序"></a>硬件接口和时序</h2><p>看相关数据手册, 以jz2440v3开发板为例:</p>
<ul>
<li><code>K9F2G08U0C.pdf</code> NAND Flash 数据手册</li>
<li><code>S3C2440A_UserManual_Rev13.pdf</code> CPU 数据手册</li>
</ul>
<p>NAND Flash的硬件引脚基本固定, 下面列出各个引脚的含义</p>
<table>
<thead>
<tr>
<th>缩写</th>
<th>英文原意</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>I/O</td>
<td>data Inputs/Outputs</td>
<td>数据收发, 8bit或16bit</td>
</tr>
<tr>
<td>CLE</td>
<td>Command Latch Enable</td>
<td>传的是指令, 高电平有效</td>
</tr>
<tr>
<td>ALE</td>
<td>Address Latch Enable</td>
<td>传的是地址, 高电平有效</td>
</tr>
<tr>
<td>_CE 或 nCE</td>
<td>Chip Enable</td>
<td>片选信号, 低电平有效</td>
</tr>
<tr>
<td>_RE 或 nRE</td>
<td>Read Enable</td>
<td>读数据, 低电平有效</td>
</tr>
<tr>
<td>_WE 或 nWE</td>
<td>Write Enable</td>
<td>写数据, 低电平有效</td>
</tr>
<tr>
<td>R/_B 或 R/nB</td>
<td>Ready/Busy</td>
<td>空闲/忙信号, 忙为低电平</td>
</tr>
</tbody>
</table>
<p>查看三星S3C2440数据手册 <code>NAND Flash Controller</code> 章节可知, 已将nand flash的时序操作打包成了寄存器操作.<br>u-boot里面, 可以使用 <code>md</code> <code>mw</code> 直接对memroy进行操作. 因此可在u-boot下面直接用指令来操作nand flash的时序</p>
<ul>
<li><code>md</code>, Memory Display. 显示指定内存地址的内容. <code>.b</code>表Byte, 字节. <code>.w</code>表Word, 2字节. <code>.l</code>表Long, 4字节.</li>
<li><code>mw</code>, Memory Write. 写入内容到指定内存地址. <code>.b</code>表Byte, 字节. <code>.w</code>表Word, 2字节. <code>.l</code>表Long, 4字节.</li>
</ul>
<table>
<thead>
<tr>
<th>指令</th>
<th>物理操作</th>
<th>S3C2440 寄存器操作</th>
<th>u-boot 直接操作对应的寄存器地址</th>
</tr>
</thead>
<tbody>
<tr>
<td>片选</td>
<td>_CE低</td>
<td>NFCONT bit1=0</td>
<td>md.l 读一下, mw.l 0x4E000004 回写bit1=0</td>
</tr>
<tr>
<td>发命令</td>
<td>CLE高, ALE低, I/O命令值, _WE高变低</td>
<td>NFCMMD=命令值</td>
<td>mw.b 0x4E000008 命令值</td>
</tr>
<tr>
<td>发地址</td>
<td>ALE高, CLE低, I/O地址值, _WE高变低</td>
<td>NFADDR=地址值</td>
<td>mw.b 0x4E00000C 地址值</td>
</tr>
<tr>
<td>发数据</td>
<td>CLE低, ALE低, I/O数据值, _WE高变低</td>
<td>NFDATA=数据值</td>
<td>mw.b 0x4E000010 数据值</td>
</tr>
<tr>
<td>读数据</td>
<td>CLE低, ALE低, _RE高变低, 取I/O值</td>
<td>数据值=NFDATA</td>
<td>md.b 0x4E000010 1</td>
</tr>
</tbody>
</table>
<h2 id="读写实验"><a href="#读写实验" class="headerlink" title="读写实验"></a>读写实验</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 开发板 uboot 命令行, 最好是从 NAND Flash 启动的uboot.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 读取 ID, 查看 K9F2G08U0C 数据手册 5.5 Read ID 时序图.</span></span><br><span class="line">md.l 0x4E000004 1           <span class="comment"># 读取 NFCONT 寄存器值. 1表示长度, 就读一个数据. 默认值是16</span></span><br><span class="line">mw.l 0x4E000004 1           <span class="comment"># 置 bit1=0 后, 回写</span></span><br><span class="line">mw.b 0x4E000008 0x90        <span class="comment"># 发命令 NFCMMD=0x90</span></span><br><span class="line">mw.b 0x4E00000C 0x00        <span class="comment"># 发地址 NFADDR=0x00</span></span><br><span class="line">md.b 0x4E000010 1           <span class="comment"># 读数据 NFDATA, 应该得到 ec</span></span><br><span class="line">md.b 0x4E000010 1           <span class="comment"># 继续读 NFDATA, 应该得到device code, da</span></span><br><span class="line">md.b 0x4E000010 1           <span class="comment"># 继续读 NFDATA, 应该得到device code, 10</span></span><br><span class="line">md.b 0x4E000010 1           <span class="comment"># 继续读 NFDATA, 应该得到device code, 15 (这里返回了95, 先不管)</span></span><br><span class="line">md.b 0x4E000010 1           <span class="comment"># 继续读 NFDATA, 应该得到device code, 44</span></span><br><span class="line"><span class="comment"># 这里不能使用指令 md.b 0x4E000010 5 读取5个字节. 因为其含义是读 0x4E000010-0x4E000014 的寄存器值, 必然是错的.</span></span><br><span class="line">mw.b 0x4E000008 0xff        <span class="comment"># 发RESET命令 NFCMMD=0xFF</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 读取0地址的数据, 查看 K9F2G08U0C 数据手册 5.1 Page Read 时序图</span></span><br><span class="line">nand dump 0                 <span class="comment"># 先用nand指令直接读取nand flash的页, 后面在用寄存器操作的方式读一遍来对比</span></span><br><span class="line">17 00 00 ea 14 f0 9f e5  14 f0 9f e5 14 f0 9f e5</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">md.l 0x4E000004 1           <span class="comment"># 读取 NFCONT 寄存器值. 1表示长度, 就读一个数据. 默认值是16</span></span><br><span class="line">mw.l 0x4E000004 1           <span class="comment"># 置 bit1=0 后, 回写</span></span><br><span class="line">mw.b 0x4E000008 0x00        <span class="comment"># 写命令 NFCMMD=0x00</span></span><br><span class="line">mw.b 0x4E00000C 0x00        <span class="comment"># 写地址 NFADDR=0x00</span></span><br><span class="line">mw.b 0x4E00000C 0x00        <span class="comment"># 写地址 NFADDR=0x00</span></span><br><span class="line">mw.b 0x4E00000C 0x00        <span class="comment"># 写地址 NFADDR=0x00</span></span><br><span class="line">mw.b 0x4E00000C 0x00        <span class="comment"># 写地址 NFADDR=0x00</span></span><br><span class="line">mw.b 0x4E00000C 0x00        <span class="comment"># 写地址 NFADDR=0x00</span></span><br><span class="line"><span class="comment"># 这款nand总线是8位, 时序图要求5个周期. 由2字节的列地址和3字节的行地址组成.</span></span><br><span class="line">mw.b 0x4E000008 0x30        <span class="comment"># 读命令 NFCMMD=0x30</span></span><br><span class="line">md.b 0x4E000010 1           <span class="comment"># 读数据 NFDATA</span></span><br><span class="line">......                      <span class="comment"># 重复多次这个指令, 譬如16次</span></span><br><span class="line">md.b 0x4E000010 1           <span class="comment"># 读数据 NFDATA, 得到的数据应该和 nand dump 0 的一样</span></span><br><span class="line"><span class="comment"># 16此返回值应该和 nand dump 的结果一样: 17 00 00 ea 14 f0 9f e5  14 f0 9f e5 14 f0 9f e5</span></span><br><span class="line"><span class="comment"># 这里不能使用指令 md.b 0x4E000010 16 读取16个字节. 因为其含义是读 0x4E000010-0x4E000020 的寄存器值, 必然是错的.</span></span><br><span class="line">mw.b 0x4E000008 0xff        <span class="comment"># 发RESET命令 NFCMMD=0xFF</span></span><br></pre></td></tr></table></figure>
<h1 id="NAND-Flash-系统框架"><a href="#NAND-Flash-系统框架" class="headerlink" title="NAND Flash 系统框架"></a>NAND Flash 系统框架</h1><p><img src="https://draapho.github.io/images/1810/nand1.jpg" alt="nand1"></p>
<p><img src="https://draapho.github.io/images/1810/nand2.png" alt="nand2"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 由Linux系统启动时的打印信息, 可以抓取到 NAND FLASH 相关的初始化信息和分区信息.</span></span><br><span class="line"><span class="comment">// 可得 "S3C24XX NAND Driver, ..." 搜索后, 定位到文件 "/drivers/mtd/nand/s3c2410.c"</span></span><br><span class="line"><span class="comment">// mtd: Memory Technology Device. 记忆体技术设备, 也就是 nand/nor flash.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// -----&gt; /drivers/mtd/nand/s3c2410.c</span></span><br><span class="line">s3c2410_nand_init                                               <span class="comment">// 看驱动文件, 从 module_init 开始</span></span><br><span class="line">    platform_driver_register(&amp;s3c2440_nand_driver);             <span class="comment">// 很明显用了 platform 框架</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// -----&gt; /arch/arm/plat-s3c24xx/common-smdk.c              // 这里是 platform 框架的 device 配置</span></span><br><span class="line">    smdk_machine_init</span><br><span class="line">        s3c_device_nand.dev.platform_data = &amp;smdk_nand_info;</span><br><span class="line">        platform_add_devices(smdk_devs);                        <span class="comment">// 找到了 platform 的 devices 端.</span></span><br><span class="line">        <span class="comment">// 这里看下 smdk_nand_info, smdk_devs的s3c_device_nand 就都明白了. 配置nand的名称和参数.</span></span><br><span class="line">    <span class="comment">// -----&gt; 结束, common-smdk.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 看完了platform框架, 匹配后就是调用probe函数. 几次跳转后, 最终调用:</span></span><br><span class="line">s3c24xx_nand_probe</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">s3c2410_platform_nand</span> *<span class="title">plat</span> = <span class="title">to_nand_plat</span>(<span class="title">pdev</span>);</span>    <span class="comment">// 取出了 smdk_nand_info 的配置信息</span></span><br><span class="line">    s3c2410_nand_inithw                                         <span class="comment">// 初始化硬件, 如时序</span></span><br><span class="line">    s3c2410_nand_init_chip                                      <span class="comment">// 初始化通讯, 如缓冲区, 寄存器值</span></span><br><span class="line">    nand_scan                                                   <span class="comment">// 开始通讯, 检查 nand flash</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// -----&gt; /drivers/mtd/nand/nand_base.c                     // NAND FLASH 操作的通用文件</span></span><br><span class="line">    nand_scan</span><br><span class="line">        nand_scan_ident                                         <span class="comment">// 第一阶段的初始化, 检查flash硬件</span></span><br><span class="line">            nand_set_defaults                                   <span class="comment">// nand 通信使用默认参数</span></span><br><span class="line">            nand_get_flash_type                                 <span class="comment">// 获取第一块 nand 的ID值</span></span><br><span class="line">                nand_flash_ids                                  <span class="comment">// 常用的 nand flash 表. 可见内核都支持了</span></span><br><span class="line">            printk(KERN_INFO <span class="string">"%d NAND chips detected\n"</span>, i);    <span class="comment">// 接了多块nand的话, 必须是同型号的</span></span><br><span class="line">            mtd-&gt;size = i * chip-&gt;chipsize;                     <span class="comment">// 总容量 = nand数量*单片容量</span></span><br><span class="line">        nand_scan_tail                                          <span class="comment">// 第二阶段的初始化工作, 软件设置</span></span><br><span class="line">    <span class="comment">// -----&gt; 结束, nand_base.c</span></span><br><span class="line"></span><br><span class="line">    s3c2410_nand_add_partition                                  <span class="comment">// 分区工作</span></span><br><span class="line">        add_mtd_device</span><br><span class="line">        <span class="comment">// -----&gt; /drivers/mtd/mtdcore.c                        // mtd 设备核心</span></span><br><span class="line">        <span class="comment">// add_mtd_partitions 最终也调用了 add_mtd_device</span></span><br><span class="line">        add_mtd_device</span><br><span class="line">            <span class="keyword">not</span> = list_entry(<span class="keyword">this</span>, struct mtd_notifier, <span class="built_in">list</span>);  <span class="comment">// struct mtd_notifier 结构体是关键</span></span><br><span class="line">            <span class="keyword">not</span>-&gt;add(mtd);                                      <span class="comment">// 调用了add</span></span><br><span class="line">            <span class="comment">// 搜索 mtd_notifier 查看来源, 可知:</span></span><br><span class="line">            <span class="comment">// 实际调用了 mtd_notify_add         // -----&gt; drivers/mtd/mtdchar.c</span></span><br><span class="line">            <span class="comment">// 实际调用了 blktrans_notify_add    // -----&gt; drivers/mtd/mtd_blkdevs.c</span></span><br><span class="line">        <span class="comment">// -----&gt; 结束, mtdcore.c</span></span><br><span class="line"><span class="comment">// -----&gt; 结束, s3c2410.c</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// -----&gt; drivers/mtd/mtdchar.c                                 // 将mtd设备挂载成字符设备</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">mtd_notifier</span> <span class="title">notifier</span>;</span>                            <span class="comment">// .add = mtd_notify_add</span></span><br><span class="line">mtd_notify_add</span><br><span class="line">    class_device_create(<span class="string">"mtd%d"</span>)                                <span class="comment">// mtd字符设备, 可读写</span></span><br><span class="line">    class_device_create(<span class="string">"mtd%dro"</span>)                              <span class="comment">// mtd只读字符设备</span></span><br><span class="line">init_mtdchar                                                    <span class="comment">// mtdchar.c 的 module_init</span></span><br><span class="line">    register_chrdev(MTD_CHAR_MAJOR, <span class="string">"mtd"</span>, &amp;mtd_fops)           <span class="comment">// 注册为字符设备</span></span><br><span class="line"><span class="comment">// -----&gt; 结束, mtdchar.c 完成了字符设备的核心步骤.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// -----&gt; drivers/mtd/mtd_blkdevs.c                             // 将mtd设备挂载成块设备</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">mtd_notifier</span> <span class="title">blktrans_notifier</span>;</span>                   <span class="comment">// .add = blktrans_notify_add</span></span><br><span class="line">blktrans_notify_add</span><br><span class="line">    tr = list_entry(<span class="keyword">this</span>, struct mtd_blktrans_ops, <span class="built_in">list</span>);       <span class="comment">// 一样的, 搜索 mtd_blktrans_ops</span></span><br><span class="line">    tr-&gt;add_mtd(tr, mtd);</span><br><span class="line">    <span class="comment">// 可以找到两个文件有初始化, 很明显是块设备读写还是只读的区别. 选取 /drivers/mtd/mtdblock.c</span></span><br><span class="line">    <span class="comment">// 实际调用了 mtdblock_add_mtd</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// -----&gt; /drivers/mtd/mtdblock.c</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">mtd_blktrans_ops</span> <span class="title">mtdblock_tr</span>;</span>                 <span class="comment">// .add_mtd = mtdblock_add_mtd</span></span><br><span class="line">    mtdblock_add_mtd</span><br><span class="line">        add_mtd_blktrans_dev</span><br><span class="line">            alloc_disk                                          <span class="comment">// 分配 gendisk</span></span><br><span class="line">            add_disk                                            <span class="comment">// 注册为块设备</span></span><br><span class="line">    init_mtdblock                                               <span class="comment">// mtdblock.c 的 module_init</span></span><br><span class="line">        register_mtd_blktrans</span><br><span class="line">            register_blkdev                                     <span class="comment">// 获得主设备号</span></span><br><span class="line">            blk_init_queue                                      <span class="comment">// 设置缓冲队列</span></span><br><span class="line">    <span class="comment">// -----&gt; 结束, mtdblock.c 完成了块设备的核心步骤.</span></span><br><span class="line"><span class="comment">// -----&gt; 结束, mtd_blkdevs</span></span><br></pre></td></tr></table></figure>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="http://www.cnblogs.com/TaigaCon/archive/2012/11/17/2775057.html" target="_blank" rel="noopener">Linux操作系统下 NAND FLASH驱动程序框架</a><br><a href="http://www.linuxidc.com/Linux/2017-03/142206.htm" target="_blank" rel="noopener">Linux MTD子系统 _从模型分析到Flash驱动模板</a><br><a href="http://blog.sina.com.cn/s/blog_6683e49d0100o18j.html" target="_blank" rel="noopener">LINUX NAND FLASH驱动程序框架分析</a></p>
<hr>
<p><strong><em>原创于 <a href="https://draapho.github.io/">DRA&amp;PHO</a></em></strong></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/01/22/1809-drv-blk/" itemprop="url">
                  驱动之块设备-框架
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2018-01-22T00:00:00+11:00" content="2018-01-22">
              2018-01-22
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/embedded-linux/" itemprop="url" rel="index">
                    <span itemprop="name">embedded linux</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h1><ul>
<li><a href="https://draapho.github.io/2017/11/23/1734-linux-content/">嵌入式linux学习目录</a></li>
<li><a href="https://draapho.github.io/2018/01/22/1809-drv-blk/">驱动之块设备-框架</a></li>
<li><a href="https://draapho.github.io/2018/01/24/1810-drv-nand1/">驱动之NAND Flash框架</a></li>
<li><a href="https://draapho.github.io/2018/01/25/1811-drv-nand2/">驱动之NAND Flash源码</a></li>
<li>[驱动之NOR Flash](<a href="https://draapho.github.io/2018/01/26/1812-drv-nor/">https://draapho.github.io/2018/01/26/1812-drv-nor/</a></li>
<li><a href="https://draapho.github.io/2018/02/06/1813-drv-net/">驱动之网卡驱动</a></li>
</ul>
<p>本文使用 linux-2.6.22.6 内核, 使用jz2440开发板.</p>
<h1 id="块设备的驱动框架"><a href="#块设备的驱动框架" class="headerlink" title="块设备的驱动框架"></a>块设备的驱动框架</h1><h2 id="驱动框架"><a href="#驱动框架" class="headerlink" title="驱动框架"></a>驱动框架</h2><p><img src="https://draapho.github.io/images/1809/block.png" alt="block.png"></p>
<p><img src="https://draapho.github.io/images/1809/block_fun.png" alt="block_fun.png"></p>
<ul>
<li><code>ll_rw_block</code>: Low Level Read/Write block device</li>
<li><code>submit_bh</code>: submit Buffer Head</li>
<li><code>submit_bio</code>: submit Block IO (Input/Output)</li>
<li><code>elv_merge</code>: elevator merge. 用电梯算法合并数据</li>
</ul>
<h2 id="硬盘基础概念"><a href="#硬盘基础概念" class="headerlink" title="硬盘基础概念"></a>硬盘基础概念</h2><p>块设备为了兼容机械结构的硬盘, 使用了一些硬盘特有的概念.</p>
<p><img src="https://draapho.github.io/images/1809/Platter.jpg" alt="Platter.jpg"></p>
<p><img src="https://draapho.github.io/images/1809/Cylinder.png" alt="Cylinder.png"></p>
<ul>
<li><code>存储容量 = 磁头数 x 柱面数 x 扇区数 x 512(扇区字节数)</code></li>
<li><code>存储容量 = 柱面大小 x 柱面数</code></li>
<li><code>柱面大小 = 磁头数 x 扇区数 x 512(扇区字节数)</code></li>
</ul>
<table>
<thead>
<tr>
<th>英语</th>
<th>中文</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Disk</td>
<td>磁盘</td>
<td>就是硬盘</td>
</tr>
<tr>
<td>Platter</td>
<td>圆盘</td>
<td>硬盘的盘片</td>
</tr>
<tr>
<td>Head</td>
<td>磁头</td>
<td>盘片有2面: 2磁头/圆盘</td>
</tr>
<tr>
<td>Track</td>
<td>磁道</td>
<td>圆盘被分割为多个同心圆, 即磁道</td>
</tr>
<tr>
<td>Sector</td>
<td>扇区</td>
<td>磁道被分割后的扇形区域</td>
</tr>
<tr>
<td>Cylinder</td>
<td>柱面</td>
<td>由多个圆盘的同一磁道构成</td>
</tr>
<tr>
<td>Partition</td>
<td>分区</td>
<td>软件概念, 以柱面为单位</td>
</tr>
</tbody>
</table>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://draapho.github.io/2017/02/01/1704-linux-source4/">Linux 0.11 源码阅读笔记-设备驱动程序</a></li>
<li><a href="http://blog.csdn.net/zdy0_2004/article/details/78206395" target="_blank" rel="noopener">Linux-块设备驱动之框架详细分析(详解)</a></li>
<li><a href="http://blog.csdn.net/hustfoxy/article/details/8723178" target="_blank" rel="noopener">Linux块设备驱动</a></li>
<li><a href="http://blog.chinaunix.net/uid-23069658-id-3413957.html" target="_blank" rel="noopener">硬盘的存储原理和内部架构</a></li>
<li><a href="http://www.bijishequ.com/detail/193530" target="_blank" rel="noopener">计算机机械硬盘的结构和工作原理</a></li>
<li><a href="http://www.dongcoder.com/detail-473552.html" target="_blank" rel="noopener">磁盘的组成</a></li>
<li><a href="http://www.cnblogs.com/joydinghappy/articles/2511948.html" target="_blank" rel="noopener">磁盘结构简介</a></li>
</ul>
<h1 id="块设备驱动范例"><a href="#块设备驱动范例" class="headerlink" title="块设备驱动范例"></a>块设备驱动范例</h1><p>块设备驱动的实现更为简单. Linux内核做掉了大部分工作, 驱动层只需要专注于硬件的块读写功能.<br>而且其框架相对固定, 不像字符设备有多种不同的框架组合.</p>
<p>可以参考内核里的两个文件</p>
<ul>
<li><code>drivers\block\xd.c</code> 用于 XT hard disk.</li>
<li><code>drivers\block\z2ram.c</code> ram disk.</li>
<li>给出的源码没有做返回值判断, <strong>实际使用时务必参考上面的范例实现错误处理</strong>.</li>
</ul>
<p>基本步骤如下:</p>
<ol>
<li>分配gendisk: <code>alloc_disk</code></li>
<li>设置<br> 2.1 分配/设置缓冲队列. <code>blk_init_queue</code><br> 2.2 设置gendisk其他信息, 用于提供硬件属性, 如容量</li>
<li>硬件初始化操作</li>
<li>注册: <code>add_disk</code></li>
</ol>
<h2 id="ramblock-c"><a href="#ramblock-c" class="headerlink" title="ramblock.c"></a>ramblock.c</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/major.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/vmalloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/blkdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/hdreg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">"GPL"</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">"DRAAPHO"</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEVICE_NAME <span class="meta-string">"RAMDISK"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RAMBLOCK_SIZE (1024*1024)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> major;</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">gendisk</span> *<span class="title">ramblock_disk</span>;</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">request_queue_t</span> *ramblock_queue;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">DEFINE_SPINLOCK</span><span class="params">(ramblock_lock)</span></span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *ramblock_buf;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分区需要知道"硬盘"的几何结构(geometry), 这里虚拟一下即可.</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ramblock_getgeo</span><span class="params">(struct block_device *bdev, struct hd_geometry *geo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    geo-&gt;heads     = <span class="number">2</span>;                                     <span class="comment">// 磁头数=盘面数*2</span></span><br><span class="line">    geo-&gt;cylinders = <span class="number">32</span>;                                    <span class="comment">// 柱面数</span></span><br><span class="line">    geo-&gt;sectors   = RAMBLOCK_SIZE/<span class="number">2</span>/<span class="number">32</span>/<span class="number">512</span>;                <span class="comment">// 扇区数. 利用公式: 存储容量=磁头数x柱面数x扇区数x512</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">block_device_operations</span> <span class="title">ramblock_fops</span> = &#123;</span></span><br><span class="line">    .owner  = THIS_MODULE,</span><br><span class="line">    .getgeo = ramblock_getgeo,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现扇区的读写操作</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">do_ramblock_request</span><span class="params">(<span class="keyword">request_queue_t</span> * q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> r_cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> w_cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">request</span> *<span class="title">req</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ((req = elv_next_request(q)) != <span class="literal">NULL</span>) &#123;           <span class="comment">// 取出要处理的数据(连续的扇区数据, 即簇)</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> offset = req-&gt;sector*<span class="number">512</span>;             <span class="comment">// 读写的目标地址</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> len = req-&gt;current_nr_sectors*<span class="number">512</span>;    <span class="comment">// 长度</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (rq_data_dir(req) == READ) &#123;                     <span class="comment">// 读操作</span></span><br><span class="line">            printk(<span class="string">"do_ramblock_request read %d\n"</span>, ++r_cnt);</span><br><span class="line">            <span class="built_in">memcpy</span>(req-&gt;buffer, ramblock_buf+offset, len);  <span class="comment">// 直接读 ramblock_buf</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;                                            <span class="comment">// 写操作</span></span><br><span class="line">            printk(<span class="string">"do_ramblock_request write %d\n"</span>, ++w_cnt);</span><br><span class="line">            <span class="built_in">memcpy</span>(ramblock_buf+offset, req-&gt;buffer, len);  <span class="comment">// 直接写 ramblock_buf</span></span><br><span class="line">        &#125;</span><br><span class="line">        end_request(req, <span class="number">1</span>);                                <span class="comment">// 告知操作完成</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ramblock_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* 1. 分配一个gendisk结构体 */</span></span><br><span class="line">    ramblock_disk = alloc_disk(<span class="number">16</span>);                         <span class="comment">// 次设备号个数, 也是允许的最大分区个数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 2. 设置 */</span></span><br><span class="line">    <span class="comment">/* 2.1 分配/设置缓冲队列 */</span></span><br><span class="line">    ramblock_queue = blk_init_queue(do_ramblock_request, &amp;ramblock_lock);</span><br><span class="line">    ramblock_disk-&gt;<span class="built_in">queue</span> = ramblock_queue;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 2.2 设置其他属性: 比如容量 */</span></span><br><span class="line">    major = register_blkdev(<span class="number">0</span>, DEVICE_NAME);                <span class="comment">// cat /proc/devices 查看块设备</span></span><br><span class="line">    ramblock_disk-&gt;major       = major;                     <span class="comment">// 主设备号</span></span><br><span class="line">    ramblock_disk-&gt;first_minor = <span class="number">0</span>;                         <span class="comment">// 次设备号起始值</span></span><br><span class="line">    <span class="built_in">sprintf</span>(ramblock_disk-&gt;disk_name, <span class="string">"ramblock"</span>);</span><br><span class="line">    ramblock_disk-&gt;fops        = &amp;ramblock_fops;</span><br><span class="line">    set_capacity(ramblock_disk, RAMBLOCK_SIZE / <span class="number">512</span>);       <span class="comment">// 设置扇区的数量, 不是字节数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 3. 硬件初始化操作 */</span></span><br><span class="line">    ramblock_buf = kzalloc(RAMBLOCK_SIZE, GFP_KERNEL);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 4. 注册 */</span></span><br><span class="line">    add_disk(ramblock_disk);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ramblock_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    del_gendisk(ramblock_disk);                     <span class="comment">// 对应 add_disk</span></span><br><span class="line">    put_disk(ramblock_disk);                        <span class="comment">// 对应 blk_init_queue</span></span><br><span class="line">    blk_cleanup_queue(ramblock_queue);              <span class="comment">// 对应 blk_init_queue</span></span><br><span class="line">    unregister_blkdev(major, DEVICE_NAME);          <span class="comment">// 对应 register_blkdev</span></span><br><span class="line">    kfree(ramblock_buf);                            <span class="comment">// 安全起见, 最后释放buf</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(ramblock_init);</span><br><span class="line">module_exit(ramblock_exit);</span><br></pre></td></tr></table></figure>
<h2 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h2><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">obj-m       := ramblock.o</span><br><span class="line">KERN_SRC    := /home/draapho/share/jz2440/kernel/linux-2.6.22.6/</span><br><span class="line">PWD         := <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"></span><br><span class="line"><span class="section">modules:</span></span><br><span class="line">    make -C <span class="variable">$(KERN_SRC)</span> M=<span class="variable">$(PWD)</span> modules</span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    make -C <span class="variable">$(KERN_SRC)</span> M=<span class="variable">$(PWD)</span> clean</span><br></pre></td></tr></table></figure>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Ubuntu主机端</span></span><br><span class="line"><span class="comment"># pwd = ~/share/jz2440/drivers/drv_blk/         # 块设备驱动目录</span></span><br><span class="line">$ make modules                                  <span class="comment"># 生成 ramblock.ko</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 开发板端, 开始测试</span></span><br><span class="line"><span class="comment"># pwd = ~/share/jz2440/drivers/drv_blk/         # 块设备驱动目录, nfs</span></span><br><span class="line">$ insmod ramblock.ko</span><br><span class="line"> ramblock:do_ramblock_request <span class="built_in">read</span> 1</span><br><span class="line"> unknown partition table                        <span class="comment"># ramblock_buf 全是0, 所以显示无效分区表.</span></span><br><span class="line"></span><br><span class="line">$ ls /dev/ramblock*                             <span class="comment"># 可以看到 ramblock 设备了</span></span><br><span class="line">$ cat /proc/devices</span><br><span class="line">254 RAMDISK                                     <span class="comment"># register_blkdev产生的块设备信息</span></span><br><span class="line"></span><br><span class="line">$ mkdosfs /dev/ramblock                         <span class="comment"># 格式化. 没有mkfs指令, 用mkdosfs</span></span><br><span class="line">$ mount /dev/ramblock /tmp                      <span class="comment"># 挂载为 /tmp</span></span><br><span class="line"></span><br><span class="line">$ vi /tmp/<span class="built_in">test</span>                                  <span class="comment"># 在ramblock_disk里读写文件</span></span><br><span class="line">do_ramblock_request <span class="built_in">read</span> 43                     <span class="comment"># 退出后, 只是读取块, 然后在缓冲区修改. 没有真正写入!</span></span><br><span class="line">$ sync                                          <span class="comment"># 多等一会, 或者输入sync同步指令, 开始写入磁盘</span></span><br><span class="line">do_ramblock_request write 6</span><br><span class="line">do_ramblock_request write 7 ......</span><br><span class="line"></span><br><span class="line">$ cp ramblock.c /tmp/                           <span class="comment"># 随便拷贝一个文件</span></span><br><span class="line"><span class="comment"># 没有打印 do_ramblock_request write 说明文件还没有被真正写入磁盘</span></span><br><span class="line">$ sync                                          <span class="comment"># 多等一会, 或者输入sync同步指令, 开始写入磁盘</span></span><br><span class="line">do_ramblock_request write 11</span><br><span class="line">do_ramblock_request write 12 ......</span><br><span class="line"></span><br><span class="line">$ ls /tmp                                       <span class="comment"># 显示 ramblock 里的文件</span></span><br><span class="line">ramblock.c  <span class="built_in">test</span></span><br><span class="line">$ umount /tmp                                   <span class="comment"># 卸载 /tmp</span></span><br><span class="line">do_ramblock_request write 16 ......             <span class="comment"># 如果有未写入的数据, 此时会写入.</span></span><br><span class="line">$ ls /tmp                                       <span class="comment"># 这时候, tmp文件夹就是空的了.</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$cat</span> /dev/ramblock &gt; ./ramblock.bin             <span class="comment"># 把整个磁盘打包成文件. 当前路径是ubuntu的nfs</span></span><br><span class="line">do_ramblock_request <span class="built_in">read</span> ......</span><br><span class="line"></span><br><span class="line"><span class="comment"># 然后切换到 Ubuntu主机端</span></span><br><span class="line">$ sudo mount -o loop ramblock.bin /mnt          <span class="comment"># -o loop 表示挂载指定文件, 挂载到/mnt目录下</span></span><br><span class="line">$ ls /mnt                                       <span class="comment"># 显示了之前 ramblock 里的内容.</span></span><br><span class="line">ramblock.c  <span class="built_in">test</span></span><br><span class="line">$ sudo umount /mnt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换到 开发板端</span></span><br><span class="line">$ mkdir /ramdisk</span><br><span class="line">$ mount /dev/ramblock /ramdisk                  <span class="comment"># 重新挂载为 /ramdisk</span></span><br><span class="line">$ ls /ramdisk                                   <span class="comment"># 显示 ramblock 里的文件</span></span><br><span class="line">ramblock.c  <span class="built_in">test</span></span><br><span class="line">$ df                                            <span class="comment"># 可以查看文件系统信息.</span></span><br><span class="line">Filesystem           1k-blocks      Used Available Use% Mounted on</span><br><span class="line">/dev/ramblock             1004         6       998   1% /ramdisk</span><br><span class="line"></span><br><span class="line">$ umount /ramdisk                               <span class="comment"># 卸载ramdisk, 否则无法卸载驱动</span></span><br><span class="line">$ rmdir /ramdisk</span><br><span class="line">$ rmmod ramblock                                <span class="comment"># 卸载驱动, 里面数据就没有了!</span></span><br><span class="line"><span class="comment"># 观察打印信息 do_ramblock_request 可得: 块设备操作都是批量的读或者批量的写.</span></span><br><span class="line"><span class="comment"># 这是由电梯算法实现的, 能大大提高硬盘的物理读写速度, 减缓由磁盘操作造成的速度下降</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 开发板端, 开始做fdisk分区测试 (分区指令需要 geometry 信息)</span></span><br><span class="line">$ insmod ramblock.ko</span><br><span class="line">$ ls /dev/ramblock*                             <span class="comment"># 查看设备</span></span><br><span class="line">/dev/ramblock                                   <span class="comment"># 没有分区, 只有一个总的磁盘设备</span></span><br><span class="line">$ fdisk /dev/ramblock</span><br><span class="line">m                                               <span class="comment"># m for help</span></span><br><span class="line">n p Partition number: 1 cylinder value: 1-8     <span class="comment"># 增加一个主分区</span></span><br><span class="line">n p Partition number: 2 cylinder value: 9-32    <span class="comment"># 再增加一个主分区</span></span><br><span class="line">p                                               <span class="comment"># 查看设置的分区情况</span></span><br><span class="line">w                                               <span class="comment"># 执行上述配置</span></span><br><span class="line"></span><br><span class="line">$ ls /dev/ramblock* -l                          <span class="comment"># 再次查看设备, b表示块设备</span></span><br><span class="line">brw-rw----    1 0        0        254,   0 Jan  1 00:01 /dev/ramblock   <span class="comment"># 整个磁盘设备</span></span><br><span class="line">brw-rw----    1 0        0        254,   1 Jan  1 00:01 /dev/ramblock1  <span class="comment"># 分区一</span></span><br><span class="line">brw-rw----    1 0        0        254,   2 Jan  1 00:01 /dev/ramblock2  <span class="comment"># 分区二</span></span><br><span class="line"></span><br><span class="line">$ mkdosfs /dev/ramblock1                        <span class="comment"># 格式化</span></span><br><span class="line">$ mkdosfs /dev/ramblock2</span><br><span class="line">$ mkdir /mnt/ramdisk1                           <span class="comment"># 创建挂载文件点</span></span><br><span class="line">$ mkdir /mnt/ramdisk2</span><br><span class="line">$ mount /dev/ramblock1 /mnt/ramdisk1            <span class="comment"># 挂载</span></span><br><span class="line">$ mount /dev/ramblock2 /mnt/ramdisk2</span><br><span class="line"><span class="comment"># 做一些操作, 如读写/拷贝文件...</span></span><br><span class="line">$ mkdosfs /dev/ramblock                         <span class="comment"># 危险操作!!! 依旧能格式化整个磁盘.</span></span><br><span class="line"></span><br><span class="line">$ umount /mnt/ramdisk1</span><br><span class="line">$ umount /mnt/ramdisk2</span><br><span class="line">$ rmdir /mnt/ramdisk1</span><br><span class="line">$ rmdir /mnt/ramdisk2</span><br></pre></td></tr></table></figure>
<hr>
<p><strong><em>原创于 <a href="https://draapho.github.io/">DRA&amp;PHO</a></em></strong></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/01/19/1808-drv-usb2/" itemprop="url">
                  驱动之USB设备驱动程序
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2018-01-19T00:00:00+11:00" content="2018-01-19">
              2018-01-19
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/embedded-linux/" itemprop="url" rel="index">
                    <span itemprop="name">embedded linux</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h1><ul>
<li><a href="https://draapho.github.io/2017/11/23/1734-linux-content/">嵌入式linux学习目录</a></li>
<li><a href="https://draapho.github.io/2018/01/05/1802-drv-input/">驱动之input子系统</a></li>
<li><a href="https://draapho.github.io/2018/01/08/1803-drv-platform/">驱动之platform概念</a></li>
<li><a href="https://draapho.github.io/2018/02/08/1814-drv-rtc/">驱动之RTC分析</a></li>
<li><a href="https://draapho.github.io/2018/01/09/1804-drv-lcd/">驱动之LCD驱动框架和实现</a></li>
<li><a href="https://draapho.github.io/2018/01/11/1806-drv-ts/">驱动之触摸屏驱动框架和实现</a></li>
<li><a href="https://draapho.github.io/2018/01/18/1807-drv-usb1/">驱动之USB基础概念和框架</a></li>
<li><a href="https://draapho.github.io/2018/01/19/1808-drv-usb2/">驱动之USB设备驱动程序</a></li>
</ul>
<p>本文使用 linux-2.6.22.6 内核, 使用jz2440开发板.</p>
<h1 id="查看USB设备信息"><a href="#查看USB设备信息" class="headerlink" title="查看USB设备信息"></a>查看USB设备信息</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ cat /proc/bus/usb/devices           <span class="comment"># 查看USB设备信息, 但是jz2440里没有devices目录</span></span><br><span class="line">$ cat /proc/bus/input/devices         <span class="comment"># 接入的是USB鼠标, 是输入设备, 这里可以看到USB鼠标的信息</span></span><br><span class="line">I: Bus=0003 Vendor=046d Product=c52b Version=0111</span><br><span class="line">N: Name=<span class="string">"Logitech USB Receiver"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 接入USB鼠标后, 会显示如下信息, 可知被分配到input10.</span></span><br><span class="line">usb 1-1: new full speed USB device using s3c2410-ohci and address 8</span><br><span class="line">usb 1-1: configuration <span class="comment">#1 chosen from 1 choice</span></span><br><span class="line">input: Logitech USB Receiver as /class/input/input10</span><br><span class="line"></span><br><span class="line"><span class="comment"># 然后用如下指令, 可以查处VID, PID</span></span><br><span class="line">$ cat sys/class/input/input10/id/product</span><br><span class="line">c52b</span><br><span class="line">$ cat sys/class/input/input10/id/vendor</span><br><span class="line">046d</span><br><span class="line">$ cat sys/class/input/input10/id/version</span><br><span class="line">0111</span><br></pre></td></tr></table></figure>
<h1 id="源码-第一版"><a href="#源码-第一版" class="headerlink" title="源码, 第一版"></a>源码, 第一版</h1><p>第一版, 先实现USB框架.<br>使用 <code>LinK+ Device Driver Development</code> 生成并部分修改而来.</p>
<p><img src="https://draapho.github.io/images/1808/drv_usb.jpg" alt="drv_usb.jpg"></p>
<p>基本步骤如下:</p>
<ol>
<li>分配/设置 <code>struct usb_driver</code> 结构体<ul>
<li><code>.id_table</code></li>
<li><code>.probe</code></li>
<li><code>.disconnect</code></li>
</ul>
</li>
<li>注册 <code>usb_register</code></li>
</ol>
<h2 id="mousekey-c"><a href="#mousekey-c" class="headerlink" title="mousekey.c"></a>mousekey.c</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">===============================================================================</span></span><br><span class="line"><span class="comment">Driver Name     :       mousekey</span></span><br><span class="line"><span class="comment">Author          :       DRAAPHO</span></span><br><span class="line"><span class="comment">License         :       GPL</span></span><br><span class="line"><span class="comment">Description     :       LINUX DEVICE DRIVER PROJECT</span></span><br><span class="line"><span class="comment">===============================================================================</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"mousekey.h"</span></span></span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">"GPL"</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">"DRAAPHO"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* TODO Fill the USB device table */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">usb_device_id</span> <span class="title">mousekey_usb_ids</span>[] = &#123;</span></span><br><span class="line"><span class="comment">// 可以选择 USB设备类型, 或者 VID/PID 匹配驱动</span></span><br><span class="line">    &#123; USB_INTERFACE_INFO(USB_INTERFACE_CLASS_HID, USB_INTERFACE_SUBCLASS_BOOT, USB_INTERFACE_PROTOCOL_MOUSE) &#125;,</span><br><span class="line"><span class="comment">//    &#123; USB_DEVICE(0x046d,0xc52b) &#125;,  // idVendor(VID), idProduct(PID)</span></span><br><span class="line">    &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//struct usb_private &#123;</span></span><br><span class="line"><span class="comment">//  struct urb *urb;</span></span><br><span class="line"><span class="comment">//  struct usb_device *udev;</span></span><br><span class="line"><span class="comment">//&#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">usb_driver</span> <span class="title">mousekey_usb_driver</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">mousekey_probe</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    struct usb_interface *iface, <span class="keyword">const</span> struct usb_device_id *id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//    struct usb_private *priv;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// struct usb_device_id *id 只记录用于匹配的信息.</span></span><br><span class="line">    <span class="comment">// 因此这里需要通过 iface 获取 usb_device 的信息.</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">usb_device</span> *<span class="title">dev</span> = <span class="title">interface_to_usbdev</span>(<span class="title">iface</span>);</span></span><br><span class="line"></span><br><span class="line">    PINFO(<span class="string">"found USB mousekey! ==========&gt;\n"</span>);</span><br><span class="line">    printk(<span class="string">"USB address=%d\n"</span></span><br><span class="line">           <span class="string">"manufacturer=%s, product=%s, serial=%s\n"</span></span><br><span class="line">           <span class="string">"idVendor=0x%x, idProduct=0x%x\n"</span></span><br><span class="line">           <span class="string">"Device Class=%d, SubClass=%d, Protocol=%d\n"</span>,</span><br><span class="line">           dev-&gt;devnum,</span><br><span class="line">           dev-&gt;manufacturer, dev-&gt;product, dev-&gt;serial,</span><br><span class="line">           dev-&gt;descriptor.idVendor, dev-&gt;descriptor.idProduct,</span><br><span class="line">           dev-&gt;descriptor.bDeviceClass,</span><br><span class="line">           dev-&gt;descriptor.bDeviceSubClass,</span><br><span class="line">           dev-&gt;descriptor.bDeviceProtocol);</span><br><span class="line">    printk(<span class="string">"InterfaceNumber=%d, NumberOfEndpoints=%d\n"</span></span><br><span class="line">           <span class="string">"Interface Class=%d, SubClass=%d, Protocol=%d\n"</span>,</span><br><span class="line">           iface-&gt;cur_altsetting-&gt;desc.bInterfaceNumber,</span><br><span class="line">           iface-&gt;cur_altsetting-&gt;desc.bNumEndpoints,</span><br><span class="line">           iface-&gt;cur_altsetting-&gt;desc.bInterfaceClass,</span><br><span class="line">           iface-&gt;cur_altsetting-&gt;desc.bInterfaceSubClass,</span><br><span class="line">           iface-&gt;cur_altsetting-&gt;desc.bInterfaceProtocol);</span><br><span class="line"></span><br><span class="line"><span class="comment">//    priv = kzalloc(sizeof(*priv), GFP_KERNEL);</span></span><br><span class="line"><span class="comment">//    if (!priv) &#123;</span></span><br><span class="line"><span class="comment">//        PERR("Failed to allocate the device's private data\n");</span></span><br><span class="line"><span class="comment">//        return -ENOMEM;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    usb_set_intfdata(iface, priv);</span></span><br><span class="line"><span class="comment">//    priv-&gt;udev = interface_to_usbdev(iface);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mousekey_disconnect</span><span class="params">(struct usb_interface *iface)</span>    </span>&#123;</span><br><span class="line"><span class="comment">//    struct usb_private *priv = usb_get_intfdata(iface);</span></span><br><span class="line"></span><br><span class="line">    PINFO(<span class="string">"disconnect USB mousekey\n"</span>);</span><br><span class="line"><span class="comment">//    kfree(priv);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 1. 分配/设置 struct usb_driver */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">usb_driver</span> <span class="title">mousekey_usb_driver</span> = &#123;</span></span><br><span class="line">    .name           = DRIVER_NAME,</span><br><span class="line">    .id_table       = mousekey_usb_ids,</span><br><span class="line">    .probe          = mousekey_probe,</span><br><span class="line">    .disconnect     = mousekey_disconnect,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __<span class="function">init <span class="title">mousekey_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* TODO Auto-generated Function Stub */</span></span><br><span class="line">    <span class="keyword">int</span> res;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 2. 注册 */</span></span><br><span class="line">    res = usb_register(&amp;mousekey_usb_driver);</span><br><span class="line">    <span class="keyword">if</span>( res ) &#123;</span><br><span class="line">        PERR(<span class="string">"Error registering the USB Driver\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    PINFO(<span class="string">"INIT\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __<span class="function"><span class="built_in">exit</span> <span class="title">mousekey_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* TODO Auto-generated Function Stub */</span></span><br><span class="line">    PINFO(<span class="string">"EXIT\n"</span>);</span><br><span class="line">    usb_deregister(&amp;mousekey_usb_driver);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(mousekey_init);</span><br><span class="line">module_exit(mousekey_exit);</span><br></pre></td></tr></table></figure>
<h2 id="mousekey-h"><a href="#mousekey-h" class="headerlink" title="mousekey.h"></a>mousekey.h</h2><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DRIVER_NAME <span class="meta-string">"mousekey"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PDEBUG(fmt,args...) printk(KERN_DEBUG<span class="meta-string">"%s:"</span>fmt,DRIVER_NAME, ##args)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PERR(fmt,args...) printk(KERN_ER<span class="meta-string">R"%s:"</span>fmt,DRIVER_NAME,##args)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PINFO(fmt,args...) printk(KERN_INFO<span class="meta-string">"%s:"</span>fmt,DRIVER_NAME, ##args)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;linux/slab.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;linux/usb.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/hid.h&gt;</span></span></span><br></pre></td></tr></table></figure>
<h2 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h2><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">obj-m       := mousekey.o</span><br><span class="line">KERN_SRC    := /home/draapho/share/jz2440/kernel/linux-2.6.22.6/</span><br><span class="line">PWD         := <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"></span><br><span class="line"><span class="section">modules:</span></span><br><span class="line">    make -C <span class="variable">$(KERN_SRC)</span> M=<span class="variable">$(PWD)</span> modules</span><br><span class="line"></span><br><span class="line"><span class="section">install:</span></span><br><span class="line">    make -C <span class="variable">$(KERN_SRC)</span> M=<span class="variable">$(PWD)</span> modules_install</span><br><span class="line">    depmod -a</span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    make -C <span class="variable">$(KERN_SRC)</span> M=<span class="variable">$(PWD)</span> clean</span><br></pre></td></tr></table></figure>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>由于内核自带了USB鼠标驱动程序, 因此需要重新编译内核, 去掉内核的HID的USB功能</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Ubuntu 主机端</span></span><br><span class="line"><span class="comment"># pwd = ./linux-2.6.22.6_custom  复制一个新的内核源码目录</span></span><br><span class="line"></span><br><span class="line">$ make clean</span><br><span class="line">$ make menuconfig                               <span class="comment"># 去掉自带的HID USB驱动程序</span></span><br><span class="line"><span class="comment"># -&gt; Device Drivers</span></span><br><span class="line"><span class="comment">#   -&gt; HID Devices</span></span><br><span class="line"><span class="comment">#     &lt; &gt; USB Human Interface Device (full HID) support     # 取消HID的USB支持</span></span><br><span class="line"></span><br><span class="line">$ make uImage</span><br><span class="line"><span class="comment"># 烧录新的uImage</span></span><br><span class="line"><span class="comment"># 重启开发板进入uboot烧录界面, 按k准备烧录内核. 略过不表</span></span><br><span class="line">$ sudo dnw ./arch/arm/boot/uImage</span><br><span class="line"></span><br><span class="line"><span class="comment"># pwd = ~/share/jz2440/drivers/mousekey/        # USB鼠标驱动目录</span></span><br><span class="line">$ make modules                                  <span class="comment"># 生成mousekey.ko</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 开发板端, 开始测试</span></span><br><span class="line"><span class="comment"># pwd = ~/share/jz2440/drivers/mousekey/        # USB鼠标驱动目录, nfs</span></span><br><span class="line">$ insmod mousekey.ko                            <span class="comment"># 加载驱动, 开始测试</span></span><br><span class="line">usbcore: registered new interface driver mousekey</span><br><span class="line">mousekey:INIT</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开发板上接入USB鼠标, 会打印如下信息:</span></span><br><span class="line">usb 1-1: new full speed USB device using s3c2410-ohci and address 7</span><br><span class="line">usb 1-1: configuration <span class="comment">#1 chosen from 1 choice</span></span><br><span class="line">mousekey:found USB mousekey! ==========&gt;</span><br><span class="line">......                                          <span class="comment"># 打印具体信息. 可以看出Device不重要, Interface才重要.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 开发板上拔出USB鼠标, 会打印如下信息:</span></span><br><span class="line">usb 1-1: USB disconnect, address 7</span><br><span class="line">mousekey:disconnect USB mousekey</span><br><span class="line"></span><br><span class="line"><span class="comment"># rmmod mousekey</span></span><br><span class="line">mousekey:EXIT</span><br><span class="line">usbcore: deregistering interface driver mousekey</span><br></pre></td></tr></table></figure>
<h1 id="源码-第二版"><a href="#源码-第二版" class="headerlink" title="源码, 第二版"></a>源码, 第二版</h1><p>实现USB设备驱动, 将USB鼠标识别成按键.<br>左键输入<code>l</code>, 右键输入<code>s</code>, 中键输入<code>enter</code></p>
<ul>
<li><code>mousekey.h</code> 和 <code>Makefile</code> 参考 <code>源码, 第一版</code></li>
<li>这里因为是用的input子系统, 所以注册设备用了 <code>input_register_device</code>, 而不是 <code>usb_register_dev</code><ul>
<li>用 <code>input_register_device</code> 注册的话, 会在 <code>/dev/</code> 下面新增一个 <code>event*</code></li>
<li>用 <code>usb_register_dev</code> 注册的话, 会在 <code>/sys/class/usb/</code> 下面看到节点名称.</li>
</ul>
</li>
<li><code>input 子系统</code> 参考 <a href="https://draapho.github.io/2018/01/05/1802-drv-input/">驱动之input子系统</a><ol>
<li>分配一个input_dev变量</li>
<li>设置/初始化此变量</li>
<li>注册, input_register_device</li>
<li>硬件相关代码, open, close, event, sync等等.</li>
</ol>
</li>
<li><code>URB</code>, 即 <code>usb request block</code>. 基本用法:<ol>
<li>分配 URB. <code>usb_alloc_urb</code></li>
<li>初始化 URB 结构体 <code>struct urb</code></li>
<li>提交URB (开始通讯). <code>usb_submit_urb</code></li>
</ol>
</li>
<li>可参考 Linux 内核里的 <code>/drivers/hid/usbhid/usbmouse.c</code></li>
</ul>
<h2 id="mousekey-c-1"><a href="#mousekey-c-1" class="headerlink" title="mousekey.c"></a>mousekey.c</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">===============================================================================</span></span><br><span class="line"><span class="comment">Driver Name     :       mousekey</span></span><br><span class="line"><span class="comment">Author          :       DRAAPHO</span></span><br><span class="line"><span class="comment">License         :       GPL</span></span><br><span class="line"><span class="comment">Description     :       LINUX DEVICE DRIVER PROJECT</span></span><br><span class="line"><span class="comment">===============================================================================</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"mousekey.h"</span></span></span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">"GPL"</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">"DRAAPHO"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* TODO Fill the USB device table */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">usb_device_id</span> <span class="title">mousekey_usb_ids</span>[] = &#123;</span></span><br><span class="line"><span class="comment">// 可以选择 USB设备类型, 或者 VID/PID 匹配驱动</span></span><br><span class="line">    &#123; USB_INTERFACE_INFO(USB_INTERFACE_CLASS_HID, USB_INTERFACE_SUBCLASS_BOOT, USB_INTERFACE_PROTOCOL_MOUSE) &#125;,</span><br><span class="line"><span class="comment">//    &#123; USB_DEVICE(0x046d,0xc52b) &#125;,  // idVendor(VID), idProduct(PID)</span></span><br><span class="line">    &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">usb_driver</span> <span class="title">mousekey_usb_driver</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">usb_private</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">urb</span> *<span class="title">urb</span>;</span>                <span class="comment">// usb请求块</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">usb_device</span> *<span class="title">udev</span>;</span>        <span class="comment">// usb 设备</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">input_dev</span> *<span class="title">idev</span>;</span>         <span class="comment">// input 设备</span></span><br><span class="line">    <span class="keyword">char</span> *buf;                      <span class="comment">// urb 用的缓冲</span></span><br><span class="line">    <span class="keyword">dma_addr_t</span> buf_phys;            <span class="comment">// 缓冲物理地址, dma要用</span></span><br><span class="line">    <span class="keyword">int</span> len;                        <span class="comment">// 缓冲区大小</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mousekey_irq</span><span class="params">(struct urb *urb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">usb_private</span> *<span class="title">priv</span> = <span class="title">urb</span>-&gt;<span class="title">context</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">    <span class="comment">// 先打印查看usb鼠标发来的数据, 不同的鼠标数据格式略有不同!</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; priv-&gt;len; i++) &#123;</span><br><span class="line">        printk(<span class="string">"%02x "</span>, priv-&gt;buf[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    printk(<span class="string">"\n"</span>);</span><br><span class="line">    usb_submit_urb(priv-&gt;urb, GFP_KERNEL);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (urb-&gt;status) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:             <span class="comment">/* success */</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> -ECONNRESET:   <span class="comment">/* unlink */</span></span><br><span class="line">    <span class="keyword">case</span> -ENOENT:</span><br><span class="line">    <span class="keyword">case</span> -ESHUTDOWN:</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">/* -EPIPE:  should clear the halt */</span></span><br><span class="line">    <span class="keyword">default</span>:            <span class="comment">/* error */</span></span><br><span class="line">        <span class="keyword">goto</span> resubmit;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* USB鼠标数据含义</span></span><br><span class="line"><span class="comment">     * data[0]: bit0-左键, 1-按下, 0-松开</span></span><br><span class="line"><span class="comment">     *          bit1-右键, 1-按下, 0-松开</span></span><br><span class="line"><span class="comment">     *          bit2-中键, 1-按下, 0-松开</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    input_report_key(priv-&gt;idev, KEY_L,     priv-&gt;buf[<span class="number">0</span>] &amp; <span class="number">0x01</span>);</span><br><span class="line">    input_report_key(priv-&gt;idev, KEY_S,     priv-&gt;buf[<span class="number">0</span>] &amp; <span class="number">0x02</span>);</span><br><span class="line">    input_report_key(priv-&gt;idev, KEY_ENTER, priv-&gt;buf[<span class="number">0</span>] &amp; <span class="number">0x04</span>);</span><br><span class="line">    input_sync(priv-&gt;idev);</span><br><span class="line"></span><br><span class="line">resubmit:</span><br><span class="line">    <span class="comment">/* 重新提交urb */</span></span><br><span class="line">    usb_submit_urb (urb, GFP_ATOMIC);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">mousekey_probe</span><span class="params">(struct usb_interface *iface,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">const</span> struct usb_device_id *id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pipe;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">usb_private</span> *<span class="title">priv</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">usb_endpoint_descriptor</span> *<span class="title">endpoint</span>;</span></span><br><span class="line">    PINFO(<span class="string">"found USB mousekey! ==========&gt;\n"</span>);</span><br><span class="line"></span><br><span class="line">    priv = kzalloc(<span class="keyword">sizeof</span>(*priv), GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (!priv) &#123;</span><br><span class="line">        PERR(<span class="string">"Failed to allocate the device's private data\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">    &#125;</span><br><span class="line">    usb_set_intfdata(iface, priv);</span><br><span class="line">    priv-&gt;udev = interface_to_usbdev(iface);</span><br><span class="line"></span><br><span class="line">    printk(<span class="string">"USB address=%d\n"</span></span><br><span class="line">           <span class="string">"manufacturer=%s, product=%s, serial=%s\n"</span></span><br><span class="line">           <span class="string">"idVendor=0x%x, idProduct=0x%x\n"</span></span><br><span class="line">           <span class="string">"Device Class=%d, SubClass=%d, Protocol=%d\n"</span>,</span><br><span class="line">           priv-&gt;udev-&gt;devnum,</span><br><span class="line">           priv-&gt;udev-&gt;manufacturer, priv-&gt;udev-&gt;product, priv-&gt;udev-&gt;serial,</span><br><span class="line">           priv-&gt;udev-&gt;descriptor.idVendor, priv-&gt;udev-&gt;descriptor.idProduct,</span><br><span class="line">           priv-&gt;udev-&gt;descriptor.bDeviceClass,</span><br><span class="line">           priv-&gt;udev-&gt;descriptor.bDeviceSubClass,</span><br><span class="line">           priv-&gt;udev-&gt;descriptor.bDeviceProtocol);</span><br><span class="line">    printk(<span class="string">"InterfaceNumber=%d, NumberOfEndpoints=%d\n"</span></span><br><span class="line">           <span class="string">"Interface Class=%d, SubClass=%d, Protocol=%d\n"</span>,</span><br><span class="line">           iface-&gt;cur_altsetting-&gt;desc.bInterfaceNumber,</span><br><span class="line">           iface-&gt;cur_altsetting-&gt;desc.bNumEndpoints,</span><br><span class="line">           iface-&gt;cur_altsetting-&gt;desc.bInterfaceClass,</span><br><span class="line">           iface-&gt;cur_altsetting-&gt;desc.bInterfaceSubClass,</span><br><span class="line">           iface-&gt;cur_altsetting-&gt;desc.bInterfaceProtocol);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (iface-&gt;cur_altsetting-&gt;desc.bNumEndpoints != <span class="number">1</span>)     <span class="comment">// endpoint 不为1, 认为不是USB鼠标</span></span><br><span class="line">        <span class="keyword">return</span> -ENODEV;</span><br><span class="line">    endpoint = &amp;iface-&gt;cur_altsetting-&gt;endpoint[<span class="number">0</span>].desc;</span><br><span class="line">    <span class="keyword">if</span> (!usb_endpoint_is_int_in(endpoint))                  <span class="comment">// endpoint 传输属性必须是中断输入</span></span><br><span class="line">        <span class="keyword">return</span> -ENODEV;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* a. 分配一个input_dev */</span></span><br><span class="line">    priv-&gt;idev = input_allocate_device();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* b. 设置 */</span></span><br><span class="line">    <span class="comment">/* b.1 能产生哪类事件 */</span></span><br><span class="line">    set_bit(EV_KEY, priv-&gt;idev-&gt;evbit);</span><br><span class="line">    set_bit(EV_REP, priv-&gt;idev-&gt;evbit);</span><br><span class="line">    <span class="comment">/* b.2 能产生哪些事件 */</span></span><br><span class="line">    set_bit(KEY_L, priv-&gt;idev-&gt;keybit);                     <span class="comment">// 鼠标按键模拟键盘 L S ENTER</span></span><br><span class="line">    set_bit(KEY_S, priv-&gt;idev-&gt;keybit);</span><br><span class="line">    set_bit(KEY_ENTER, priv-&gt;idev-&gt;keybit);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* c. 注册 */</span></span><br><span class="line">    input_register_device(priv-&gt;idev);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* d. 硬件相关操作, 这里就是使用urb进行USB通讯 */</span></span><br><span class="line">    <span class="comment">/* 1. 分配 URB. */</span></span><br><span class="line">    priv-&gt;urb = usb_alloc_urb(<span class="number">0</span>, GFP_KERNEL);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 2. 初始化 URB 结构体 */</span></span><br><span class="line">    pipe = usb_rcvintpipe(priv-&gt;udev, endpoint-&gt;bEndpointAddress);  <span class="comment">// 指定USB通讯类型和endpoint</span></span><br><span class="line">    priv-&gt;len = endpoint-&gt;wMaxPacketSize;                           <span class="comment">// buf大小</span></span><br><span class="line">    priv-&gt;buf = usb_buffer_alloc(priv-&gt;udev, priv-&gt;len, GFP_ATOMIC, &amp;priv-&gt;buf_phys);</span><br><span class="line">    <span class="comment">// 分配buf, usb会使用dma进行数据传输, buf_phys用于记录buf的物理地址.</span></span><br><span class="line"></span><br><span class="line">    usb_fill_int_urb(priv-&gt;urb, priv-&gt;udev, pipe, priv-&gt;buf, priv-&gt;len, mousekey_irq, priv, endpoint-&gt;bInterval);</span><br><span class="line">    <span class="comment">// mousekey_irq, usb中断发生时的回调函数. priv, 回调函数用的私有参数, 可以是NULL. bInterval, USB HUB的轮询间隔时间.</span></span><br><span class="line">    priv-&gt;urb-&gt;transfer_dma = priv-&gt;buf_phys;                       <span class="comment">// dma传输需要物理地址</span></span><br><span class="line">    priv-&gt;urb-&gt;transfer_flags |= URB_NO_TRANSFER_DMA_MAP;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 3. 提交URB (开始通讯) */</span></span><br><span class="line">    usb_submit_urb(priv-&gt;urb, GFP_KERNEL);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mousekey_disconnect</span><span class="params">(struct usb_interface *iface)</span>    </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">usb_private</span> *<span class="title">priv</span> = <span class="title">usb_get_intfdata</span>(<span class="title">iface</span>);</span></span><br><span class="line">    PINFO(<span class="string">"disconnect USB mousekey\n"</span>);</span><br><span class="line"></span><br><span class="line">    usb_kill_urb(priv-&gt;urb);</span><br><span class="line">    usb_free_urb(priv-&gt;urb);</span><br><span class="line">    usb_buffer_free(priv-&gt;udev, priv-&gt;len, priv-&gt;buf, priv-&gt;buf_phys);</span><br><span class="line">    input_unregister_device(priv-&gt;idev);</span><br><span class="line">    input_free_device(priv-&gt;idev);</span><br><span class="line">    kfree(priv);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 1. 分配/设置 struct usb_driver */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">usb_driver</span> <span class="title">mousekey_usb_driver</span> = &#123;</span></span><br><span class="line">    .name           = DRIVER_NAME,</span><br><span class="line">    .id_table       = mousekey_usb_ids,</span><br><span class="line">    .probe          = mousekey_probe,</span><br><span class="line">    .disconnect     = mousekey_disconnect,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __<span class="function">init <span class="title">mousekey_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* TODO Auto-generated Function Stub */</span></span><br><span class="line">    <span class="keyword">int</span> res;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 2. 注册 */</span></span><br><span class="line">    res = usb_register(&amp;mousekey_usb_driver);</span><br><span class="line">    <span class="keyword">if</span>( res ) &#123;</span><br><span class="line">        PERR(<span class="string">"Error registering the USB Driver\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    PINFO(<span class="string">"INIT\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __<span class="function"><span class="built_in">exit</span> <span class="title">mousekey_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* TODO Auto-generated Function Stub */</span></span><br><span class="line">    PINFO(<span class="string">"EXIT\n"</span>);</span><br><span class="line">    usb_deregister(&amp;mousekey_usb_driver);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(mousekey_init);</span><br><span class="line">module_exit(mousekey_exit);</span><br></pre></td></tr></table></figure>
<h2 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 先按照此文之前的测试步骤烧录好无HID USB驱动的内核文件.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># pwd = ~/share/jz2440/drivers/mousekey/        # USB鼠标驱动目录, nfs</span></span><br><span class="line">$ insmod mousekey.ko                            <span class="comment"># 加载驱动, 开始测试</span></span><br><span class="line">usbcore: registered new interface driver mousekey</span><br><span class="line">mousekey:INIT</span><br><span class="line"></span><br><span class="line">$ ls /dev/event*                                <span class="comment"># 查看已有的event号</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 开发板上接入USB鼠标, 会打印如下信息:</span></span><br><span class="line">usb 1-1: new full speed USB device using s3c2410-ohci and address 7</span><br><span class="line">usb 1-1: configuration <span class="comment">#1 chosen from 1 choice</span></span><br><span class="line">mousekey:found USB mousekey! ==========&gt;</span><br><span class="line">......                                          <span class="comment"># 打印具体信息. 可以看出Device不重要, Interface才重要.</span></span><br><span class="line"></span><br><span class="line">$ ls /dev/event*                                <span class="comment"># 查看新增的event号, 就是此驱动的event</span></span><br><span class="line">/dev/event1                                     <span class="comment"># 譬如, 新增了event1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法一 (没有LCD):</span></span><br><span class="line">$ cat /dev/tty1</span><br><span class="line"><span class="comment"># 点击鼠标, 终端会显示输入, 但没有输出反馈.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法二 (没有LCD):</span></span><br><span class="line">$ hexdump /dev/event1</span><br><span class="line"><span class="comment"># 字节数|   秒    |  微秒   | 类  |code|  value      # 小端模式, 低位在前!</span></span><br><span class="line">0000000 0bb2 0000 0e48 000c 0001 0026 0001 0000    <span class="comment"># input_event(keydev, EV_KEY, key_val, 1)</span></span><br><span class="line">0000010 0bb2 0000 0e54 000c 0000 0000 0000 0000    <span class="comment"># input_sync(keydev);</span></span><br><span class="line">0000020 0bb2 0000 5815 000e 0001 0026 0000 0000    <span class="comment"># input_event(keydev, EV_KEY, key_val, 0)</span></span><br><span class="line">0000030 0bb2 0000 581f 000e 0000 0000 0000 0000    <span class="comment"># input_sync(keydev);</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法三 (有LCD, 没有QT)</span></span><br><span class="line">$ vi /etc/inittab</span><br><span class="line">    <span class="comment"># ===== 设置为如下内容 =====</span></span><br><span class="line">    ::sysinit:/etc/init.d/rcS</span><br><span class="line">    s3c2410_serial0::askfirst:-/bin/sh</span><br><span class="line">    <span class="comment"># 增加了下面一行, 用于屏幕打开终端</span></span><br><span class="line">    tty1::askfirst:-/bin/sh</span><br><span class="line">    ::ctrlaltdel:/sbin/reboot</span><br><span class="line">    ::shutdown:/bin/umount -a -r</span><br><span class="line">    <span class="comment"># ===== wq保存, 退出 =====</span></span><br><span class="line">$ reboot                                        <span class="comment"># 重启终端</span></span><br><span class="line"><span class="comment"># 这样点击鼠标就直接能在LCD上查看输入和输出了.</span></span><br></pre></td></tr></table></figure>
<hr>
<p><strong><em>原创于 <a href="https://draapho.github.io/">DRA&amp;PHO</a></em></strong></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/01/18/1807-drv-usb1/" itemprop="url">
                  驱动之USB基础概念和框架
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2018-01-18T00:00:00+11:00" content="2018-01-18">
              2018-01-18
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/embedded-linux/" itemprop="url" rel="index">
                    <span itemprop="name">embedded linux</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h1><ul>
<li><a href="https://draapho.github.io/2017/11/23/1734-linux-content/">嵌入式linux学习目录</a></li>
<li><a href="https://draapho.github.io/2018/01/05/1802-drv-input/">驱动之input子系统</a></li>
<li><a href="https://draapho.github.io/2018/01/08/1803-drv-platform/">驱动之platform概念</a></li>
<li><a href="https://draapho.github.io/2018/02/08/1814-drv-rtc/">驱动之RTC分析</a></li>
<li><a href="https://draapho.github.io/2018/01/09/1804-drv-lcd/">驱动之LCD驱动框架和实现</a></li>
<li><a href="https://draapho.github.io/2018/01/11/1806-drv-ts/">驱动之触摸屏驱动框架和实现</a></li>
<li><a href="https://draapho.github.io/2018/01/18/1807-drv-usb1/">驱动之USB基础概念和框架</a></li>
<li><a href="https://draapho.github.io/2018/01/19/1808-drv-usb2/">驱动之USB设备驱动程序</a></li>
</ul>
<p>本文使用 linux-2.6.22.6 内核, 使用jz2440开发板.</p>
<h1 id="USB基础知识"><a href="#USB基础知识" class="headerlink" title="USB基础知识"></a>USB基础知识</h1><ul>
<li>USB是主从结构的<ul>
<li>所有的USB传输，都是从USB主机这方发起! USB设备没有”主动”通知USB主机的能力。</li>
<li>例子：USB鼠标滑动一下立刻产生数据，但是它没有能力通知PC机来读数据，只能被动地等得PC机来读。</li>
</ul>
</li>
<li>USB的传输类型:<ul>
<li>控制传输(Control Transfers)：可靠，时间有保证，比如：USB设备的识别过程</li>
<li>批量传输(Bulk Transfers):可靠, 时间没有保证, 比如：U盘</li>
<li>中断传输(Interrupt Transfers)：可靠，实时，比如：USB鼠标</li>
<li>实时传输(Isochronous Transfers)：不可靠，实时，比如：USB摄像头</li>
</ul>
</li>
<li>USB的识别过程<ul>
<li>硬件上(USB2.0)<ul>
<li>USB主机端D-和D+接有15K下拉电阻, 未接USB设备时为低电平.</li>
<li>USB设备端D-或D+接有1.5K上拉电阻.</li>
<li>当USB设备插入USB主机端口时, 就会把D-或D+拉高, 让主机知道有设备接入了</li>
<li>把D-拉高是低速设备, 把D+拉高是高速设备</li>
</ul>
</li>
<li>软件上<ul>
<li>USB核心驱动程序负责: 识别USB设备, 给USB设备找到对应的驱动程序</li>
<li>当USB设备接入USB主机端后, 其默认的address是0. PC使用此adress与之通讯.</li>
<li>建立通讯后, USB核心驱动会给它分配一个新的address, 并查找有没有对应的驱动.</li>
</ul>
</li>
</ul>
</li>
<li>USB通讯速率<ul>
<li>低速设备(USB1.1, Low speed): 1.5Mb/s</li>
<li>全速设备(USB1.1, Full speed): 12Mb/s</li>
<li>高速设备(USB2.0, High speed): 480Mb/s</li>
<li>超高速设备(USB3.0, Super speed): 5Gb/s, 全双工</li>
</ul>
</li>
</ul>
<h1 id="USB主机端驱动框架"><a href="#USB主机端驱动框架" class="headerlink" title="USB主机端驱动框架"></a>USB主机端驱动框架</h1><p><img src="https://draapho.github.io/images/1807/usb_layer.png" alt="usb_layer.png"></p>
<p>各层作用如下:</p>
<ul>
<li>USB设备驱动 (USB Device Driver):<ol>
<li>让USB主机知道特定设备的数据含义</li>
<li>linux USB驱动开发就是在这一层. 更底层都是由linux内核完成的.</li>
</ol>
</li>
<li>USB核心层 (USB Core):<ol>
<li>识别USB设备: 分配并设置USB设备的address, 然后发出命令获取描述符.</li>
<li>查找并安装匹配的设备驱动</li>
<li>提供USB读写函数 (只是一个接口, 不知道数据含义)</li>
</ol>
</li>
<li>USB主机控制器 (USB HCD):<ol>
<li>需要支持的USB接口规范, 譬如USB2.0的设备要向下兼容必须包含USB1.1</li>
<li>OHCI: USB1.1 microsoft等创立的标准. 硬件功能强于软件功能</li>
<li>UHCI: USB1.1 intel创立的标准. 软件功能强于硬件功能, 因此芯片价格更低</li>
<li>EHCI: USB2.0</li>
<li>xHCI: USB3.0</li>
</ol>
</li>
</ul>
<h1 id="USB设备端概念"><a href="#USB设备端概念" class="headerlink" title="USB设备端概念"></a>USB设备端概念</h1><p><img src="https://draapho.github.io/images/1807/usb_dev.png" alt="usb_dev.png"></p>
<p>在USB从设备的结构中，从上到下分为:</p>
<ul>
<li>设备(device)<ul>
<li>设备即硬件概念上的USB从设备.</li>
<li><code>address</code> 的概念就是对设备而言的. 一条USB总线最多外接127个USB设备.</li>
<li>软件数据结构 <code>usb_device</code> <code>usb_device_descriptor</code></li>
</ul>
</li>
<li>配置(config)<ul>
<li>设备可以有一个或多个配置. 但任一时刻只有一个有效配置.</li>
<li>这里其实不难理解. 一个USB硬件设备可以允许多种功能.</li>
<li>个典型的例子是手机, 目前手机自动连接后, 都会弹出问你要用哪种模式连接电脑. 对应了不同的配置</li>
<li>因此选中一个配置后, 就从软件上决定了该USB设备的具体功能.</li>
<li>软件数据结构  <code>usb_device</code> <code>usb_host_config</code> <code>usb_config_descriptor</code></li>
</ul>
</li>
<li>接口(interface)<ul>
<li>接口表示逻辑设备, 包含零个或多个endpoint打包.</li>
<li>Linux的USB设备驱动是绑定到接口上的, 每个接口在主机看来都是一个独立的功能设备.</li>
<li>譬如录音接口, 播放接口, 数据接口等等.</li>
<li>软件数据结构  <code>usb_host_interface</code> <code>usb_interface_descriptor</code>.</li>
</ul>
</li>
<li>端点(endpoint)<ul>
<li>传输数据时, USB使用的就是endpoint概念. endpoint是数据通道.</li>
<li><code>endpoint0</code> 用于控制传输, 可双向传输.</li>
<li>除了 <code>endpoint0</code> 以外, 每个端点只支持一个方向的数据传输.</li>
<li>每个 endpoint 都有传输类型和传输方向.</li>
<li>传输类型: 控制传输, 批量传输, 中断传输, 实时传输.</li>
<li>传输方向: 输入(IN), 输出(OUT). 注意, 都是基于USB主机来说的! 读U盘, 数据方向就是输入.</li>
<li>譬如”读写U盘”, 软件上的概念是: 把数据写到U盘的 endpoint1 上去, 从U盘的 endpoint2 里读数据.</li>
<li>软件数据结构  <code>usb_device</code> <code>usb_host_endpoint</code> <code>usb_endpoint_descriptor</code></li>
</ul>
</li>
</ul>
<h1 id="Linux的USB驱动框架"><a href="#Linux的USB驱动框架" class="headerlink" title="Linux的USB驱动框架"></a>Linux的USB驱动框架</h1><p>以下我们用“usb_skel”的USB接口驱动实例（Linux/drivers/usb/usb-skeleton.c）来看看Linux的USB驱动框架：</p>
<p><img src="https://draapho.github.io/images/1807/usb_skel.png" alt="usb_skel.png"></p>
<h1 id="USB核心层源码分析"><a href="#USB核心层源码分析" class="headerlink" title="USB核心层源码分析"></a>USB核心层源码分析</h1><p>把USB设备接到开发板上，看输出信息:</p>
<blockquote>
<p>usb 1-1: new full speed USB device using s3c2410-ohci and address 2<br>usb 1-1: configuration #1 chosen from 1 choice</p>
</blockquote>
<p>拔掉后, 显示断开</p>
<blockquote>
<p>usb 1-1: USB disconnect, address 2</p>
</blockquote>
<p>尝试寻找源码: <code>grep &quot;USB device using&quot; -nR</code>, 找到 <code>drivers/usb/core/hub.c:2186</code> 文件.<br>由此开始分析.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">hub_irq                                 <span class="comment">// 硬件检测到USB总线状态变化</span></span><br><span class="line">    kick_khubd                          <span class="comment">// 踢一脚唤醒, 很形象</span></span><br><span class="line">        wake_up(&amp;khubd_wait);           <span class="comment">// 唤醒 hub_thread</span></span><br><span class="line"></span><br><span class="line">hub_thread</span><br><span class="line">    hub_events</span><br><span class="line">        hub_port_connect_change         <span class="comment">// USB总线状态改变事件处理函数</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">usb_device</span> *<span class="title">hdev</span> = <span class="title">hub</span>-&gt;<span class="title">hdev</span>             // 处理<span class="title">usb</span> <span class="title">hub</span>的, 忽略</span></span><br><span class="line"><span class="class">            <span class="title">struct</span> <span class="title">usb_device</span> *<span class="title">udev</span>;</span>                        <span class="comment">// usb设备, 后面具体分析 usb_device 数据结构</span></span><br><span class="line">            udev = usb_alloc_dev(hdev, hdev-&gt;bus, port1);   <span class="comment">// 申请usb设备, 然后初始化一些参数</span></span><br><span class="line">            choose_address(udev);                           <span class="comment">// 挑出一个空闲的address, 但没有告知这个USB设备</span></span><br><span class="line">            hub_port_init                                   <span class="comment">// 开始对新接入的usb设备进行初始化设置</span></span><br><span class="line">                dev_info                                    <span class="comment">// 打印了如下信息:</span></span><br><span class="line">                <span class="comment">// usb 1-1: new full speed USB device using s3c2410-ohci and address 2</span></span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">usb_device_descriptor</span> *<span class="title">buf</span>;</span>          <span class="comment">// buf 用于取出 bMaxPacketSize0 的大小</span></span><br><span class="line">                hub_set_address                             <span class="comment">// 这里, 才真正把address告诉USB设备</span></span><br><span class="line">                usb_get_device_descriptor(udev, <span class="number">8</span>);         <span class="comment">// 获取设备描述符, 兼容性考虑</span></span><br><span class="line">                usb_get_device_descriptor(udev, USB_DT_DEVICE_SIZE); <span class="comment">// 获取设备描述符</span></span><br><span class="line"></span><br><span class="line">            usb_new_device(udev)                            <span class="comment">// 查找USB设备驱动</span></span><br><span class="line">                usb_get_configuration(udev);                <span class="comment">// 把所有的描述符都读出来，并解析</span></span><br><span class="line">                    usb_get_descriptor                      <span class="comment">// 读描述符</span></span><br><span class="line">                    usb_parse_configuration                 <span class="comment">// 解析配置</span></span><br><span class="line">                device_add                                  <span class="comment">// platform概念的device部分函数.</span></span><br><span class="line">                <span class="comment">// 很熟悉的一个函数了, 见 "驱动之platform概念"</span></span><br><span class="line">                <span class="comment">// 1. 把device放入usb_bus_type的dev链表,</span></span><br><span class="line">                <span class="comment">// 2. 从usb_bus_type的driver链表里取出usb_driver, 把usb_interface和usb_driver的id_table比较</span></span><br><span class="line">                <span class="comment">// 3. 如果能匹配，调用usb_driver的probe</span></span><br></pre></td></tr></table></figure>
<p>下面, 简单分析一下USB的几个描述符结构体<br>结构体内各个变量的具体含义可参考: <a href="http://www.beyondlogic.org/usbnutshell/usb5.shtml" target="_blank" rel="noopener">USB Descriptors</a><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// usb_device 和 usb_host_XXX 可以在 include\linux\usb.h 看到</span></span><br><span class="line"><span class="comment">// usb_XXX_descriptor 可以在 include\linux\usb\Ch9.h 看到</span></span><br><span class="line"><span class="comment">// Ch9.h 就是 Chapter9 的缩写, 表示USB协议规范第9章</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">usb_device</span> &#123;</span>                         <span class="comment">// usb设备数据结构</span></span><br><span class="line">    <span class="keyword">int</span>     devnum;                         <span class="comment">/* Address on USB bus */</span></span><br><span class="line">    <span class="keyword">enum</span> usb_device_state   state;          <span class="comment">/* configured, not attached, etc */</span></span><br><span class="line">    <span class="keyword">enum</span> usb_device_speed   speed;          <span class="comment">/* high/full/low (or error) */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// usb_host_*** 里面就包含了 usb 描述符</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">usb_host_endpoint</span> <span class="title">ep0</span>;</span>           <span class="comment">// 特殊的 endpoint0 可双向传输</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">usb_device_descriptor</span> <span class="title">descriptor</span>;</span><span class="comment">/* Descriptor */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">usb_host_config</span> *<span class="title">config</span>;</span>         <span class="comment">/* All of the configs */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">usb_host_config</span> *<span class="title">actconfig</span>;</span>      <span class="comment">/* the active configuration */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">usb_host_endpoint</span> *<span class="title">ep_in</span>[16];</span>    <span class="comment">// 用做输入的 endpoint</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">usb_host_endpoint</span> *<span class="title">ep_out</span>[16];</span>   <span class="comment">// 用做输出的 endpoint</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* static strings from the device */</span></span><br><span class="line">    <span class="keyword">char</span> *product;                          <span class="comment">/* iProduct string, if present */</span></span><br><span class="line">    <span class="keyword">char</span> *manufacturer;                     <span class="comment">/* iManufacturer string, if present */</span></span><br><span class="line">    <span class="keyword">char</span> *serial;                           <span class="comment">/* iSerialNumber string, if present */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 整个USB描述符的数据结构框架如下:</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">usb_device</span>                   // <span class="title">usb</span>设备</span></span><br><span class="line"><span class="class">    <span class="title">struct</span> <span class="title">usb_device_descriptor</span>        // <span class="title">device</span> 描述符</span></span><br><span class="line"><span class="class">        __<span class="title">le16</span> <span class="title">bcdUSB</span>;</span>                      <span class="comment">// 设备支持的最高USB版本</span></span><br><span class="line">        __u8  bDeviceClass;                 <span class="comment">// 设备类别</span></span><br><span class="line">        __u8  bDeviceSubClass;              <span class="comment">// 设备子类</span></span><br><span class="line">        __u8  bDeviceProtocol;              <span class="comment">// 通信协议</span></span><br><span class="line">        __u8  bMaxPacketSize0;              <span class="comment">// endpoint0 通讯支持的最大数据量</span></span><br><span class="line">        __le16 idVendor;                    <span class="comment">// 经销商ID, 由USB机构分配给厂家</span></span><br><span class="line">        __le16 idProduct;                   <span class="comment">// 产品ID, 由USB厂家自己分配</span></span><br><span class="line">        __u8  iSerialNumber;                <span class="comment">// 产品序列号</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">usb_host_config</span>              // 主机记录的<span class="title">config</span>信息</span></span><br><span class="line"><span class="class">        <span class="title">struct</span> <span class="title">usb_config_descriptor</span>        // <span class="title">config</span> 描述符</span></span><br><span class="line"><span class="class">            __<span class="title">le16</span> <span class="title">wTotalLength</span>;</span>                <span class="comment">// config 总数据长度</span></span><br><span class="line">            __u8  bNumInterfaces;               <span class="comment">// config包含的interface数量</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">usb_interface</span>                // <span class="title">USB</span> <span class="title">interface</span></span></span><br><span class="line"><span class="class">            <span class="title">struct</span> <span class="title">usb_host_interface</span>           // 主机记录的<span class="title">interface</span>信息</span></span><br><span class="line"><span class="class">                <span class="title">struct</span> <span class="title">usb_interface_descriptor</span>     // <span class="title">interface</span>描述符</span></span><br><span class="line"><span class="class">                    __<span class="title">u8</span>  <span class="title">bInterfaceNumber</span>;</span>             <span class="comment">// interface编号</span></span><br><span class="line">                    __u8  bNumEndpoints;                <span class="comment">// 包含的endpoint数量</span></span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">usb_host_endpoint</span>            // 该<span class="title">interface</span>包含的<span class="title">endpoint</span></span></span><br><span class="line"><span class="class">            <span class="title">int</span> <span class="title">minor</span>;</span>                          <span class="comment">// 该USB interface的子设备号</span></span><br><span class="line">            <span class="comment">// 这里可以看出, Linux下, USB设备驱动是被绑到 USB interface 这一层的.</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">usb_host_endpoint</span>            // 主机记录的该<span class="title">USB</span>设备所有的<span class="title">endpoint</span></span></span><br><span class="line"><span class="class">        <span class="title">struct</span> <span class="title">usb_endpoint_descriptor</span>      // <span class="title">endpoint</span> 描述符</span></span><br><span class="line"><span class="class">            __<span class="title">u8</span>  <span class="title">bEndpointAddress</span>;</span>             <span class="comment">// endpoint 地址</span></span><br><span class="line">            __le16 wMaxPacketSize;              <span class="comment">// 支持的数据包大小</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">urb_list</span>;</span>          <span class="comment">// URB列表, USB Request Block.</span></span><br><span class="line">        <span class="comment">// URB 是linux内核给USB底层通讯抽象出来一种方法. 类似于TCP/IP协议里的socket方法.</span></span><br></pre></td></tr></table></figure></p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="http://blog.csdn.net/ahskx/article/details/50618983" target="_blank" rel="noopener">Linux的USB驱动分析</a></li>
<li><a href="http://www.embeddedlinux.org.cn/emb-linux/kernel-driver/201710/25-7669.html" target="_blank" rel="noopener">Linux USB驱动工作流程</a></li>
<li><a href="http://blog.csdn.net/u014276460/article/details/47292427" target="_blank" rel="noopener">浅谈USB驱动架构</a></li>
<li><a href="http://www.cnblogs.com/xiaojiang1025/p/6500574.html" target="_blank" rel="noopener">Linux usb子系统(一) _写一个usb鼠标驱动</a></li>
<li><a href="http://www.beyondlogic.org/usbnutshell/usb4.shtml" target="_blank" rel="noopener">USB in a NutShell</a></li>
<li><a href="http://www.beyondlogic.org/usbnutshell/usb5.shtml" target="_blank" rel="noopener">USB Descriptors</a></li>
<li><a href="https://www.crifan.com/files/doc/docbook/usb_basic/release/webhelp/four_hci_relations.html" target="_blank" rel="noopener">USB控制器类型：OHCI，UHCI，EHCI，xHCI</a></li>
</ul>
<hr>
<p><strong><em>原创于 <a href="https://draapho.github.io/">DRA&amp;PHO</a></em></strong></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/01/11/1806-drv-ts/" itemprop="url">
                  驱动之触摸屏驱动框架和实现
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2018-01-11T00:00:00+11:00" content="2018-01-11">
              2018-01-11
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/embedded-linux/" itemprop="url" rel="index">
                    <span itemprop="name">embedded linux</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h1><ul>
<li><a href="https://draapho.github.io/2017/11/23/1734-linux-content/">嵌入式linux学习目录</a></li>
<li><a href="https://draapho.github.io/2018/01/05/1802-drv-input/">驱动之input子系统</a></li>
<li><a href="https://draapho.github.io/2018/01/08/1803-drv-platform/">驱动之platform概念</a></li>
<li><a href="https://draapho.github.io/2018/02/08/1814-drv-rtc/">驱动之RTC分析</a></li>
<li><a href="https://draapho.github.io/2018/01/09/1804-drv-lcd/">驱动之LCD驱动框架和实现</a></li>
<li><a href="https://draapho.github.io/2018/01/11/1806-drv-ts/">驱动之触摸屏驱动框架和实现</a></li>
<li><a href="https://draapho.github.io/2018/01/18/1807-drv-usb1/">驱动之USB基础概念和框架</a></li>
<li><a href="https://draapho.github.io/2018/01/19/1808-drv-usb2/">驱动之USB设备驱动程序</a></li>
</ul>
<p>本文使用 linux-2.6.22.6 内核, 使用jz2440开发板.</p>
<h1 id="触摸屏驱动框架分析"><a href="#触摸屏驱动框架分析" class="headerlink" title="触摸屏驱动框架分析"></a>触摸屏驱动框架分析</h1><h2 id="回顾input子系统"><a href="#回顾input子系统" class="headerlink" title="回顾input子系统"></a>回顾input子系统</h2><p>在 <a href="https://draapho.github.io/2018/01/05/1802-drv-input/">驱动之input子系统</a> 一文里, 已经介绍了input子系统的框架.<br>触摸驱动作为输入设备, 很自然的需要用到input子系统.<br>input子系统, 核心点如下:</p>
<ul>
<li>软件抽象层, <code>/drivers/input/input.c</code> <code>/drviers/input/*dev.c</code><ul>
<li>初始化 <code>input_handler</code> 结构体变量, 负责软件抽象.</li>
<li>提供 <code>input_register_handler</code> 函数</li>
<li>提供 <code>input_register_handle(没有r)</code> 函数</li>
<li>提供 <code>input_register_device</code> 函数</li>
</ul>
</li>
<li>连接层, <code>/drviers/input/*dev.c</code><ul>
<li>初始化 <code>input_handle(没有r)</code> 结构体变量, 负责input系统的软硬层对接</li>
<li>注册此变量 <code>input_register_handle(没有r)</code></li>
<li>当注册handler或者device时, 会自动调用 <code>handler-&gt;connect</code>, 匹配并关联软件抽象层和硬件设备层.</li>
</ul>
</li>
<li>硬件设备层, 需要自己来实现<ul>
<li>负责具体的硬件功能实现.</li>
<li>初始化 <code>input_dev</code> 结构体变量</li>
<li>注册此变量 <code>input_register_device</code></li>
<li>实现硬件相关代码. 上报事件 <code>input_event</code></li>
</ul>
</li>
</ul>
<h2 id="s3c2410的触摸屏框架"><a href="#s3c2410的触摸屏框架" class="headerlink" title="s3c2410的触摸屏框架"></a>s3c2410的触摸屏框架</h2><p>s3c2410的触摸屏框架使用了input层. 硬件设备层又使用了platform框架来进一步隔离硬件上的通用代码和专用参数设置.<br>platform总线系统的详情可查看 <a href="https://draapho.github.io/2018/01/08/1803-drv-platform/">驱动之platform概念</a><br>整个框架层次如下图:</p>
<p><img src="https://draapho.github.io/images/1806/ts.png" alt="ts"></p>
<p>platform 总线框架具体分析如下:</p>
<ul>
<li>platform_driver <code>/drivers/input/touchscreen/s3c2410_ts.c</code><ul>
<li>调用 <code>platform_driver_register(&amp;s3c2410ts_driver);</code></li>
<li>匹配时, 执行 <code>s3c2410ts_probe</code><ul>
<li>和想的不一样, 用的 <code>evbit</code> 而不是 <code>absbit</code></li>
<li><code>ts.dev-&gt;evbit[0] = BIT(EV_SYN) | BIT(EV_KEY) | BIT(EV_ABS);</code></li>
<li><code>ts.dev-&gt;keybit[LONG(BTN_TOUCH)] = BIT(BTN_TOUCH);</code></li>
<li>然后向input系统注册device <code>input_register_device(ts.dev);</code></li>
</ul>
</li>
<li>timer超时函数 <code>touch_timer_fire</code>, 检测和发送触摸事件<ul>
<li><code>input_report_abs</code></li>
<li><code>input_report_key</code></li>
</ul>
</li>
</ul>
</li>
<li>platform_device <code>/arch/arm/plat-s3c24xx/common-smdk.c</code><ul>
<li>调用 <code>platform_add_devices(smdk_devs, ARRAY_SIZE(smdk_devs));</code></li>
<li><code>smdk_devs</code> 里面包含了 <code>s3c_device_ts</code></li>
<li>通过 <code>set_s3c2410ts_info</code> 函数来设置 <code>s3c_device_ts</code></li>
</ul>
</li>
</ul>
<h1 id="测试触摸屏驱动"><a href="#测试触摸屏驱动" class="headerlink" title="测试触摸屏驱动"></a>测试触摸屏驱动</h1><p>这里用的开发板自带的触摸屏驱动, 先测试一下.</p>
<h2 id="方法一-hexdump"><a href="#方法一-hexdump" class="headerlink" title="方法一 hexdump"></a>方法一 hexdump</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 开发板端</span></span><br><span class="line">$ ls /dev/event*</span><br><span class="line"><span class="comment"># 系统自带的一般是 event0, 对应触摸屏事件</span></span><br><span class="line">$ hexdump /dev/event0</span><br><span class="line"><span class="comment"># 字节数|   秒    |   微秒   |type|code|  value       # 小端模式, 低位在前!</span></span><br><span class="line">0000000 04aa 0000 8555 000b 0003 0000 0138 0000     <span class="comment"># input_report_abs(ts.dev, ABS_X, ts.xp);</span></span><br><span class="line">0000010 04aa 0000 8569 000b 0003 0001 020e 0000     <span class="comment"># input_report_abs(ts.dev, ABS_Y, ts.yp);</span></span><br><span class="line">0000020 04aa 0000 856e 000b 0001 014a 0001 0000     <span class="comment"># input_report_key(ts.dev, BTN_TOUCH, 1);</span></span><br><span class="line">0000030 04aa 0000 8570 000b 0003 0018 0001 0000     <span class="comment"># input_report_abs(ts.dev, ABS_PRESSURE, 1);</span></span><br><span class="line">0000040 04aa 0000 8573 000b 0000 0000 0000 0000     <span class="comment"># input_sync(ts.dev);</span></span><br></pre></td></tr></table></figure>
<h2 id="方法二-tslib"><a href="#方法二-tslib" class="headerlink" title="方法二 tslib"></a>方法二 tslib</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Ubuntu 主机端, 需要先编译 tslib</span></span><br><span class="line"><span class="comment"># pwd = ./drivers/ts</span></span><br><span class="line">$ tar xzf tslib-1.4.tar.gz</span><br><span class="line">$ <span class="built_in">cd</span> tslib</span><br><span class="line">$ ./autogen.sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 报错: ./autogen.sh: 4: autoreconf: not found</span></span><br><span class="line"><span class="comment"># 报错: configure.ac:25: error: possibly undefined macro: AC_DISABLE_STATIC</span></span><br><span class="line"><span class="comment"># sudo apt-get install autoconf automake libtool # 安装相关软件即可</span></span><br><span class="line"></span><br><span class="line">$ mkdir tmp</span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">"ac_cv_func_malloc_0_nonnull=yes"</span> &gt;arm-linux.cache</span><br><span class="line">$ ./configure --host=arm-linux --cache-file=arm-linux.cache --prefix=$(<span class="built_in">pwd</span>)/tmp</span><br><span class="line">$ make</span><br><span class="line">$ make install</span><br><span class="line">$ ll tmp/bin                                <span class="comment"># 查看一下编译结果.</span></span><br><span class="line">$ vi tmp/etc/ts.conf</span><br><span class="line"><span class="comment"># ===== 修改第二行 =====</span></span><br><span class="line">    <span class="comment"># module_raw input</span></span><br><span class="line">    <span class="comment"># 取消注释, 改为:</span></span><br><span class="line">    module_raw input</span><br><span class="line"><span class="comment"># ===== wq 保存退出 =====</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 开发板端</span></span><br><span class="line"><span class="comment"># pwd = ./drivers/ts/tslib/tmp              # 挂载的nfs文件系统</span></span><br><span class="line">$ cp * -rf /                                <span class="comment"># 拷贝到根目录</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置环境变量</span></span><br><span class="line">$ <span class="built_in">export</span> TSLIB_TSDEVICE=/dev/event0         <span class="comment"># 必须对应ts的event</span></span><br><span class="line">$ <span class="built_in">export</span> TSLIB_CALIBFILE=/etc/pointercal</span><br><span class="line">$ <span class="built_in">export</span> TSLIB_CONFFILE=/etc/ts.conf</span><br><span class="line">$ <span class="built_in">export</span> TSLIB_PLUGINDIR=/lib/ts</span><br><span class="line">$ <span class="built_in">export</span> TSLIB_CONSOLEDEVICE=none</span><br><span class="line">$ <span class="built_in">export</span> TSLIB_FBDEVICE=/dev/fb0            <span class="comment"># 对应屏幕的framebuffer</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 开始测试</span></span><br><span class="line">$ ts_calibrate                              <span class="comment"># 五点校验</span></span><br><span class="line">xres = 480, yres = 272</span><br><span class="line">Top left :</span><br><span class="line">Top right :</span><br><span class="line">Bot right :</span><br><span class="line">Bot left :</span><br><span class="line">Center :</span><br><span class="line">$ ts_test                                   <span class="comment"># 开始测试</span></span><br><span class="line">时间: X坐标 Y坐标 是否按下</span><br><span class="line">$ ts_print_raw                              <span class="comment"># 打印原始数据</span></span><br><span class="line">时间: X电压值 Y电压值 是否按下</span><br></pre></td></tr></table></figure>
<h1 id="源码-第一版"><a href="#源码-第一版" class="headerlink" title="源码, 第一版"></a>源码, 第一版</h1><p>第一版源码, 让触摸屏工作起来即可</p>
<h2 id="ts-c"><a href="#ts-c" class="headerlink" title="ts.c"></a>ts.c</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/slab.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/input.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/serio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/delay.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/platform_device.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/clk.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/io.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/irq.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/plat-s3c24xx/ts.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/arch/regs-adc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/arch/regs-gpio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">"GPL"</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">s3c_ts_regs</span> &#123;</span>                                <span class="comment">// 触摸屏寄存器</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> adccon;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> adctsc;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> adcdly;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> adcdat0;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> adcdat1;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> adcupdn;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">input_dev</span> *<span class="title">s3c_ts_dev</span>;</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">volatile</span> <span class="class"><span class="keyword">struct</span> <span class="title">s3c_ts_regs</span> *<span class="title">s3c_ts_regs</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 几个模式的设置</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">enter_wait_pen_down_mode</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    s3c_ts_regs-&gt;adctsc = <span class="number">0xd3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">enter_wait_pen_up_mode</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    s3c_ts_regs-&gt;adctsc = <span class="number">0x1d3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">enter_measure_xy_mode</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    s3c_ts_regs-&gt;adctsc = (<span class="number">1</span>&lt;&lt;<span class="number">3</span>)|(<span class="number">1</span>&lt;&lt;<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">start_adc</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    s3c_ts_regs-&gt;adccon |= (<span class="number">1</span>&lt;&lt;<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 触摸事件中断, 按下或松开触摸屏</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> irqreturn_t <span class="title">pen_down_up_irq</span><span class="params">(<span class="keyword">int</span> irq, <span class="keyword">void</span> *dev_id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s3c_ts_regs-&gt;adcdat0 &amp; (<span class="number">1</span>&lt;&lt;<span class="number">15</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        printk(<span class="string">"pen up\n"</span>);</span><br><span class="line">        enter_wait_pen_down_mode();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//printk("pen down\n");</span></span><br><span class="line">        <span class="comment">//enter_wait_pen_up_mode();</span></span><br><span class="line">        enter_measure_xy_mode();                    <span class="comment">// 按下了, 准备开始测量</span></span><br><span class="line">        start_adc();                                <span class="comment">// 测量adc</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> IRQ_HANDLED;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ADC完成中断</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> irqreturn_t <span class="title">adc_irq</span><span class="params">(<span class="keyword">int</span> irq, <span class="keyword">void</span> *dev_id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    printk(<span class="string">"adc_irq cnt = %d, x = %d, y = %d\n"</span>, ++cnt,</span><br><span class="line">        s3c_ts_regs-&gt;adcdat0 &amp; <span class="number">0x3ff</span>, s3c_ts_regs-&gt;adcdat1 &amp; <span class="number">0x3ff</span>);</span><br><span class="line">                                                    <span class="comment">// 打印测量结果</span></span><br><span class="line">    enter_wait_pen_up_mode();</span><br><span class="line">    <span class="keyword">return</span> IRQ_HANDLED;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">s3c_ts_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">clk</span>* <span class="title">clk</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 1. 分配一个input_dev结构体 */</span></span><br><span class="line">    s3c_ts_dev = input_allocate_device();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 2. 设置 */</span></span><br><span class="line">    <span class="comment">/* 2.1 能产生哪类事件 */</span></span><br><span class="line">    set_bit(EV_KEY, s3c_ts_dev-&gt;evbit);             <span class="comment">// 按键事件</span></span><br><span class="line">    set_bit(EV_ABS, s3c_ts_dev-&gt;evbit);             <span class="comment">// 绝对坐标事件</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 2.2 能产生按键事件里的哪些值 */</span></span><br><span class="line">    set_bit(BTN_TOUCH, s3c_ts_dev-&gt;keybit);         <span class="comment">// 键盘的虚拟按键</span></span><br><span class="line"></span><br><span class="line">    input_set_abs_params(s3c_ts_dev, ABS_X, <span class="number">0</span>, <span class="number">0x3FF</span>, <span class="number">0</span>, <span class="number">0</span>);    <span class="comment">// 绝对坐标范围设置</span></span><br><span class="line">    input_set_abs_params(s3c_ts_dev, ABS_Y, <span class="number">0</span>, <span class="number">0x3FF</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    input_set_abs_params(s3c_ts_dev, ABS_PRESSURE, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>); <span class="comment">// 是否按压, 理解为Z轴即可.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 3. 注册 */</span></span><br><span class="line">    input_register_device(s3c_ts_dev);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 4. 硬件相关的操作 */</span></span><br><span class="line">    <span class="comment">/* 4.1 使能时钟(CLKCON[15]) */</span></span><br><span class="line">    clk = clk_get(<span class="literal">NULL</span>, <span class="string">"adc"</span>);</span><br><span class="line">    clk_enable(clk);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 4.2 设置S3C2440的ADC/TS寄存器 */</span></span><br><span class="line">    s3c_ts_regs = ioremap(<span class="number">0x58000000</span>, <span class="keyword">sizeof</span>(struct s3c_ts_regs));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* bit[14]  : 1-A/D converter prescaler enable</span></span><br><span class="line"><span class="comment">     * bit[13:6]: A/D converter prescaler value,</span></span><br><span class="line"><span class="comment">     *            49, ADCCLK=PCLK/(49+1)=50MHz/(49+1)=1MHz</span></span><br><span class="line"><span class="comment">     * bit[0]: A/D conversion starts by enable. 先设为0</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    s3c_ts_regs-&gt;adccon = (<span class="number">1</span>&lt;&lt;<span class="number">14</span>)|(<span class="number">49</span>&lt;&lt;<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使能两个中断</span></span><br><span class="line">    request_irq(IRQ_TC, pen_down_up_irq, IRQF_SAMPLE_RANDOM, <span class="string">"ts_pen"</span>, <span class="literal">NULL</span>);</span><br><span class="line">    request_irq(IRQ_ADC, adc_irq, IRQF_SAMPLE_RANDOM, <span class="string">"adc"</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    enter_wait_pen_down_mode();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">s3c_ts_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    free_irq(IRQ_TC, <span class="literal">NULL</span>);</span><br><span class="line">    iounmap(s3c_ts_regs);</span><br><span class="line">    input_unregister_device(s3c_ts_dev);</span><br><span class="line">    input_free_device(s3c_ts_dev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(s3c_ts_init);</span><br><span class="line">module_exit(s3c_ts_exit);</span><br></pre></td></tr></table></figure>
<h2 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">obj-m       := ts.o</span><br><span class="line">KERN_SRC    := /home/draapho/share/jz2440/kernel/linux<span class="number">-2.6</span><span class="number">.22</span><span class="number">.6</span>/</span><br><span class="line">PWD         := $(shell pwd)</span><br><span class="line"></span><br><span class="line">modules:</span><br><span class="line">    make -C $(KERN_SRC) M=$(PWD) modules</span><br><span class="line"></span><br><span class="line">clean:</span><br><span class="line">    make -C $(KERN_SRC) M=$(PWD) clean</span><br></pre></td></tr></table></figure>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>由于内核自带了驱动程序, 因此需要重新编译内核, 去掉触摸驱动</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"># Ubuntu 主机端</span><br><span class="line"># pwd = ./linux-2.6.22.6_custom  复制一个新的内核源码目录</span><br><span class="line"></span><br><span class="line">$ make clean</span><br><span class="line">$ make menuconfig                               # 去掉自带的触摸屏驱动程序</span><br><span class="line"># -&gt; Device Drivers</span><br><span class="line">#   -&gt; Input device support</span><br><span class="line">#     -&gt; Touchscreens</span><br><span class="line">#       &lt; &gt; S3C2410/S3C2440 touchscreens        # 取消触摸屏驱动</span><br><span class="line"></span><br><span class="line">$ make uImage</span><br><span class="line"># 烧录新的uImage</span><br><span class="line"># 重启开发板进入uboot烧录界面, 按k准备烧录内核. 略过不表</span><br><span class="line">$ sudo dnw ./arch/arm/boot/uImage</span><br><span class="line"></span><br><span class="line"># pwd = ~/share/jz2440/drivers/ts/              # 触摸屏驱动目录</span><br><span class="line">$ make modules                                  # 生成ts.ko</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 开发板端</span><br><span class="line"># pwd = ~/share/jz2440/drivers/ts/              # 触摸屏驱动目录, nfs</span><br><span class="line">$ insmod ts.ko                                  # 加载驱动, 开始测试</span><br><span class="line">input: Unspecified device as /class/input/input0</span><br><span class="line">adc_irq cnt = 1, x = 17, y = 991</span><br><span class="line">pen up</span><br><span class="line"># 点击触摸屏, 就会打印出坐标, 释放时, 就会显示 pen up</span><br><span class="line"># 至此, 说明触摸屏的硬件设置没有问题!</span><br></pre></td></tr></table></figure>
<h1 id="源码-第二版"><a href="#源码-第二版" class="headerlink" title="源码, 第二版"></a>源码, 第二版</h1><p>第一版的源码用于检测触摸屏的硬件设置是否正确, 触摸屏是否能正常工作.<br>但在实际情况下, 对触摸屏的ADC值还需要进行软件滤波等工作, 以提高可用性.<br>另外我们去掉了printk的打印信息, 改为 <code>input_report_abs</code> <code>input_report_key</code></p>
<h2 id="ts-c-1"><a href="#ts-c-1" class="headerlink" title="ts.c"></a>ts.c</h2><p>为方便理解, 减少代码量, 和源码第一版相同的部分删掉了.<br>譬如头文件, 小函数等.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">timer_list</span> <span class="title">ts_timer</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 软件过滤用, 如果4次ADC值的差值过大, 直接丢弃</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">s3c_filter_ts</span><span class="params">(<span class="keyword">int</span> x[], <span class="keyword">int</span> y[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> ERR_LIMIT 10                                    <span class="comment">// 这是个经验值</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> avr_x, avr_y;</span><br><span class="line">    <span class="keyword">int</span> det_x, det_y;</span><br><span class="line"></span><br><span class="line">    avr_x = (x[<span class="number">0</span>] + x[<span class="number">1</span>])/<span class="number">2</span>;                                <span class="comment">// 获得数据0,1的平均值</span></span><br><span class="line">    avr_y = (y[<span class="number">0</span>] + y[<span class="number">1</span>])/<span class="number">2</span>;</span><br><span class="line">    det_x = (x[<span class="number">2</span>] &gt; avr_x) ? (x[<span class="number">2</span>] - avr_x) : (avr_x - x[<span class="number">2</span>]);<span class="comment">// 求数据2的差值</span></span><br><span class="line">    det_y = (y[<span class="number">2</span>] &gt; avr_y) ? (y[<span class="number">2</span>] - avr_y) : (avr_y - y[<span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">if</span> ((det_x &gt; ERR_LIMIT) || (det_y &gt; ERR_LIMIT))         <span class="comment">// 差值太大, 丢弃整组数据</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    avr_x = (x[<span class="number">1</span>] + x[<span class="number">2</span>])/<span class="number">2</span>;                                <span class="comment">// 获得数据1,2的平均值</span></span><br><span class="line">    avr_y = (y[<span class="number">1</span>] + y[<span class="number">2</span>])/<span class="number">2</span>;</span><br><span class="line">    det_x = (x[<span class="number">3</span>] &gt; avr_x) ? (x[<span class="number">3</span>] - avr_x) : (avr_x - x[<span class="number">3</span>]);<span class="comment">// 求数据3的差值</span></span><br><span class="line">    det_y = (y[<span class="number">3</span>] &gt; avr_y) ? (y[<span class="number">3</span>] - avr_y) : (avr_y - y[<span class="number">3</span>]);</span><br><span class="line">    <span class="keyword">if</span> ((det_x &gt; ERR_LIMIT) || (det_y &gt; ERR_LIMIT))         <span class="comment">// 差值太大, 丢弃整组数据</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定时器, 用去测量触摸屏长按和移动. 在adc中断函数里触发</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">s3c_ts_timer_function</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s3c_ts_regs-&gt;adcdat0 &amp; (<span class="number">1</span>&lt;&lt;<span class="number">15</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 已经松开 */</span>                                       <span class="comment">// 向input层报告事件</span></span><br><span class="line">        input_report_abs(s3c_ts_dev, ABS_PRESSURE, <span class="number">0</span>);</span><br><span class="line">        input_report_key(s3c_ts_dev, BTN_TOUCH, <span class="number">0</span>);</span><br><span class="line">        input_sync(s3c_ts_dev);</span><br><span class="line">        enter_wait_pen_down_mode();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 测量X/Y坐标 */</span></span><br><span class="line">        enter_measure_xy_mode();                            <span class="comment">// 没有松开, 周期性测量</span></span><br><span class="line">        start_adc();                                        <span class="comment">// 触发adc, adc完成后又会触发定时器, 形成周期测量.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 触摸事件中断, 按下或松开触摸屏</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> irqreturn_t <span class="title">pen_down_up_irq</span><span class="params">(<span class="keyword">int</span> irq, <span class="keyword">void</span> *dev_id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s3c_ts_regs-&gt;adcdat0 &amp; (<span class="number">1</span>&lt;&lt;<span class="number">15</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//printk("pen up\n");                               // 松开, 向input层报告事件</span></span><br><span class="line">        input_report_abs(s3c_ts_dev, ABS_PRESSURE, <span class="number">0</span>);</span><br><span class="line">        input_report_key(s3c_ts_dev, BTN_TOUCH, <span class="number">0</span>);</span><br><span class="line">        input_sync(s3c_ts_dev);</span><br><span class="line">        enter_wait_pen_down_mode();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//printk("pen down\n");</span></span><br><span class="line">        <span class="comment">//enter_wait_pen_up_mode();</span></span><br><span class="line">        enter_measure_xy_mode();                            <span class="comment">// 刚按下, 开始测量</span></span><br><span class="line">        start_adc();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> IRQ_HANDLED;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ADC完成中断</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> irqreturn_t <span class="title">adc_irq</span><span class="params">(<span class="keyword">int</span> irq, <span class="keyword">void</span> *dev_id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> x[<span class="number">4</span>], y[<span class="number">4</span>];</span><br><span class="line">    <span class="keyword">int</span> adcdat0, adcdat1;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 优化措施2: 如果ADC完成时, 发现触摸笔已经松开, 则丢弃此次结果 */</span></span><br><span class="line">    adcdat0 = s3c_ts_regs-&gt;adcdat0;</span><br><span class="line">    adcdat1 = s3c_ts_regs-&gt;adcdat1;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (s3c_ts_regs-&gt;adcdat0 &amp; (<span class="number">1</span>&lt;&lt;<span class="number">15</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 已经松开 */</span></span><br><span class="line">        cnt = <span class="number">0</span>;</span><br><span class="line">        input_report_abs(s3c_ts_dev, ABS_PRESSURE, <span class="number">0</span>);</span><br><span class="line">        input_report_key(s3c_ts_dev, BTN_TOUCH, <span class="number">0</span>);</span><br><span class="line">        input_sync(s3c_ts_dev);</span><br><span class="line">        enter_wait_pen_down_mode();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// printk("adc_irq cnt = %d, x = %d, y = %d\n", ++cnt, adcdat0 &amp; 0x3ff, adcdat1 &amp; 0x3ff);</span></span><br><span class="line">        <span class="comment">/* 优化措施3: 多次测量求平均值 */</span></span><br><span class="line">        x[cnt] = adcdat0 &amp; <span class="number">0x3ff</span>;</span><br><span class="line">        y[cnt] = adcdat1 &amp; <span class="number">0x3ff</span>;</span><br><span class="line">        ++cnt;</span><br><span class="line">        <span class="keyword">if</span> (cnt == <span class="number">4</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* 优化措施4: 软件过滤 */</span></span><br><span class="line">            <span class="keyword">if</span> (s3c_filter_ts(x, y))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//printk("x = %d, y = %d\n", (x[0]+x[1]+x[2]+x[3])/4, (y[0]+y[1]+y[2]+y[3])/4);</span></span><br><span class="line">                input_report_abs(s3c_ts_dev, ABS_X, (x[<span class="number">0</span>]+x[<span class="number">1</span>]+x[<span class="number">2</span>]+x[<span class="number">3</span>])/<span class="number">4</span>);</span><br><span class="line">                input_report_abs(s3c_ts_dev, ABS_Y, (y[<span class="number">0</span>]+y[<span class="number">1</span>]+y[<span class="number">2</span>]+y[<span class="number">3</span>])/<span class="number">4</span>);</span><br><span class="line">                input_report_abs(s3c_ts_dev, ABS_PRESSURE, <span class="number">1</span>);</span><br><span class="line">                input_report_key(s3c_ts_dev, BTN_TOUCH, <span class="number">1</span>);</span><br><span class="line">                input_sync(s3c_ts_dev);</span><br><span class="line">            &#125;</span><br><span class="line">            cnt = <span class="number">0</span>;</span><br><span class="line">            enter_wait_pen_up_mode();</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 启动定时器处理长按/滑动的情况 */</span></span><br><span class="line">            mod_timer(&amp;ts_timer, jiffies + HZ/<span class="number">100</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            enter_measure_xy_mode();</span><br><span class="line">            start_adc();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> IRQ_HANDLED;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">s3c_ts_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ......                          <span class="comment">// 硬件配置都一样, 略过</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使能两个中断</span></span><br><span class="line">    request_irq(IRQ_TC, pen_down_up_irq, IRQF_SAMPLE_RANDOM, <span class="string">"ts_pen"</span>, <span class="literal">NULL</span>);</span><br><span class="line">    request_irq(IRQ_ADC, adc_irq, IRQF_SAMPLE_RANDOM, <span class="string">"adc"</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 优化措施1:</span></span><br><span class="line"><span class="comment">     * 设置ADCDLY为最大值, 这使得电压稳定后再发出IRQ_TC中断</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    s3c_ts_regs-&gt;adcdly = <span class="number">0xffff</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 优化措施5: 使用定时器处理长按,滑动的情况 */</span></span><br><span class="line">    init_timer(&amp;ts_timer);</span><br><span class="line">    ts_timer.function = s3c_ts_timer_function;</span><br><span class="line">    add_timer(&amp;ts_timer);</span><br><span class="line"></span><br><span class="line">    enter_wait_pen_down_mode();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">s3c_ts_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    free_irq(IRQ_TC, <span class="literal">NULL</span>);</span><br><span class="line">    free_irq(IRQ_ADC, <span class="literal">NULL</span>);</span><br><span class="line">    iounmap(s3c_ts_regs);</span><br><span class="line">    input_unregister_device(s3c_ts_dev);</span><br><span class="line">    input_free_device(s3c_ts_dev);</span><br><span class="line">    del_timer(&amp;ts_timer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 先按照此文之前的测试步骤设置好tslib, 烧录无触摸屏驱动的内核文件.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 开发板端</span></span><br><span class="line"><span class="comment"># pwd = ./drivers/ts/                               # 挂载的nfs文件系统</span></span><br><span class="line">$ rmmod ts                                          <span class="comment"># 卸载源码第一版加载的触摸屏驱动</span></span><br><span class="line">$ ls /dev/event*</span><br><span class="line">$ insmod ts.ko                                      <span class="comment"># 加载驱动</span></span><br><span class="line">$ ls /dev/event*</span><br><span class="line"><span class="comment"># 多出的一个event, 就是触摸屏的event, 譬如event0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法一, 用hexdump测试</span></span><br><span class="line"></span><br><span class="line">$ hexdump /dev/event0</span><br><span class="line"><span class="comment"># 字节数|   秒    |   微秒   |type|code|  value       # 小端模式, 低位在前!</span></span><br><span class="line">0000000 04aa 0000 8555 000b 0003 0000 0138 0000     <span class="comment"># input_report_abs(ts.dev, ABS_X, ts.xp);</span></span><br><span class="line">0000010 04aa 0000 8569 000b 0003 0001 020e 0000     <span class="comment"># input_report_abs(ts.dev, ABS_Y, ts.yp);</span></span><br><span class="line">0000030 04aa 0000 8570 000b 0003 0018 0001 0000     <span class="comment"># input_report_abs(ts.dev, ABS_PRESSURE, 1);</span></span><br><span class="line">0000020 04aa 0000 856e 000b 0001 014a 0001 0000     <span class="comment"># input_report_key(ts.dev, BTN_TOUCH, 1);</span></span><br><span class="line">0000040 04aa 0000 8573 000b 0000 0000 0000 0000     <span class="comment"># input_sync(ts.dev);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法二, 用tslib测试</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置环境变量</span></span><br><span class="line">$ <span class="built_in">export</span> TSLIB_TSDEVICE=/dev/event0         <span class="comment"># 必须对应ts的event</span></span><br><span class="line">$ <span class="built_in">export</span> TSLIB_CALIBFILE=/etc/pointercal</span><br><span class="line">$ <span class="built_in">export</span> TSLIB_CONFFILE=/etc/ts.conf</span><br><span class="line">$ <span class="built_in">export</span> TSLIB_PLUGINDIR=/lib/ts</span><br><span class="line">$ <span class="built_in">export</span> TSLIB_CONSOLEDEVICE=none</span><br><span class="line">$ <span class="built_in">export</span> TSLIB_FBDEVICE=/dev/fb0            <span class="comment"># 对应屏幕的framebuffer</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 开始测试</span></span><br><span class="line">$ ts_calibrate                              <span class="comment"># 五点校验</span></span><br><span class="line">xres = 480, yres = 272</span><br><span class="line">Top left :</span><br><span class="line">Top right :</span><br><span class="line">Bot right :</span><br><span class="line">Bot left :</span><br><span class="line">Center :</span><br><span class="line">$ ts_test                                   <span class="comment"># 开始测试</span></span><br><span class="line">时间: X坐标 Y坐标 是否按下</span><br><span class="line">$ ts_print_raw                              <span class="comment"># 打印原始数据</span></span><br><span class="line">时间: X电压值 Y电压值 是否按下</span><br></pre></td></tr></table></figure>
<hr>
<p><strong><em>原创于 <a href="https://draapho.github.io/">DRA&amp;PHO</a></em></strong></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/18/">18</a><a class="extend next" rel="next" href="/page/5/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="//schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.jpg"
               alt="draapho" />
          <p class="site-author-name" itemprop="name">draapho</p>
          <p class="site-description motion-element" itemprop="description">Embedded System, IoT, M2M</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">120</span>
              <span class="site-state-item-name">posts</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">12</span>
                <span class="site-state-item-name">categories</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">80</span>
                <span class="site-state-item-name">tags</span>
              
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://au.linkedin.com/in/kim-huanqing-yu-67424638" target="_blank" title="Linkedin">
                  
                    <i class="fa fa-fw fa-linkedin-square"></i>
                  
                  Linkedin
                </a>
              </span>
            
          
        </div>

        
        

        
        

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">draapho</span>
</div>

<div class="powered-by">
  Powered by <a class="theme-link" href="https://hexo.io">Hexo</a>
</div>

<div class="theme-info">
  Theme -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.2"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.2"></script>



  



  




  
  
  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length == 0) {
       search_path = "search.xml";
    }
    var path = "/" + search_path;
    // monitor main search box;

    function proceedsearch() {
      $("body").append('<div class="popoverlay">').css('overflow', 'hidden');
      $('.popup').toggle();

    }
    // search function;
    var searchFunc = function(path, search_id, content_id) {
    'use strict';
    $.ajax({
        url: path,
        dataType: "xml",
        async: true,
        success: function( xmlResponse ) {
            // get the contents from search data
            isfetched = true;
            $('.popup').detach().appendTo('.header-inner');
            var datas = $( "entry", xmlResponse ).map(function() {
                return {
                    title: $( "title", this ).text(),
                    content: $("content",this).text(),
                    url: $( "url" , this).text()
                };
            }).get();
            var $input = document.getElementById(search_id);
            var $resultContent = document.getElementById(content_id);
            $input.addEventListener('input', function(){
                var matchcounts = 0;
                var str='<ul class=\"search-result-list\">';
                var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                $resultContent.innerHTML = "";
                if (this.value.trim().length > 1) {
                // perform local searching
                datas.forEach(function(data) {
                    var isMatch = false;
                    var content_index = [];
                    var data_title = data.title.trim().toLowerCase();
                    var data_content = data.content.trim().replace(/<[^>]+>/g,"").toLowerCase();
                    var data_url = decodeURIComponent(data.url);
                    var index_title = -1;
                    var index_content = -1;
                    var first_occur = -1;
                    // only match artiles with not empty titles and contents
                    if(data_title != '') {
                        keywords.forEach(function(keyword, i) {
                            index_title = data_title.indexOf(keyword);
                            index_content = data_content.indexOf(keyword);
                            if( index_title >= 0 || index_content >= 0 ){
                                isMatch = true;
								if (i == 0) {
                                    first_occur = index_content;
                                }
                            } 
							
                        });
                    }
                    // show search results
                    if (isMatch) {
                        matchcounts += 1;
                        str += "<li><a href='"+ data_url +"' class='search-result-title'>"+ data_title +"</a>";
                        var content = data.content.trim().replace(/<[^>]+>/g,"");
                        if (first_occur >= 0) {
                            // cut out 100 characters
                            var start = first_occur - 20;
                            var end = first_occur + 80;
                            if(start < 0){
                                start = 0;
                            }
                            if(start == 0){
                                end = 50;
                            }
                            if(end > content.length){
                                end = content.length;
                            }
                            var match_content = content.substring(start, end);
                            // highlight all keywords
                            keywords.forEach(function(keyword){
                                var regS = new RegExp(keyword, "gi");
                                match_content = match_content.replace(regS, "<b class=\"search-keyword\">"+keyword+"</b>");
                            });

                            str += "<p class=\"search-result\">" + match_content +"...</p>"
                        }
                        str += "</li>";
                    }
                })};
                str += "</ul>";
                if (matchcounts == 0) { str = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>' }
                if (keywords == "") { str = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>' }
                $resultContent.innerHTML = str;
            });
            proceedsearch();
        }
    });}

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched == false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };

    });

    $('.popup-btn-close').click(function(e){
      $('.popup').hide();
      $(".popoverlay").remove();
      $('body').css('overflow', '');
    });
    $('.popup').click(function(e){
      e.stopPropagation();
    });
  </script>


  

  

  

  


</body>
</html>
